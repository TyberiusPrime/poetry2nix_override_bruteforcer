{"info":{"author":"Richard Jones","author_email":"r1chardj0n3s@gmail.com","bugtrack_url":null,"classifiers":[],"description":"euclid\n======\n\nPython module for 2D and 3D graphics-related maths functions: vectors, matrices, quaternions and simple plane/line/sphere geometry.\n\nHistory\n-------\n\nThis library was written in 2006 and [hosted on Google Code](https://code.google.com/archive/p/pyeuclid/) under an LGPL license.  Alex relicensed the code in 2019 under a more permissive BSD license.  It was updated to work with Python 3 soon after, and released as 1.0 in 2020 by the new maintainer, Richard Jones.\n\nThe rest of this README is the original documentation from 2006, converted from reStructured Text to Markdown using cloudconvert.com.\n\nOverview\n--------\n\nThis document describes the `euclid` module, which provides vector, matrix and quaternion classes for 2D and 3D graphics applications. Everything is provided in the `euclid` namespace:\n\n    >>> from euclid import *\n    >>>\n\nType checking of arguments is done with assertions. The advantage of this is that in a usual Python session an exception will be raised earlier rather than later, with a message indicating the expected type. When Python is run with the `-O` or `-OO` flags, assertions are removed and the code executes faster.\n\nVector classes\n--------------\n\nTwo mutable vector types are available: **Vector2** and **Vector3**, for 2D and 3D vectors, respectively. Vectors are assumed to hold floats, but most operations will also work if you use ints or longs instead. Construct a vector in the obvious way:\n\n    >>> Vector2(1.5, 2.0)\n    Vector2(1.50, 2.00)\n\n    >>> Vector3(1.0, 2.0, 3.0)\n    Vector3(1.00, 2.00, 3.00)\n\n### Element access\n\nComponents may be accessed as attributes (examples that follow use **Vector3**, but all results are similar for **Vector2**, using only the *x* and *y* components):\n\n    >>> v = Vector3(1, 2, 3)\n    >>> v.x\n    1\n    >>> v.y\n    2\n    >>> v.z\n    3\n\nVectors support the list interface via slicing:\n\n    >>> v = Vector3(1, 2, 3)\n    >>> len(v)\n    3\n    >>> v[0]\n    1\n    >>> v[:]\n    (1, 2, 3)\n\nYou can also \"swizzle\" the components (*a la* GLSL or Cg):\n\n    >>> v = Vector3(1, 2, 3)\n    >>> v.xyz\n    (1, 2, 3)\n    >>> v.zx\n    (3, 1)\n    >>> v.zzzz\n    (3, 3, 3, 3)\n\nAll of the above accessors are also mutators[1]:\n\n    >>> v = Vector3(1, 2, 3)\n    >>> v.x = 5\n    >>> v\n    Vector3(5.00, 2.00, 3.00)\n    >>> v[1:] = (10, 20)\n    >>> v\n    Vector3(5.00, 10.00, 20.00)\n\n[1] assignment via a swizzle (e.g., `v.xyz = (1, 2, 3)`) is supported only if the `_enable_swizzle_set` variable is set. This is disabled by default, as it impacts on the performance of ordinary attribute setting, and is slower than setting components sequentially anyway.\n\n### Operators\n\nAddition and subtraction are supported via operator overloading (note that in-place operators perform faster than those that create a new object):\n\n    >>> v1 = Vector3(1, 2, 3)\n    >>> v2 = Vector3(4, 5, 6)\n    >>> v1 + v2\n    Vector3(5.00, 7.00, 9.00)\n    >>> v1 -= v2\n    >>> v1\n    Vector3(-3.00, -3.00, -3.00)\n\nMultiplication and division can be performed with a scalar only:\n\n    >>> Vector3(1, 2, 3) * 2\n    Vector3(2.00, 4.00, 6.00)\n    >>> v1 = Vector3(1., 2., 3.)\n    >>> v1 /= 2\n    >>> v1\n    Vector3(0.50, 1.00, 1.50)\n\nThe magnitude of a vector can be found with `abs`:\n\n    >>> v = Vector3(1., 2., 3.)\n    >>> abs(v)\n    3.7416573867739413\n\nA vector can be normalized in-place (note that the in-place method also returns `self`, so you can chain it with further operators):\n\n    >>> v = Vector3(1., 2., 3.)\n    >>> v.normalize()\n    Vector3(0.27, 0.53, 0.80)\n    >>> v\n    Vector3(0.27, 0.53, 0.80)\n\nThe following methods do *not* alter the original vector or their arguments:\n\n`copy()`  \nReturns a copy of the vector. `__copy__` is also implemented.\n\n`magnitude()`  \nReturns the magnitude of the vector; equivalent to `abs(v)`. Example:\n\n    >>> v = Vector3(1., 2., 3.)\n    >>> v.magnitude()\n    3.7416573867739413\n\n`magnitude_squared()`  \nReturns the sum of the squares of each component. Useful for comparing the length of two vectors without the expensive square root operation. Example:\n\n    >>> v = Vector3(1., 2., 3.)\n    >>> v.magnitude_squared()\n    14.0\n\n`normalized()`  \nReturn a unit length vector in the same direction. Note that this method differs from `normalize` in that it does not modify the vector in-place. Example:\n\n    >>> v = Vector3(1., 2., 3.)\n    >>> v.normalized()\n    Vector3(0.27, 0.53, 0.80)\n    >>> v\n    Vector3(1.00, 2.00, 3.00)\n\n`dot(other)`  \nReturn the scalar \"dot\" product of two vectors. Example:\n\n    >>> v1 = Vector3(1., 2., 3.)\n    >>> v2 = Vector3(4., 5., 6.)\n    >>> v1.dot(v2)\n    32.0\n\n`cross()` and `cross(other)`  \nReturn the cross product of a vector (for **Vector2**), or the cross product of two vectors (for **Vector3**). The return type is a vector. Example:\n\n    >>> v1 = Vector3(1., 2., 3.)\n    >>> v2 = Vector3(4., 5., 6.)\n    >>> v1.cross(v2)\n    Vector3(-3.00, 6.00, -3.00)\n\nIn two dimensions there can be no argument to `cross`:\n\n    >>> v1 = Vector2(1., 2.)\n    >>> v1.cross()\n    Vector2(2.00, -1.00)\n\n`reflect(normal)`  \nReturn the vector reflected about the given normal. In two dimensions, *normal* is the normal to a line, in three dimensions it is the normal to a plane. The normal must have unit length. Example:\n\n    >>> v = Vector3(1., 2., 3.)\n    >>> v.reflect(Vector3(0, 1, 0))\n    Vector3(1.00, -2.00, 3.00)\n    >>> v = Vector2(1., 2.)\n    >>> v.reflect(Vector2(1, 0))\n    Vector2(-1.00, 2.00)\n\n`rotate_around(axes, theta)`  \nFor 3D vectors, return the vector rotated around axis by the angle theta.\n\n    >>> v = Vector3(1., 2., 3.)\n    >>> axes = Vector3(1.,1.,0)\n    >>> v.rotate_around(axes,math.pi/4)\n    Vector3(2.65, 0.35, 2.62)\n    \n`angle(other)`  \nReturn the angle between two vectors.\n\n`project(other)`  \nReturn the projection (the component) of the vector on other.\n\nTests for equality include comparing against other sequences:\n\n    >>> v2 = Vector2(1, 2)\n    >>> v2 == Vector2(3, 4)\n    False\n    >>> v2 != Vector2(1, 2)\n    False\n    >>> v2 == (1, 2)\n    True\n\n    >>> v3 = Vector3(1, 2, 3)\n    >>> v3 == Vector3(3, 4, 5)\n    False\n    >>> v3 != Vector3(1, 2, 3)\n    False\n    >>> v3 == (1, 2, 3)\n    True\n\nVectors are not hashable, and hence cannot be put in sets nor used as dictionary keys:\n\n    >>> {Vector2(): 0}\n    Traceback (most recent call last):\n        ...\n    TypeError: unhashable type: 'Vector2'\n\n    >>> {Vector3(): 0}\n    Traceback (most recent call last):\n        ...\n    TypeError: unhashable type: 'Vector3'\n\nMatrix classes\n--------------\n\nTwo matrix classes are supplied, **Matrix3**, a 3x3 matrix for working with 2D affine transformations, and **Matrix4**, a 4x4 matrix for working with 3D affine transformations.\n\nThe default constructor intializes the matrix to the identity:\n\n    >>> Matrix3()\n    Matrix3([    1.00     0.00     0.00\n                 0.00     1.00     0.00\n                 0.00     0.00     1.00])\n    >>> Matrix4()\n    Matrix4([    1.00     0.00     0.00     0.00\n                 0.00     1.00     0.00     0.00\n                 0.00     0.00     1.00     0.00\n                 0.00     0.00     0.00     1.00])\n\n### Element access\n\nInternally each matrix is stored as a set of attributes named `a` to `p`. The layout for Matrix3 is:\n\n    # a b c \n    # e f g \n    # i j k \n\nand for Matrix4:\n\n    # a b c d\n    # e f g h\n    # i j k l\n    # m n o p\n\nIf you wish to set or retrieve a number of elements at once, you can do so with a slice:\n\n    >>> m = Matrix4()\n    >>> m[:]\n    [1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0]\n    >>> m[12:15] = (5, 5, 5)\n    >>> m\n    Matrix4([    1.00     0.00     0.00     5.00\n                 0.00     1.00     0.00     5.00\n                 0.00     0.00     1.00     5.00\n                 0.00     0.00     0.00     1.00])\n\nNote that slices operate in column-major order, which makes them suitable for working directly with OpenGL's `glLoadMatrix` and `glGetFloatv` functions.\n\n### Class constructors\n\nThere are class constructors for the most common types of transform.\n\n`new_identity`  \nEquivalent to the default constructor. Example:\n\n    >>> m = Matrix4.new_identity()\n    >>> m\n    Matrix4([    1.00     0.00     0.00     0.00\n                 0.00     1.00     0.00     0.00\n                 0.00     0.00     1.00     0.00\n                 0.00     0.00     0.00     1.00])\n\n`new_scale(x, y)` and `new_scale(x, y, z)`  \nThe former is defined on **Matrix3**, the latter on **Matrix4**. Equivalent to the OpenGL call `glScalef`. Example:\n\n    >>> m = Matrix4.new_scale(2.0, 3.0, 4.0)\n    >>> m\n    Matrix4([    2.00     0.00     0.00     0.00\n                 0.00     3.00     0.00     0.00\n                 0.00     0.00     4.00     0.00\n                 0.00     0.00     0.00     1.00])\n\n`new_translate(x, y)` and `new_translate(x, y, z)`  \nThe former is defined on **Matrix3**, the latter on **Matrix4**. Equivalent to the OpenGL call `glTranslatef`. Example:\n\n    >>> m = Matrix4.new_translate(3.0, 4.0, 5.0)\n    >>> m\n    Matrix4([    1.00     0.00     0.00     3.00\n                 0.00     1.00     0.00     4.00\n                 0.00     0.00     1.00     5.00\n                 0.00     0.00     0.00     1.00])\n\n`new_rotate(angle)`  \nCreate a **Matrix3** for a rotation around the origin. *angle* is specified in radians, anti-clockwise. This is not implemented in **Matrix4** (see below for equivalent methods). Example:\n\n    >>> import math\n    >>> m = Matrix3.new_rotate(math.pi / 2)\n    >>> m\n    Matrix3([    0.00    -1.00     0.00\n                 1.00     0.00     0.00\n                 0.00     0.00     1.00])\n\nThe following constructors are defined for **Matrix4** only.\n\n`new`  \nConstruct a matrix with 16 values in column-major order.\n\n`new_rotatex(angle)`, `new_rotatey(angle)`, `new_rotatez(angle)`  \nCreate a **Matrix4** for a rotation around the X, Y or Z axis, respectively. *angle* is specified in radians. Example:\n\n    >>> m = Matrix4.new_rotatex(math.pi / 2)\n    >>> m\n    Matrix4([    1.00     0.00     0.00     0.00\n                 0.00     0.00    -1.00     0.00\n                 0.00     1.00     0.00     0.00\n                 0.00     0.00     0.00     1.00])\n\n`new_rotate_axis(angle, axis)`  \nCreate a **Matrix4** for a rotation around the given axis. *angle* is specified in radians, and *axis* must be an instance of **Vector3**. It is not necessary to normalize the axis. Example:\n\n    >>> m = Matrix4.new_rotate_axis(math.pi / 2, Vector3(1.0, 0.0, 0.0))\n    >>> m        \n    Matrix4([    1.00     0.00     0.00     0.00\n                 0.00     0.00    -1.00     0.00\n                 0.00     1.00     0.00     0.00\n                 0.00     0.00     0.00     1.00])\n\n`new_rotate_euler(heading, attitude, bank)`  \nCreate a **Matrix4** for the given Euler rotation. *heading* is a rotation around the Y axis, *attitude* around the X axis and *bank* around the Z axis. All rotations are performed simultaneously, so this method avoids \"gimbal lock\" and is the usual method for implemented 3D rotations in a game. Example:\n\n    >>> m = Matrix4.new_rotate_euler(math.pi / 2, math.pi / 2, 0.0)\n    >>> m\n    Matrix4([    0.00    -0.00     1.00     0.00\n                 1.00     0.00    -0.00     0.00\n                -0.00     1.00     0.00     0.00\n                 0.00     0.00     0.00     1.00])\n\n`new_perspective(fov_y, aspect, near, far)`  \nCreate a **Matrix4** for projection onto the 2D viewing plane. This method is equivalent to the OpenGL call `gluPerspective`. *fov\\_y* is the view angle in the Y direction, in radians. *aspect* is the aspect ration *width* / *height* of the viewing plane. *near* and *far* are the distance to the near and far clipping planes. They must be positive and non-zero. Example:\n\n    >>> m = Matrix4.new_perspective(math.pi / 2, 1024.0 / 768, 1.0, 100.0)\n    >>> m\n    Matrix4([    0.75     0.00     0.00     0.00\n                 0.00     1.00     0.00     0.00\n                 0.00     0.00    -1.02    -2.02\n                 0.00     0.00    -1.00     0.00])\n\n### Operators\n\nMatrices of the same dimension may be multiplied to give a new matrix. For example, to create a transform which translates and scales:\n\n    >>> m1 = Matrix3.new_translate(5.0, 6.0)\n    >>> m2 = Matrix3.new_scale(1.0, 2.0)\n    >>> m1 * m2\n    Matrix3([    1.00     0.00     5.00\n                 0.00     2.00     6.00\n                 0.00     0.00     1.00])\n\nNote that multiplication is not commutative (the order that you apply transforms matters):\n\n    >>> m2 * m1\n    Matrix3([    1.00     0.00     5.00\n                 0.00     2.00    12.00\n                 0.00     0.00     1.00])\n\nIn-place multiplication is also permitted (and optimised):\n\n    >>> m1 *= m2\n    >>> m1\n    Matrix3([    1.00     0.00     5.00\n                 0.00     2.00     6.00\n                 0.00     0.00     1.00])\n\nMultiplying a matrix by a vector returns a vector, and is used to transform a vector:\n\n    >>> m1 = Matrix3.new_rotate(math.pi / 2)\n    >>> m1 * Vector2(1.0, 1.0)\n    Vector2(-1.00, 1.00)\n\nNote that translations have no effect on vectors. They do affect points, however:\n\n    >>> m1 = Matrix3.new_translate(5.0, 6.0)\n    >>> m1 * Vector2(1.0, 2.0)\n    Vector2(1.00, 2.00)\n    >>> m1 * Point2(1.0, 2.0)\n    Point2(6.00, 8.00)\n\nMultiplication is currently incorrect between matrices and vectors -- the projection component is ignored. Use the **Matrix4.transform** method instead.\n\nMatrix4 also defines **transpose** (in-place), **transposed** (functional), **determinant** and **inverse** (functional) methods.\n\nA **Matrix3** can be multiplied with a **Vector2** or any of the 2D geometry objects (**Point2**, **Line2**, **Circle**, etc).\n\nA **Matrix4** can be multiplied with a **Vector3** or any of the 3D geometry objects (**Point3**, **Line3**, **Sphere**, etc).\n\nFor convenience, each of the matrix constructors are also available as in-place operators. For example, instead of writing:\n\n    >>> m1 = Matrix3.new_translate(5.0, 6.0)\n    >>> m2 = Matrix3.new_scale(1.0, 2.0)\n    >>> m1 *= m2\n\nyou can apply the scale directly to *m1*:\n\n    >>> m1 = Matrix3.new_translate(5.0, 6.0)\n    >>> m1.scale(1.0, 2.0)\n    Matrix3([    1.00     0.00     5.00\n                 0.00     2.00     6.00\n                 0.00     0.00     1.00])\n    >>> m1\n    Matrix3([    1.00     0.00     5.00\n                 0.00     2.00     6.00\n                 0.00     0.00     1.00])\n\nNote that these methods operate in-place (they modify the original matrix), and they also return themselves as a result. This allows you to chain transforms together directly:\n\n    >>> Matrix3().translate(1.0, 2.0).rotate(math.pi / 2).scale(4.0, 4.0)\n    Matrix3([    0.00    -4.00     1.00\n                 4.00     0.00     2.00\n                 0.00     0.00     1.00])\n\nAll constructors have an equivalent in-place method. For **Matrix3**, they are `identity`, `translate`, `scale` and `rotate`. For **Matrix4**, they are `identity`, `translate`, `scale`, `rotatex`, `rotatey`, `rotatez`, `rotate_axis` and `rotate_euler`. Both **Matrix3** and **Matrix4** also have an in-place `transpose` method.\n\nThe `copy` method is also implemented in both matrix classes and behaves in the obvious way.\n\nQuaternions\n-----------\n\nA quaternion represents a three-dimensional rotation or reflection transformation. They are the preferred way to store and manipulate rotations in 3D applications, as they do not suffer the same numerical degredation that matrices do.\n\nThe quaternion constructor initializes to the identity transform:\n\n    >>> q = Quaternion()\n    >>> q\n    Quaternion(real=1.00, imag=<0.00, 0.00, 0.00>)\n\n### Element access\n\nInternally, the quaternion is stored as four attributes: `x`, `y` and `z` forming the imaginary vector, and `w` the real component.\n\n### Constructors\n\nRotations can be formed using the constructors:\n\n`new_identity()`  \nEquivalent to the default constructor.\n\n`new_rotate_axis(angle, axis)`  \nEquivalent to the Matrix4 constructor of the same name. *angle* is specified in radians, *axis* is an instance of **Vector3**. It is not necessary to normalize the axis. Example:\n\n    >>> q = Quaternion.new_rotate_axis(math.pi / 2, Vector3(1, 0, 0))\n    >>> q\n    Quaternion(real=0.71, imag=<0.71, 0.00, 0.00>)\n\n`new_rotate_euler(heading, attitude, bank)`  \nEquivalent to the Matrix4 constructor of the same name. *heading* is a rotation around the Y axis, *attitude* around the X axis and *bank* around the Z axis. All angles are given in radians. Example:\n\n    >>> q = Quaternion.new_rotate_euler(math.pi / 2, math.pi / 2, 0)\n    >>> q\n    Quaternion(real=0.50, imag=<0.50, 0.50, 0.50>)\n\n`new_interpolate(q1, q2, t)`  \nCreate a quaternion which gives a (SLERP) interpolated rotation between *q1* and *q2*. *q1* and *q2* are instances of **Quaternion**, and *t* is a value between 0.0 and 1.0. For example:\n\n    >>> q1 = Quaternion.new_rotate_axis(math.pi / 2, Vector3(1, 0, 0))\n    >>> q2 = Quaternion.new_rotate_axis(math.pi / 2, Vector3(0, 1, 0))\n    >>> for i in range(11):\n    ...     print Quaternion.new_interpolate(q1, q2, i / 10.0)\n    ...\n    Quaternion(real=0.71, imag=<0.71, 0.00, 0.00>)\n    Quaternion(real=0.75, imag=<0.66, 0.09, 0.00>)\n    Quaternion(real=0.78, imag=<0.61, 0.17, 0.00>)\n    Quaternion(real=0.80, imag=<0.55, 0.25, 0.00>)\n    Quaternion(real=0.81, imag=<0.48, 0.33, 0.00>)\n    Quaternion(real=0.82, imag=<0.41, 0.41, 0.00>)\n    Quaternion(real=0.81, imag=<0.33, 0.48, 0.00>)\n    Quaternion(real=0.80, imag=<0.25, 0.55, 0.00>)\n    Quaternion(real=0.78, imag=<0.17, 0.61, 0.00>)\n    Quaternion(real=0.75, imag=<0.09, 0.66, 0.00>)\n    Quaternion(real=0.71, imag=<0.00, 0.71, 0.00>)\n\n### Operators\n\nQuaternions may be multiplied to compound rotations. For example, to rotate 90 degrees around the X axis and then 90 degrees around the Y axis:\n\n    >>> q1 = Quaternion.new_rotate_axis(math.pi / 2, Vector3(1, 0, 0))\n    >>> q2 = Quaternion.new_rotate_axis(math.pi / 2, Vector3(0, 1, 0))\n    >>> q1 * q2\n    Quaternion(real=0.50, imag=<0.50, 0.50, 0.50>)\n\nMultiplying a quaternion by a vector gives a vector, transformed appropriately:\n\n    >>> q = Quaternion.new_rotate_axis(math.pi / 2, Vector3(0, 1, 0))\n    >>> q * Vector3(1.0, 0, 0)\n    Vector3(0.00, 0.00, -1.00)\n\nSimilarly, any 3D object can be multiplied (e.g., **Point3**, **Line3**, **Sphere**, etc):\n\n    >>> q * Ray3(Point3(1., 1., 1.), Vector3(1., 1., 1.))\n    Ray3(<1.00, 1.00, -1.00> + u<1.00, 1.00, -1.00>)\n\nAs with the matrix classes, the constructors are also available as in-place operators. These are named `identity`, `rotate_euler` and `rotate_axis`. For example:\n\n    >>> q1 = Quaternion()\n    >>> q1.rotate_euler(math.pi / 2, math.pi / 2, 0)\n    Quaternion(real=0.50, imag=<0.50, 0.50, 0.50>)\n    >>> q1\n    Quaternion(real=0.50, imag=<0.50, 0.50, 0.50>)\n\nQuaternions are usually unit length, but you may wish to use sized quaternions. In this case, you can find the magnitude using `abs`, `magnitude` and `magnitude_squared`, as with the vector classes. Example:\n\n    >>> q1 = Quaternion()\n    >>> abs(q1)\n    1.0\n    >>> q1.magnitude()\n    1.0\n\nSimilarly, the class implements `normalize` and `normalized` in the same way as the vectors.\n\nThe following methods do not alter the quaternion:\n\n`conjugated()`  \nReturns a quaternion that is the conjugate of the instance. For example:\n\n    >>> q1 = Quaternion.new_rotate_axis(math.pi / 2, Vector3(1, 0, 0))\n    >>> q1.conjugated()\n    Quaternion(real=0.71, imag=<-0.71, -0.00, -0.00>)\n    >>> q1\n    Quaternion(real=0.71, imag=<0.71, 0.00, 0.00>)\n\n`get_angle_axis()`  \nReturns a tuple (angle, axis), giving the angle to rotate around an axis equivalent to the quaternion. For example:\n\n    >>> q1 = Quaternion.new_rotate_axis(math.pi / 2, Vector3(1, 0, 0))\n    >>> q1.get_angle_axis()\n    (1.5707963267948966, Vector3(1.00, 0.00, 0.00))\n\n`get_matrix()`  \nReturns a **Matrix4** implementing the transformation of the quaternion. For example:\n\n    >>> q1 = Quaternion.new_rotate_axis(math.pi / 2, Vector3(1, 0, 0))\n    >>> q1.get_matrix()\n    Matrix4([    1.00     0.00     0.00     0.00\n                 0.00     0.00    -1.00     0.00\n                 0.00     1.00     0.00     0.00\n                 0.00     0.00     0.00     1.00])\n\n2D Geometry\n-----------\n\nThe following classes are available for dealing with simple 2D geometry. The interface to each shape is similar; in particular, the `connect` and `distance` methods are defined identically for each.\n\nFor example, to find the closest point on a line to a circle:\n\n    >>> circ = Circle(Point2(3., 2.), 2.)\n    >>> line = Line2(Point2(0., 0.), Point2(-1., 1.))\n    >>> line.connect(circ).p1\n    Point2(0.50, -0.50)\n\nTo find the corresponding closest point on the circle to the line:\n\n    >>> line.connect(circ).p2\n    Point2(1.59, 0.59)\n\n### Point2\n\nA point on a 2D plane. Construct in the obvious way:\n\n    >>> p = Point2(1.0, 2.0)\n    >>> p\n    Point2(1.00, 2.00)\n\n**Point2** subclasses **Vector2**, so all of **Vector2** operators and methods apply. In particular, subtracting two points gives a vector:\n\n    >>> Point2(2.0, 3.0) - Point2(1.0, 0.0)\n    Vector2(1.00, 3.00)\n\nThe following methods are also defined:\n\n`connect(other)`  \nReturns a **LineSegment2** which is the minimum length line segment that can connect the two shapes. *other* may be a **Point2**, **Line2**, **Ray2**, **LineSegment2** or **Circle**.\n\n`distance(other)`  \nReturns the absolute minimum distance to *other*. Internally this simply returns the length of the result of `connect`.\n\n### Line2, Ray2, LineSegment2\n\nA **Line2** is a line on a 2D plane extending to infinity in both directions; a **Ray2** has a finite end-point and extends to infinity in a single direction; a **LineSegment2** joins two points.\n\nAll three classes support the same constructors, operators and methods, but may behave differently when calculating intersections etc.\n\nYou may construct a line, ray or line segment using any of:\n\n-   another line, ray or line segment\n-   two points\n-   a point and a vector\n-   a point, a vector and a length\n\nFor example:\n\n    >>> Line2(Point2(1.0, 1.0), Point2(2.0, 3.0))\n    Line2(<1.00, 1.00> + u<1.00, 2.00>)\n    >>> Line2(Point2(1.0, 1.0), Vector2(1.0, 2.0))\n    Line2(<1.00, 1.00> + u<1.00, 2.00>)\n    >>> Ray2(Point2(1.0, 1.0), Vector2(1.0, 2.0), 1.0)\n    Ray2(<1.00, 1.00> + u<0.45, 0.89>)\n\nInternally, lines, rays and line segments store a Point2 *p* and a Vector2 *v*. You can also access (but not set) the two endpoints *p1* and *p2*. These may or may not be meaningful for all types of lines.\n\nThe following methods are supported by all three classes:\n\n`intersect(other)`  \nIf *other* is a **Line2**, **Ray2** or **LineSegment2**, returns a **Point2** of intersection, or None if the lines are parallel.\n\nIf *other* is a **Circle**, returns a **LineSegment2** or **Point2** giving the part of the line that intersects the circle, or None if there is no intersection.\n\n`connect(other)`  \nReturns a **LineSegment2** which is the minimum length line segment that can connect the two shapes. For two parallel lines, this line segment may be in an arbitrary position. *other* may be a **Point2**, **Line2**, **Ray2**, **LineSegment2** or **Circle**.\n\n`distance(other)`  \nReturns the absolute minimum distance to *other*. Internally this simply returns the length of the result of `connect`.\n\n**LineSegment2** also has a *length* property which is read-only.\n\n### Circle\n\nCircles are constructed with a center **Point2** and a radius:\n\n    >>> c = Circle(Point2(1.0, 1.0), 0.5)\n    >>> c\n    Circle(<1.00, 1.00>, radius=0.50)\n\nInternally there are two attributes: *c*, giving the center point and *r*, giving the radius.\n\nThe following methods are supported:\n\n`intersect(other)`  \nIf *other* is a **Line2**, **Ray2** or **LineSegment2**, returns a **LineSegment2** giving the part of the line that intersects the circle, or None if there is no intersection.\n\n`connect(other)`  \nReturns a **LineSegment2** which is the minimum length line segment that can connect the two shapes. *other* may be a **Point2**, **Line2**, **Ray2**, **LineSegment2** or **Circle**.\n\n`distance(other)`  \nReturns the absolute minimum distance to *other*. Internally this simply returns the length of the result of `connect`.\n\n3D Geometry\n-----------\n\nThe following classes are available for dealing with simple 3D geometry. The interfaces are very similar to the 2D classes (but note that you cannot mix and match 2D and 3D operations).\n\nFor example, to find the closest point on a line to a sphere:\n\n    >>> sphere = Sphere(Point3(1., 2., 3.,), 2.)\n    >>> line = Line3(Point3(0., 0., 0.), Point3(-1., -1., 0.))\n    >>> line.connect(sphere).p1\n    Point3(1.50, 1.50, 0.00)\n\nTo find the corresponding closest point on the sphere to the line:\n\n    >>> line.connect(sphere).p2\n    Point3(1.32, 1.68, 1.05)\n\nXXX I have not checked if these are correct.\n\n### Point3\n\nA point on a 3D plane. Construct in the obvious way:\n\n    >>> p = Point3(1.0, 2.0, 3.0)\n    >>> p\n    Point3(1.00, 2.00, 3.00)\n\n**Point3** subclasses **Vector3**, so all of **Vector3** operators and methods apply. In particular, subtracting two points gives a vector:\n\n    >>> Point3(1.0, 2.0, 3.0) - Point3(1.0, 0.0, -2.0)\n    Vector3(0.00, 2.00, 5.00)\n\nThe following methods are also defined:\n\n`intersect(other)`  \nIf *other* is a **Sphere**, returns `True` iff the point lies within the sphere.\n\n`connect(other)`  \nReturns a **LineSegment3** which is the minimum length line segment that can connect the two shapes. *other* may be a **Point3**, **Line3**, **Ray3**, **LineSegment3**, **Sphere** or **Plane**.\n\n`distance(other)`  \nReturns the absolute minimum distance to *other*. Internally this simply returns the length of the result of `connect`.\n\n### Line3, Ray3, LineSegment3\n\nA **Line3** is a line on a 3D plane extending to infinity in both directions; a **Ray3** has a finite end-point and extends to infinity in a single direction; a **LineSegment3** joins two points.\n\nAll three classes support the same constructors, operators and methods, but may behave differently when calculating intersections etc.\n\nYou may construct a line, ray or line segment using any of:\n\n-   another line, ray or line segment\n-   two points\n-   a point and a vector\n-   a point, a vector and a length\n\nFor example:\n\n    >>> Line3(Point3(1.0, 1.0, 1.0), Point3(1.0, 2.0, 3.0))\n    Line3(<1.00, 1.00, 1.00> + u<0.00, 1.00, 2.00>)\n    >>> Line3(Point3(0.0, 1.0, 1.0), Vector3(1.0, 1.0, 2.0))\n    Line3(<0.00, 1.00, 1.00> + u<1.00, 1.00, 2.00>)\n    >>> Ray3(Point3(1.0, 1.0, 1.0), Vector3(1.0, 1.0, 2.0), 1.0)\n    Ray3(<1.00, 1.00, 1.00> + u<0.41, 0.41, 0.82>)\n\nInternally, lines, rays and line segments store a Point3 *p* and a Vector3 *v*. You can also access (but not set) the two endpoints *p1* and *p2*. These may or may not be meaningful for all types of lines.\n\nThe following methods are supported by all three classes:\n\n`intersect(other)`  \nIf *other* is a **Sphere**, returns a **LineSegment3** which is the intersection of the sphere and line, or `None` if there is no intersection.\n\nIf *other* is a **Plane**, returns a **Point3** of intersection, or `None`.\n\n`connect(other)`  \nReturns a **LineSegment3** which is the minimum length line segment that can connect the two shapes. For two parallel lines, this line segment may be in an arbitrary position. *other* may be a **Point3**, **Line3**, **Ray3**, **LineSegment3**, **Sphere** or **Plane**.\n\n`distance(other)`  \nReturns the absolute minimum distance to *other*. Internally this simply returns the length of the result of `connect`.\n\n**LineSegment3** also has a *length* property which is read-only.\n\n### Sphere\n\nSpheres are constructed with a center **Point3** and a radius:\n\n    >>> s = Sphere(Point3(1.0, 1.0, 1.0), 0.5)\n    >>> s\n    Sphere(<1.00, 1.00, 1.00>, radius=0.50)\n\nInternally there are two attributes: *c*, giving the center point and *r*, giving the radius.\n\nThe following methods are supported:\n\n`intersect(other)`:  \nIf *other* is a **Point3**, returns `True` iff the point lies within the sphere.\n\nIf *other* is a **Line3**, **Ray3** or **LineSegment3**, returns a **LineSegment3** giving the intersection, or `None` if the line does not intersect the sphere.\n\n`connect(other)`  \nReturns a **LineSegment3** which is the minimum length line segment that can connect the two shapes. *other* may be a **Point3**, **Line3**, **Ray3**, **LineSegment3**, **Sphere** or **Plane**.\n\n`distance(other)`  \nReturns the absolute minimum distance to *other*. Internally this simply returns the length of the result of `connect`.\n\n### Plane\n\nPlanes can be constructed with any of:\n\n-   three **Point3**'s lying on the plane\n-   a **Point3** on the plane and the **Vector3** normal\n-   a **Vector3** normal and *k*, described below.\n\nInternally, planes are stored with the normal *n* and constant *k* such that *n.p* = *k* for any point on the plane *p*.\n\nThe following methods are supported:\n\n`intersect(other)`  \nIf *other* is a **Line3**, **Ray3** or **LineSegment3**, returns a **Point3** of intersection, or `None` if there is no intersection.\n\nIf *other* is a **Plane**, returns the **Line3** of intersection.\n\n`connect(other)`  \nReturns a **LineSegment3** which is the minimum length line segment that can connect the two shapes. *other* may be a **Point3**, **Line3**, **Ray3**, **LineSegment3**, **Sphere** or **Plane**.\n\n`distance(other)`  \nReturns the absolute minimum distance to *other*. Internally this simply returns the length of the result of `connect`.","description_content_type":"","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/r1chardj0n3s/euclid","keywords":"","license":"","maintainer":"","maintainer_email":"","name":"euclid","package_url":"https://pypi.org/project/euclid/","platform":"","project_url":"https://pypi.org/project/euclid/","project_urls":{"Homepage":"https://github.com/r1chardj0n3s/euclid"},"provides_extra":null,"release_url":"https://pypi.org/project/euclid/1.2/","requires_dist":null,"requires_python":"","summary":"2D and 3D vector, matrix, quaternion and geometry module","version":"1.2","yanked":false,"yanked_reason":null},"last_serial":8305341,"releases":{"0.01":[{"comment_text":"","digests":{"blake2b_256":"bbb3167a013e6d92de729294ebddde295169d45551fab875a4504862b069760c","md5":"f639e7234dcf08f0721cb537c9e3ca8e","sha256":"d0c8d980405abdc035f6957377ab3b5414bdb14bb155c82b92702365bd9dbce6"},"downloads":-1,"filename":"euclid-0.01.tar.gz","has_sig":false,"md5_digest":"f639e7234dcf08f0721cb537c9e3ca8e","packagetype":"sdist","python_version":"source","requires_python":null,"size":13134,"upload_time":"2013-02-12T17:43:51","upload_time_iso_8601":"2013-02-12T17:43:51.942310Z","url":"https://files.pythonhosted.org/packages/bb/b3/167a013e6d92de729294ebddde295169d45551fab875a4504862b069760c/euclid-0.01.tar.gz","yanked":false,"yanked_reason":null}],"1.0":[{"comment_text":"","digests":{"blake2b_256":"fdb77f97e942d68dc3c0bef15feef19609387cef26e0ea40cf7d4d4e1d9c887d","md5":"0810d6b7d75dab99ce12d055890a278c","sha256":"782226acb4138b16086817947023d4470339f1b8e74e72c20ff456751c4078d1"},"downloads":-1,"filename":"euclid-1.0.tar.gz","has_sig":false,"md5_digest":"0810d6b7d75dab99ce12d055890a278c","packagetype":"sdist","python_version":"source","requires_python":null,"size":12940,"upload_time":"2020-09-28T05:21:24","upload_time_iso_8601":"2020-09-28T05:21:24.646030Z","url":"https://files.pythonhosted.org/packages/fd/b7/7f97e942d68dc3c0bef15feef19609387cef26e0ea40cf7d4d4e1d9c887d/euclid-1.0.tar.gz","yanked":false,"yanked_reason":null}],"1.1":[{"comment_text":"","digests":{"blake2b_256":"a7df0f6dbfc6db4a6eab67bec051476eb4edd53bd9664f908ccf8eec3bc47b9c","md5":"75ac1d7d3587419a1d5920c5f4911b3b","sha256":"f6ae30a1cdc3881b68b7b6165c0e4fab5ece571b90790d245714f72a49eff39d"},"downloads":-1,"filename":"euclid-1.1.tar.gz","has_sig":false,"md5_digest":"75ac1d7d3587419a1d5920c5f4911b3b","packagetype":"sdist","python_version":"source","requires_python":null,"size":20284,"upload_time":"2020-09-28T05:24:26","upload_time_iso_8601":"2020-09-28T05:24:26.927447Z","url":"https://files.pythonhosted.org/packages/a7/df/0f6dbfc6db4a6eab67bec051476eb4edd53bd9664f908ccf8eec3bc47b9c/euclid-1.1.tar.gz","yanked":false,"yanked_reason":null}],"1.2":[{"comment_text":"","digests":{"blake2b_256":"e0dca14aa837b71be7e0107710ff91cccaeebaba43c0acb732480d1180b98e22","md5":"ac0723b9755e7c432189618cf87dd8c7","sha256":"f179506dc6bb3c870e2002ad4658c53a02e518399188c2b47d955b311c97d66b"},"downloads":-1,"filename":"euclid-1.2.tar.gz","has_sig":false,"md5_digest":"ac0723b9755e7c432189618cf87dd8c7","packagetype":"sdist","python_version":"source","requires_python":null,"size":26150,"upload_time":"2020-09-30T09:10:27","upload_time_iso_8601":"2020-09-30T09:10:27.357911Z","url":"https://files.pythonhosted.org/packages/e0/dc/a14aa837b71be7e0107710ff91cccaeebaba43c0acb732480d1180b98e22/euclid-1.2.tar.gz","yanked":false,"yanked_reason":null}]},"urls":[{"comment_text":"","digests":{"blake2b_256":"e0dca14aa837b71be7e0107710ff91cccaeebaba43c0acb732480d1180b98e22","md5":"ac0723b9755e7c432189618cf87dd8c7","sha256":"f179506dc6bb3c870e2002ad4658c53a02e518399188c2b47d955b311c97d66b"},"downloads":-1,"filename":"euclid-1.2.tar.gz","has_sig":false,"md5_digest":"ac0723b9755e7c432189618cf87dd8c7","packagetype":"sdist","python_version":"source","requires_python":null,"size":26150,"upload_time":"2020-09-30T09:10:27","upload_time_iso_8601":"2020-09-30T09:10:27.357911Z","url":"https://files.pythonhosted.org/packages/e0/dc/a14aa837b71be7e0107710ff91cccaeebaba43c0acb732480d1180b98e22/euclid-1.2.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[]}
