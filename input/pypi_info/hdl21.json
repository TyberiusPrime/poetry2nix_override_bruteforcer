{"info":{"author":"Thomas Pluck, Kennedy Caisley, Zeyi Wang, Arya Reais-Parsi, Vighnesh Iyer","author_email":"Dan Fritchman <dan@fritch.mn>, Curtis Mayberry <Curtisma3@gmail.com>","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Programming Language :: Python","Topic :: Scientific/Engineering :: Electronic Design Automation (EDA)"],"description":"# HDL21\n\n## Analog Hardware Description Library in Python\n\n[![pypi](https://img.shields.io/badge/pypi-hdl21-blue)](https://pypi.org/project/hdl21/)\n[![python-versions](https://img.shields.io/badge/python-3.7_3.8_3.9_3.10_3.11-blue)](https://codecov.io/gh/dan-fritchman/Hdl21)\n[![test](https://github.com/dan-fritchman/Hdl21/actions/workflows/test.yaml/badge.svg)](https://github.com/dan-fritchman/Hdl21/actions/workflows/test.yaml)\n[![codecov](https://codecov.io/gh/dan-fritchman/Hdl21/branch/main/graph/badge.svg?token=f8LKUqEPdq)](https://codecov.io/gh/dan-fritchman/Hdl21)\n\nHdl21 is a [hardware description library](https://en.wikipedia.org/wiki/Hardware_description_language) embedded in Python.\nIt is targeted for analog and custom integrated circuits, and for maximum productivity with minimum fancy-programming skill.\n\n## Contents\n\n- [Installation](#installation)\n- [Modules](#modules)\n- [Signals](#signals), [Ports](#signals), and [Connections](#connections)\n- [Generators](#generators) and [Parameters](#parameters)\n- [Primitive Elements and External Modules](#primitives-and-external-modules)\n- [Spice-Class Simulation](#spice-class-simulation)\n- [Process Technologies (PDKs)](#process-technologies)\n- [Bundles](#bundles)\n- [Examples](#examples)\n- [Related Projects](#related-projects)\n\n## Installation\n\n```\npip install hdl21\n```\n\nThat's it. No crazy build step, no crazy dependencies, no crazy EDA stuff, no \"clone and _just_ modify these 300 things\", no `source`ing, none of that. Hdl21 is pure Python, and is designed to be as easy to install as any other Python package.\n\n## Modules\n\nHdl21's primary unit of hardware reuse is the `Module`. Think of it as Verilog's `module`, or VHDL's `entity`, or SPICE's `subckt`. Better yet if you are used to graphical schematics, think of it as the content of a schematic. Hdl21 `Modules` are containers of a handful of `hdl21` types. Think of them as including:\n\n- Instances of other `Modules`\n- Connections between them, defined by `Signals` and `Ports`\n- Fancy combinations thereof, covered later\n\nAn example `Module`:\n\n```python\nimport hdl21 as h\n\nm = h.Module(name=\"MyModule\")\nm.i = h.Input()\nm.o = h.Output(width=8)\nm.s = h.Signal()\nm.a = AnotherModule()\n```\n\nIn addition to the procedural-syntax shown above, `Modules` can also be defined through a `class`-based syntax by applying the `hdl21.module` decorator to a class-definition.\n\n```python\nimport hdl21 as h\n\n@h.module\nclass MyModule:\n    i = h.Input()\n    o = h.Output(width=8)\n    s = h.Signal()\n    a = AnotherModule()\n```\n\nThis class-based syntax produces identical results to the procedural code-block above. Its declarative style can be much more natural and expressive in many contexts, especially for designers familiar with popular HDLs.\n\nCreation of `Module` signal-attributes is generally performed by the built-in `Signal`, `Port`, `Input`, and `Output` constructors. Each comes with a \"plural version\" (`Input*s*` etc.) which creates several identical objects at once:\n\n```python\nimport hdl21 as h\n\n@h.module\nclass MyModule:\n    a, b = h.Inputs(2)\n    c, d, e = h.Outputs(3, width=16)\n    z, y, x, w = h.Signals(4)\n```\n\n## Signals\n\nHdl21's primary connection type is `Signal`. Think of it as Verilog's `wire`, or a node in that schematic. Each `Signal` has an integer-valued bus `width` field, and can be connected to any other equal-width `Port`.\n\nA subset of `Signals` are exposed outside their parent `Module`. These externally-connectable signals are referred to as `Ports`. Hdl21 provides four port constructors: `Input`, `Output`, `Inout`, and `Port`. The last creates a directionless (or direction unspecified) port akin to those of common spice-level languages.\n\n### Connections\n\nPopular HDLs generally feature one of two forms of connection semantics. Verilog, VHDL, and most dedicated HDLs use \"connect by call\" semantics, in which signal-objects are first declared, then passed as function-call-style arguments to instances of other modules.\n\n```verilog\nmodule my_module();\n  logic a, b, c;                              // Declare signals\n  another_module i1 (a, b, c);                // Create an instance\n  another_module i2 (.a(a), .b(b), .c(c));    // Another instance, connected by-name\nendmodule\n```\n\nChisel, in contrast, uses \"connection by assignment\" - more literally using the walrus `:=` operator. Instances of child modules are created first, and their ports are directly walrus-connected to one another. No local-signal objects ever need be declared in the instantiating parent module.\n\n```scala\nclass MyModule extends Module {\n  // Create Module Instances\n  val i1 = Module(new AnotherModule)\n  val i2 = Module(new AnotherModule)\n  // Wire them directly to one another\n  i1.io.a := i2.io.a\n  i1.io.b := i2.io.b\n  i1.io.c := i2.io.c\n}\n```\n\nEach can be more concise and expressive depending on context. Hdl21 `Modules` support **both** connect-by-call and connect-by-assignment forms.\n\nConnections by assignment are performed by assigning either a `Signal` or another instance's `Port` to an attribute of a Module-Instance.\n\n```python\n# Create a module\nm = h.Module()\n# Create its internal Signals\nm.a, m.b, m.c = h.Signals(3)\n# Create an Instance\nm.i1 = AnotherModule()\n# And wire them up\nm.i1.a = m.a\nm.i1.b = m.b\nm.i1.c = m.c\n```\n\nThis also works without the parent-module `Signals`:\n\n```python\n# Create a module\nm = h.Module()\n# Create the Instances\nm.i1 = AnotherModule()\nm.i2 = AnotherModule()\n# And wire them up\nm.i1.a = m.i2.a\nm.i1.b = m.i2.b\nm.i1.c = m.i2.c\n```\n\nInstances can instead be connected by call:\n\n```python\n# Create a module\nm = h.Module()\n# Create the Instances\nm.i1 = AnotherModule()\nm.i2 = AnotherModule()\n# Call one to connect them\nm.i1(a=m.i2.a, b=m.i2.b, c=m.i2.c)\n```\n\nThese connection-calls can also be performed inline, as the instances are being created.\n\n```python\n# Create a module\nm = h.Module()\n# Create the Instance `i1`\nm.i1 = AnotherModule()\n# Create another Instance `i2`, and connect to `i1`\nm.i2 = AnotherModule(a=m.i1.a, b=m.i1.b, c=m.i1.c)\n```\n\nThese methods hides some of what happens under the hood of HDL21 for ease-of-use. A more thorough method of defining objects, especially in `Generator`s seen below, leverage endpoints in the `Module` and `Instance` APIs:\n\n`h.Module.add` is used to add either `Signal` or `Instance`s instantiated in the usual way and also allows the use of an optional `name` keyword argument which names the newly added object so it can be accessed using the methods we've already described above.\n\n`h.Module.get` is used to get the `Signal` or `Instance` with a given name from a module via a single argument in string form.\n\n`h.Instance.connect` takes two arguments, the first a string referring to an `Instance`'s available ports and the second refers to any \"connectable\" object which can be of the type `Signal`, `PortRef`, `Slice` or `Concat`.\n\n### Slicing\n\n`Signal` objects are equipped with a `width` keyword argument, which determines the width of a signal bus. This creates a 1D array that can accessed using Python's usual slicing syntax used with lists:\n\n```python\nsig1 = h.Signal(width=12)\nsig2 = h.Input(width=6)\n# Map sig2 signals to even numbered sig1 signals\nsig2 = sig1[::2]\n```\n\nNOTE: the slicing provided works by creating a reference to the underlying signals to be mapped, so at this time can't be used to *set* connections but only *get* connections. That is, the following will raise an error:\n\n```python\nsig1 = h.Signal(width=12)\nsig2 = h.Input(width=6)\n# Map sig2 signals to even numbered sig1 signals\nsig1[::2] = sig2\n```\n\n### Concatenation\n\n`Signal`'s can be concatenated to make wider signal buses that you can use to interface with between buses of variable width. This is done using the `Concat` command:\n\n```python\na = h.Signal()\nb = h.Signal(width=2)\n\n# This is a Concat with two parts\n# that is resolved into signal bus\n# with a width of 3.\nc = h.Concat(a,b)\n```\n\nThe Concat command can be used with an arbitrary number of `Signal`s, as well as recursively to create heirarchical `Concat` structures:\n\n```python\na = h.Signal()\nb = h.Signal(width=2)\nc = h.Signal(width=3)\n\n# This is a Concat with three parts\n# it is resolved to a width-6 bus\nd = h.Concat(a,b,c)\n\n# This is a Concat with two parts\n# with objects 2-part Concat and c\n# it is flattened to the same width-6 bus\nd = h.Concat(h.Concat(a,b),c)\n```\n\n### Debugging Tips\n\nEach `Module` has an attribute called `ports` and `signals` which store what they are labelled respectively. Taking either of these, you can examine individual `Signal`s to see if they've been correctly connected by checking their individual `_slices`, `_concats` and `_connected_ports` attributes.\n\nWhereas, `Instances` contain attributes `conns` which list what objects an `Instance`'s ports are connected to and `_refs` which keeps track of where `PortRef`s for a given `Instance` are being distributed to other `Module`s and `Instance`s in your program.\n\n## Generators\n\nHdl21 `Modules` are \"plain old data\". They require no runtime or execution environment. They can be (and are!) fully represented in markup languages such as ProtoBuf, JSON, and YAML. The power of embedding `Modules` in a general-purpose programming language lies in allowing code to create and manipulate them. Hdl21's `Generators` are functions which produce `Modules`, and have a number of built-in features to aid embedding in a hierarchical hardware tree.\n\nIn other words:\n\n- `Modules` are \"structs\". `Generator`s are _functions_ which return `Modules`.\n- `Generators` are code. `Modules` are data.\n- `Generators` require a runtime environment. `Modules` do not.\n\nCreating a generator just requires applying the `@hdl21.generator` decorator to a Python function:\n\n```python\nimport hdl21 as h\n\n@h.generator\ndef MyFirstGenerator(params: MyParams) -> h.Module:\n    # A very exciting first generator function\n    m = h.Module()\n    m.i = h.Input(width=params.w)\n    return m\n```\n\nThe generator-function body can define a `Module` however it likes - procedurally or via the class-style syntax.\n\n```python\n@h.generator\ndef MySecondGenerator(params: MyParams) -> h.Module:\n    # A very exciting (second) generator function\n    @h.module\n    class MySecondGen:\n        i = h.Input(width=params.w)\n    return MySecondGen\n```\n\nOr any combination of the two:\n\n```python\n@h.generator\ndef MyThirdGenerator(params: MyParams) -> h.Module:\n    # Create an internal Module\n    @h.module\n    class Inner:\n        i = h.Input(width=params.w)\n\n    # Manipulate it a bit\n    Inner.o = h.Output(width=2 * Inner.i.width)\n\n    # Instantiate that in another Module\n    @h.module\n    class Outer:\n        inner = Inner()\n\n    # And manipulate that some more too\n    Outer.inp = h.Input(width=params.w)\n    return Outer\n```\n\n### Debugging Tips\n\nGenerators when they're called return `GeneratorCall`s, which are sufficient to validate them with respect to the rest of circuit, but don't contain the resolved `Module` that you might intuitively expect from the type-hinting. To get at this module the usual procedure is as follows:\n\n```python\nMyGen = MyGenerator(params)\n#  Explicitly elaborate your generator\nh.elaborate(MyGen)\n# Extract the resolved Module within\nMyGen = MyGen.result\n```\n\nYou can then manipulate this `Module` using the debugging tips provided above at the end of the `Signal` section.\n\n## Parameters\n\n`Generators` must take a single argument `params` which is a collection of `hdl21.Params`. Generator parameters are strongly type-checked at runtime. Each requires a data-type `dtype` and description-string `desc`. Optional parameters include a default-value, which must be an instance of `dtype`.\n\n```python\n# Example parameter:\nnf = h.Param(dtype=int, desc=\"Number of parallel fingers\", default=1)\n```\n\nThe collections of these parameters used by `Generators` are called param-classes, and are typically formed by applying the `hdl21.paramclass` decorator to a class-body-full of `hdl21.Params`:\n\n```python\nimport hdl21 as h\n\n@h.paramclass\nclass MyParams:\n    # Required\n    width = h.Param(dtype=int, desc=\"Width. Required\")\n    # Optional - including a default value\n    text = h.Param(dtype=str, desc=\"Optional string\", default=\"My Favorite Module\")\n```\n\nEach param-class is defined similarly to the Python standard-library's `dataclass`. The `paramclass` decorator converts these class-definitions into type-checked `dataclasses`, with fields using the `dtype` of each parameter.\n\n```python\np = MyParams(width=8, text=\"Your Favorite Module\")\nassert p.width == 8  # Passes. Note this is an `int`, not a `Param`\nassert p.text == \"Your Favorite Module\"  # Also passes\n```\n\nSimilar to `dataclasses`, param-class constructors use the field-order defined in the class body. Note Python's function-argument rules dictate that all required arguments be declared first, and all optional arguments come last.\n\nParam-classes can be nested, and can be converted to (potentially nested) dictionaries via `dataclasses.asdict`. The same conversion applies in reverse - (potentially nested) dictionaries can be expanded to serve as param-class constructor arguments:\n\n```python\nimport hdl21 as h\nfrom dataclasses import asdict\n\n@h.paramclass\nclass Inner:\n    i = h.Param(dtype=int, desc=\"Inner int-field\")\n\n@h.paramclass\nclass Outer:\n    inner = h.Param(dtype=Inner, desc=\"Inner fields\")\n    f = h.Param(dtype=float, desc=\"A float\", default=3.14159)\n\n# Create from a (nested) dictionary literal\nd1 = {\"inner\": {\"i\": 11}, \"f\": 22.2}\no = Outer(**d1)\n# Convert back to another dictionary\nd2 = asdict(o)\n# And check they line up\nassert d1 == d2\n```\n\nGenerators include the capability to construct their param-classes inline, if provided a set of compatible keyword arguments. For example, defining a generator using the `MyParams` parameters above:\n\n```python\n@h.generator\ndef MyGen(params: MyParams) -> h.Module:\n    ... # Create a `Module` & return it\n```\n\nThis typical invocation:\n\n```python\np = MyParams(width=8, text=\"My Favorite Module\")\nMyGen(p)\n```\n\nis the same as calling:\n\n```python\nMyParams(width=8, text=\"My Favorite Module\")\n```\n\nParameters may be provided as keywords, or as a single positional argument which is an instance of the generator's param-class. Combinations of the two are not supported.\n\n### Names of Generated Modules\nUsing `Params` with a `Generator` will generally produce a module with a name in the form of `{Module_Name}_{long_string}`, e.g. `NmosIdac_46b3842dc8718a80a86891e28bc798e5_`.\nThis 32-character hex-string is a hash of the parameters. This rule applies when parameters are \"compound\", i.e. not a simple scalar. \n\nIn constrast, when the `Params` are all-scalar, exported modules are named with a suffixed string of the directly concatenated values, e.g. `NmosIdac_nbits_5`.\n\n## A Note on Parametrization\n\nHdl21 `Generators` have parameters. `Modules` do not.\n\nThis is a deliberate decision, which in this sense makes `hdl21.Module` less feature-rich than the analogous `module` concepts in existing HDLs (Verilog, VHDL, and even SPICE). These languages support what might be called \"static parameters\" - relatively simple relationships between parent and child-module parameterization. Setting, for example, the width of a signal or number of instances in an array is straightforward. But more elaborate parametrization-cases are either highly cumbersome or altogether impossible to create. (As an example, try using Verilog parametrization to make a programmable-depth binary tree.) Hdl21, in contrast, exposes all parametrization to the full Python-power of its generators.\n\n## Numeric Parameters\n\n### `Prefixed` Numbers\n\nHdl21 provides an [SI prefixed](https://www.nist.gov/pml/owm/metric-si-prefixes) numeric type `Prefixed`, which is especially common for physical generator parameters. Each `Prefixed` value is a combination of the Python standard library's `Decimal` and an enumerated SI `Prefix`:\n\n```python\n@dataclass\nclass Prefixed:\n    number: Decimal  # Numeric Portion\n    prefix: Prefix   # Enumerated SI Prefix\n```\n\nMost of Hdl21's built-in `Generators` and `Primitives` use `Prefixed` extensively, for a key reason: floating-point rounding. It is commonplace for physical parameter values - e.g. the physical width of a transistor - to have _allowed_ and _disallowed_ values. And those values do not necessarily land on IEEE floating-point values! Hdl21 generators are often used to produce legacy-HDL netlists and other code, which must convert these values to strings. `Prefixed` ensures a way to do this at arbitrary scale without the possibility of rounding error.\n\n`Prefixed` values rarely need to be instantiated directly. Instead Hdl21 exposes a set of common prefixes via their typical single-character names:\n\n```python\nf = FEMTO = Prefix.FEMTO\np = PICO = Prefix.PICO\nn = NANO = Prefix.NANO\nµ = u = MICRO = Prefix.MICRO # Note both `u` and `µ` are valid\nm = MILLI = Prefix.MILLI\nK = KILO = Prefix.KILO\nM = MEGA = Prefix.MEGA\nG = GIGA = Prefix.GIGA\nT = TERA = Prefix.TERA\nP = PETA = Prefix.PETA\nUNIT = Prefix.UNIT\n```\n\nMultiplying by these values produces a `Prefixed` value.\n\n```python\nfrom hdl21.prefix import µ, n, f\n\n# Create a few parameter values using them\nMos.Params(\n    w=1 * µ,\n    l=20 * n,\n)\nCapacitor.Params(\n    c=1 * f,\n)\n```\n\nThese multiplications are the easiest and most common way to create `Prefixed` parameter values.\nNote the single-character identifiers `µ`, `n`, `f`, et al _are not_ exported by star-exports (`from hdl21 import *`). They must be imported explicitly from `hdl21.prefix`.\n\n`hdl21.prefix` also exposes an `e()` function which returns an `Exponent` type, which produces a prefix from an integer exponent value:\n\n```python\nfrom hdl21.prefix import e, µ\n\n11 * e(-6) == 11 * µ  # True\n```\n\nThese `e()` values are also most common in multiplication expressions,\nto create `Prefixed` values in \"floating point\" style such as `11 * e(-9)`.\n\n#### Exponent Arithmetic\n\nThe `Prefix` has its own arithmetic which can be accessed with `*`, `/` and `**`, this allows users to chain together rescaling parameters. Behind the scenes, this is done by converting the `Prefix`'s into an `Exponent` type (the default type returned by the `e` function). For example, the following test passes:\n\n```python\ndef test_prefix_arithmetic:\n\n    assert 1 * m * m == 1 * u\n    assert 1 * (K / D) == 0.1 * K\n    assert 1 * (K ** 2) == 1 * M \n```\n\n`Exponent` types support floats and also have arithmetic with `*`, `/` and `**` which works using rules relating power arithmetic to these operators:\n\n```python\ndef test_exponent_arithmetic:\n\n    assert 1 * e(0.5) * e(0.5) == 1 * e(1)\n    assert 1 * e(0.5) / e(0.5) == 1 * e(0)\n    assert 1 * e(0.2) ** 5 == 1 * e(1)\n```\n\n#### Mathematical Tricks\n\n##### Comparison and Equality\n\n`Prefixed` determines if two values are the same by comparing their difference up to 20 decimal places in their SI unit, this means that a yottameter + yoctometer is indistinguishable from a plain yottameter in `Prefixed` comparison logic. It's assumed this is safe because numerical errors at this scale difference compound very quickly with routine mathematics like square-roots, even with arbitrary precision arithmetic.\n\nAt this time, comparison and equality operators are not supported for the `Prefix` or `Exponent`, since these types describe scale rather than encode actual quantities, a Kilomilliwatt is just a Watt, after all.\n\n##### Scale Agnostic\n\n`Prefixed` in general is scale agnostic and can safely move across scales without any issue, with the `prefix` serving more as an indication of where the user would like to treat as units than explicit declaration of scale where no comparison can happen.\n\n##### Linear Algebra\n\n`numpy` supports `Prefixed` arrays out of the box, meaning that arrays can be used with `Prefix` arithmetic and used for simple linear algebra and any operations where a `np.float` dtype is required.\n\n##### Zero Division\n\nDividing a `Prefixed` instance by `0` will return `float('inf')` regardless of sign.\n\n### `Scalar`\n\nMany Hdl21 primitive parameters can be either numbers or string-literals.  \nThe combination is so common that Hdl21 defines a `Scalar` type which is (roughly):\n\n```python\nScalar = Union[Prefixed, Literal]\n```\n\nWith automatic conversions from each of `str`, `int`, `float`, and `Decimal`.\n\n`Scalar` is particularly designed for parameter-values of `Primitive`s and of simulations.\nMost such parameters \"want\" to be the `Prefixed` type, for reasons outlined [above](#prefixed-numeric-parameters). They often also need a string-valued escape hatch, e.g. when referring to out-of-Hdl21 quantities\nsuch as parameters in external netlists or simulation decks.\nThese out-of-Hdl21 expressions are represented by the `Literal` type, a simple wrapper around `str`.\n\nWhere possible `Scalar` prefers to use the `Prefixed` variant.\nBuilt-in numbers `(int, float, Decimal)` are converted to `Prefixed` inline.\nStrings are attempted to be converted to `Prefixed`, and fall back to `Literal` if unsuccessful.\nThis conversion process is also available as the free-standing `to_scalar()` function.\n\nExample:\n\n```python\nimport hdl21 as h\nfrom hdl21.prefix import NANO, µ\nfrom decimal import Decimal\n\n@h.paramclass\nclass MyMosParams:\n    w = h.Param(dtype=h.Scalar, desc=\"Width\", default=1e-6) # Default `float` converts to a `Prefixed`\n    l = h.Param(dtype=h.Scalar, desc=\"Length\", default=\"w/5\") # Default `str` converts to a `Literal`\n\n# Example instantiations\nMyMosParams() # Default values\nMyMosParams(w=Decimal(1e-6), l=3*µ)\nMyMosParams(w=h.Literal(\"sim_param_width\"), l=h.Prefixed.new(20, NANO))\nMyMosParams(w=\"11*l\", l=11)\n```\n\nWhen defining \"primitive level\" parameters - e.g. those that will be used in PDK-level devices - `Scalar` is generally the best datatype to use.\n\n## Primitives and External Modules\n\nThe leaf-nodes of each hierarchical Hdl21 circuit are generally defined in one of two places:\n\n- `Primitive` elements, defined in the `hdl21.primitives` package. Each is designed to be a technology-independent representation of an irreducible component.\n- `ExternalModules`, defined outside Hdl21. Such \"module wrappers\", which might alternately be called \"black boxes\", are common for including circuits from other HDLs.\n\n### `Primitives`\n\nHdl21's library of generic primitive elements is defined in the `hdl21.primitives` package. Its content is roughly equivalent to that built into a typical SPICE simulator.\n\nA summary of `hdl21.primitives`:\n\n| Name                           | Description                       | Type     | Aliases                               | Ports        |\n| ------------------------------ | --------------------------------- | -------- | ------------------------------------- | ------------ |\n| Mos                            | Mos Transistor                    | PHYSICAL | MOS                                   | d, g, s, b   |\n| IdealResistor                  | Ideal Resistor                    | IDEAL    | R, Res, Resistor, IdealR, IdealRes    | p, n         |\n| PhysicalResistor               | Physical Resistor                 | PHYSICAL | PhyR, PhyRes, ResPhy, PhyResistor     | p, n         |\n| ThreeTerminalResistor          | Three Terminal Resistor           | PHYSICAL | Res3, PhyRes3, ResPhy3, PhyResistor3  | p, n, b      |\n| IdealCapacitor                 | Ideal Capacitor                   | IDEAL    | C, Cap, Capacitor, IdealC, IdealCap   | p, n         |\n| PhysicalCapacitor              | Physical Capacitor                | PHYSICAL | PhyC, PhyCap, CapPhy, PhyCapacitor    | p, n         |\n| ThreeTerminalCapacitor         | Three Terminal Capacitor          | PHYSICAL | Cap3, PhyCap3, CapPhy3, PhyCapacitor3 | p, n, b      |\n| IdealInductor                  | Ideal Inductor                    | IDEAL    | L, Ind, Inductor, IdealL, IdealInd    | p, n         |\n| PhysicalInductor               | Physical Inductor                 | PHYSICAL | PhyL, PhyInd, IndPhy, PhyInductor     | p, n         |\n| ThreeTerminalInductor          | Three Terminal Inductor           | PHYSICAL | Ind3, PhyInd3, IndPhy3, PhyInductor3  | p, n, b      |\n| PhysicalShort                  | Short-Circuit/Net-Tie             | PHYSICAL | Short                                 | p, n         |\n| DcVoltageSource                | DC Voltage Source                 | IDEAL    | V, Vdc, Vsrc                          | p, n         |\n| PulseVoltageSource             | Pulse Voltage Source              | IDEAL    | Vpu, Vpulse                           | p, n         |\n| CurrentSource                  | Ideal DC Current Source           | IDEAL    | I, Idc, Isrc                          | p, n         |\n| VoltageControlledVoltageSource | Voltage Controlled Voltage Source | IDEAL    | Vcvs, VCVS                            | p, n, cp, cn |\n| CurrentControlledVoltageSource | Current Controlled Voltage Source | IDEAL    | Ccvs, CCVS                            | p, n, cp, cn |\n| VoltageControlledCurrentSource | Voltage Controlled Current Source | IDEAL    | Vccs, VCCS                            | p, n, cp, cn |\n| CurrentControlledCurrentSource | Current Controlled Current Source | IDEAL    | Cccs, CCCS                            | p, n, cp, cn |\n| Bipolar                        | Bipolar Transistor                | PHYSICAL | Bjt, BJT                              | c, b, e      |\n| Diode                          | Diode                             | PHYSICAL | D                                     | p, n         |\n\nEach primitive is available in the `hdl21.primitives` namespace, either through its full name or any of its aliases. Most primitives have fairly verbose names (e.g. `VoltageControlledCurrentSource`, `IdealResistor`), but also expose short-form aliases (e.g. `Vcvs`, `R`). Each of the aliases in Table 1 above refer to _the same_ Python object, i.e.\n\n```python\nfrom hdl21.primitives import R, Res, IdealResistor\n\nR is Res            # evaluates to True\nR is IdealResistor  # also evaluates to True\n```\n\nHdl21 `Primitives` come in _ideal_ and _physical_ flavors. The difference is most frequently relevant for passive elements, which can for example represent either\n\n- (a) technology-specific passives, e.g. a MIM or MOS capacitor, or\n- (b) an _ideal_ capacitor\n\nSome element-types have solely physical implementations, some are solely ideal, and others include both.\n\n### `ExternalModules`\n\nAlternately Hdl21 includes an `ExternalModule` type which defines the interface to a module-implementation outside Hdl21. These external definitions are common for instantiating technology-specific modules and libraries. Think of them as a module \"function header\"; other popular modern HDLs refer to them as module _black boxes_.\n\nAn example `ExternalModule`:\n\n```python\nimport hdl21 as h\nfrom hdl21.prefix import µ\nfrom hdl21.primitives import Diode\n\n@h.paramclass\nclass BandGapParams:\n    self_destruct = h.Param(\n        dtype=bool,\n        desc=\"Whether to include the self-destruction feature\",\n        default=True,\n    )\n\nBandGap = h.ExternalModule(\n    name=\"BandGap\",\n    desc=\"Example ExternalModule, defined outside Hdl21\",\n    port_list=[h.Port(name=\"vref\"), h.Port(name=\"enable\")],\n    paramtype=BandGapParams,\n)\n```\n\nBoth `Primitives` and `ExternalModules` have names, ordered `Ports`, and a few other pieces of metadata, but no internal implementation: no internal signals, and no instances of other modules. Unlike `Modules`, both _do_ have parameters. `Primitives` each have an associated `paramclass`, while `ExternalModules` can optionally declare one via their `paramtype` attribute. Their parameter-types are limited to a small subset of those possible for `Generators` - generally \"scalar\" types such as numbers, strings, and `Scalar` - primarily limited by the need to need to provide them to legacy HDLs. Parameters are applied in the same style as for `Generators`, by calling the `Primitive` or `ExternalModule`. Parameter-applications can either be an instance of the module's `paramtype` or a set of keyword arguments which validly construct one inline.\n\n```python\n# Continuing from the snippet above:\nparams = BandGapParams(self_destruct=False)  # Watch out there!\n```\n\n`Primitives` and `ExternalModules` can be instantiated and connected in all the same styles as `Modules`:\n\n```python\n@h.module\nclass BandGapPlus:\n    vref, enable = h.Signals(2)\n    # Instantiate the `ExternalModule` defined above\n    bg = BandGap(params)(vref=vref, enable=enable)\n    # ...Anything else...\n\n@h.module\nclass DiodePlus:\n    p, n = h.Signals(2)\n    # Parameterize, instantiate, and connect a `primitives.Diode`\n    d = Diode(w=1 * µ, l=1 * µ)(p=p, n=n)\n    # ... Everything else ...\n```\n\n## Exporting and Importing\n\nHdl21 generates hardware databases in the [VLSIR](https://github.com/Vlsir/Vlsir) interchange formats, defined through [Google Protocol Buffers](https://developers.google.com/protocol-buffers/). Through [VLSIR's Python tools](https://pypi.org/project/vlsirtools/) Hdl21 also includes drivers for popular industry-standard data formats and popular spice-class simulation engines.\n\nThe `hdl21.to_proto()` function converts an Hdl21 `Module` or group of `Modules` into a VLSIR `Package`. The `hdl21.from_proto()` function similarly imports a VLSIR `Package` into a Python namespace of Hdl21 `Modules`.\n\nExporting to industry-standard netlist formats is a particularly common operation for Hdl21 users. The `hdl21.netlist()` function uses VLSIR to export any of its supported netlist formats.\n\n```python\nimport sys\nimport hdl21 as h\n\n@h.module\nclass Rlc:\n    p, n = h.Ports(2)\n\n    res = h.Res(r=1e3)(p=p, n=n)\n    cap = h.Cap(c=1e3)(p=p, n=n)\n    ind = h.Ind(l=1e-9)(p=p, n=n)\n\n# Write a spice-format netlist to stdout\nh.netlist(Rlc, sys.stdout, fmt=\"spice\")\n```\n\n`hdl21.netlist` takes a second destination argument `dest`, which is commonly either an open file-handle or `sys.stdout`.\n\nEach `Module` includes a list of `Literal` contents, designed to be included directly in exported netlists. These are commonly used to refer to out-of-Hdl21 quantities, or to include netlist-language features not first-class supported by Hdl21. Example:\n\n```python\n@h.module\nclass HasLiterals:\n    a, b, c = h.Ports(3)\n\n# Add some literal content\nHasLiterals.literals.extend([\n    h.Literal(\"generate some_verilog_code\"),\n    h.Literal(\".some_spice_attribute what=ever\"),\n    h.Literal(\"PRAGMA: some_pragma\"),\n])\n```\n\n`Module.literals` is a Python built-in list and can be manipulated with any of its typical methods (`append`, `extend`, etc.). Literals are written to netlists in the order they appear in the list. Order between Literals and other Module content is not preserved.\n\n## Spice-Class Simulation\n\nHdl21 includes drivers for popular spice-class simulation engines commonly used to evaluate analog circuits.\nThe `hdl21.sim` package includes a wide variety of spice-class simulation constructs, including:\n\n- DC, AC, Transient, Operating-Point, Noise, Monte-Carlo, Parameter-Sweep and Custom (per netlist language) Analyses\n- Control elements for saving signals (`Save`), simulation options (`Options`), including external files and contents (`Include`, `Lib`), measurements (`Meas`), simulation parameters (`Param`), and literal netlist commands (`Literal`)\n\nThe entrypoint to Hdl21-driven simulation is the simulation-input type `hdl21.sim.Sim`. Each `Sim` includes:\n\n- A testbench Module `tb`, and\n- A list of simulation attributes (`attrs`), including any and all of the analyses, controls, and related elements listed above.\n\nExample:\n\n```python\nimport hdl21 as h\nfrom hdl21.sim import *\n\n@h.module\nclass MyModulesTestbench:\n    # ... Testbench content ...\n\n# Create simulation input\ns = Sim(\n    tb=MyModulesTestbench,\n    attrs=[\n        Param(name=\"x\", val=5),\n        Dc(var=\"x\", sweep=PointSweep([1]), name=\"mydc\"),\n        Ac(sweep=LogSweep(1e1, 1e10, 10), name=\"myac\"),\n        Tran(tstop=11 * h.prefix.p, name=\"mytran\"),\n        SweepAnalysis(\n            inner=[Tran(tstop=1, name=\"swptran\")],\n            var=\"x\",\n            sweep=LinearSweep(0, 1, 2),\n            name=\"mysweep\",\n        ),\n        MonteCarlo(\n            inner=[Dc(var=\"y\", sweep=PointSweep([1]), name=\"swpdc\")],\n            npts=11,\n            name=\"mymc\",\n        ),\n        Save(SaveMode.ALL),\n        Meas(analysis=\"mytr\", name=\"a_delay\", expr=\"trig_targ_something\"),\n        Include(\"/home/models\"),\n        Lib(path=\"/home/models\", section=\"fast\"),\n        Options(reltol=1e-9),\n    ],\n)\n\n# And run it!\ns.run()\n```\n\n`Sim` also includes a class-based syntax similar to `Module` and `Bundle`. This also allows for inline definition of a testbench module, which can be named either `tb` or `Tb`:\n\n```python\nimport hdl21 as h\nfrom hdl21.sim import *\n\n@sim\nclass MySim:\n\n    @h.module\n    class Tb:\n        # ... Testbench content ...\n\n    x = Param(5)\n    y = Param(6)\n    mydc = Dc(var=x, sweep=PointSweep([1]))\n    myac = Ac(sweep=LogSweep(1e1, 1e10, 10))\n    mytran = Tran(tstop=11 * h.prefix.PICO)\n    mysweep = SweepAnalysis(\n        inner=[mytran],\n        var=x,\n        sweep=LinearSweep(0, 1, 2),\n    )\n    mymc = MonteCarlo(inner=[Dc(var=\"y\", sweep=PointSweep([1]), name=\"swpdc\")], npts=11)\n    delay = Meas(analysis=mytran, expr=\"trig_targ_something\")\n    opts = Options(reltol=1e-9)\n\n    save_all = Save(SaveMode.ALL)\n    a_path = \"/home/models\"\n    include_that_path = Include(a_path)\n    fast_lib = Lib(path=a_path, section=\"fast\")\n\nMySim.run()\n```\n\nNote that in these class-based definitions, attributes whose names don't really matter such as `save_all` above can be _named_ anything, but must be _assigned_ into the class, not just constructed.\n\nClass-based `Sim` definitions retain all class members which are `SimAttr`s and drop all others. Non-`SimAttr`-valued fields can nonetheless be handy for defining intermediate values upon which the ultimate SimAttrs depend, such as the `a_path` field in the example above.\n\nClasses decorated by `@sim` have a single special required field: a testbench attribute, named either `tb` or `Tb`, which sets the simulation testbench. A handful of names are disallowed in `sim` class-definitions, generally corresponding to the names of the `Sim` class's fields and methods such as `attrs` and `run`.\n\nEach `sim` also includes a set of methods to add simulation attributes from their keyword constructor arguments. These methods use the same names as the simulation attributes (`Dc`, `Meas`, etc.) but incorporating the python language convention that functions and methods be lowercase (`dc`, `meas`, etc.). Example:\n\n```python\n# Create a `Sim`\ns = Sim(tb=MyTb)\n\n# Add all the same attributes as above\np = s.param(name=\"x\", val=5)\ndc = s.dc(var=p, sweep=PointSweep([1]), name=\"mydc\")\nac = s.ac(sweep=LogSweep(1e1, 1e10, 10), name=\"myac\")\ntr = s.tran(tstop=11 * h.prefix.p, name=\"mytran\")\nnoise = s.noise(\n    output=MyTb.p,\n    input_source=MyTb.v,\n    sweep=LogSweep(1e1, 1e10, 10),\n    name=\"mynoise\",\n)\nsw = s.sweepanalysis(inner=[tr], var=p, sweep=LinearSweep(0, 1, 2), name=\"mysweep\")\nmc = s.montecarlo(\n    inner=[Dc(var=\"y\", sweep=PointSweep([1]), name=\"swpdc\"),], npts=11, name=\"mymc\",\n)\ns.save(SaveMode.ALL)\ns.meas(analysis=tr, name=\"a_delay\", expr=\"trig_targ_something\")\ns.include(\"/home/models\")\ns.lib(path=\"/home/models\", section=\"fast\")\ns.options(reltol=1e-9)\n\n# And run it!\ns.run()\n```\n\n## Process Technologies\n\nDesigning for a specific implementation technology (or \"process development kit\", or PDK) with Hdl21 can use either of (or a combination of) two routes:\n\n- Instantiate `ExternalModules` corresponding to the target technology. These would commonly include its process-specific transistor and passive modules, and potentially larger cells, for example from a cell library. Such external modules are frequently defined as part of a PDK (python) package, but can also be defined anywhere else, including inline among Hdl21 generator code.\n- Use `hdl21.Primitives`, each of which is designed to be a technology-independent representation of a primitive component. Moving to a particular technology then generally requires passing the design through an `hdl21.pdk`'s `compile` function.\n\nHdl21 PDKs are Python packages which generally include two primary elements:\n\n- (a) A library `ExternalModules` describing the technology's cells, and\n- (b) A `compile` conversion-method which transforms a hierarchical Hdl21 tree, mapping generic `hdl21.Primitives` into the tech-specific `ExternalModules`.\n\nSince PDKs are python packages, using them is as simple as importing them. Hdl21 includes a built-in sample PDK available via `hdl21.pdk.sample_pdk` which includes simulatable NMOS and PMOS transistors. Hdl21's source tree includes three additional PDK packages:\n\n|                                       | PyPi                                   | Source        |\n| ------------------------------------- | -------------------------------------- | ------------- |\n| ASAP7 Predictive/Academic PDK         | https://pypi.org/project/asap7-hdl21/  | [pdks/Asap7](./pdks/Asap7)  |\n| SkyWater 130nm Open-Source PDK        | https://pypi.org/project/sky130-hdl21/ | [pdks/Sky130](./pdks/Sky130) |\n| GlobalFoundries 180nm Open-Source PDK | https://pypi.org/project/gf180-hdl21/  | [pdks/Gf180](./pdks/Gf180)  |\n\nEach contain much more detail documentation on their specific installation and use.\n\n```python\nimport hdl21 as h\nimport sky130_hdl21\n\n@h.module\nclass SkyInv:\n    \"\"\" An inverter, demonstrating using PDK modules \"\"\"\n\n    # Create some IO\n    i, o, VDD, VSS = h.Ports(4)\n\n    p = sky130_hdl21.Sky130MosParams(w=1,l=1)\n\n    # And create some transistors!\n    ps = sky130_hdl21.primitives.PMOS_1p8V_STD(p)(d=o, g=i, s=VDD, b=VDD)\n    ns = sky130_hdl21.primitives.NMOS_1p8V_STD(p)(d=o, g=i, s=VSS, b=VSS)\n```\n\nProcess-portable modules instead use Hdl21 `Primitives`, which can be compiled to a target technology:\n\n```python\nimport hdl21 as h\nfrom hdl21.prefix import µ\nfrom hdl21.primitives import Nmos, Pmos, MosVth\n\n@h.module\nclass Inv:\n    \"\"\" An inverter, demonstrating instantiating PDK modules \"\"\"\n\n    # Create some IO\n    i, o, VDD, VSS = h.Ports(4)\n\n    # And now create some generic transistors!\n    ps = Pmos(w=1*µ, l=1*µ, vth=MosVth.STD)(d=o, g=i, s=VDD, b=VDD)\n    ns = Nmos(w=1*µ, l=1*µ, vth=MosVth.STD)(d=o, g=i, s=VSS, b=VSS)\n```\n\nCompiling the generic devices to a target PDK then just requires a pass through the PDK's `compile()` method:\n\n```python\nimport hdl21 as h\nimport sky130_hdl21\n\nsky130_hdl21.compile(Inv) # Produces the same content as `SkyInv` above\n```\n\nHdl21 includes an `hdl21.pdk` subpackage which tracks the available in-memory PDKs. If there is a single PDK available, it need not be explicitly imported: `hdl21.pdk.compile()` will use it by default.\n\n```python\nimport hdl21 as h\nimport sky130  # Note this import can be elsewhere in the program, i.e. in a configuration layer.\n\nh.pdk.compile(Inv)  # With `sky130` in memory, this does the same thing as above.\n```\n\n### PDK Corners\n\nThe `hdl21.pdk` package inclues a three-valued `Corner` enumerated type and related classes for describing common process-corner variations. In pseudo [type-union](https://peps.python.org/pep-0604/) code:\n\n```\nCorner = TYP | SLOW | FAST\n```\n\nTypical technologies includes several quantities which undergo such variations. Values of the `Corner` enum can mean either the variations in a particular quantity, e.g. the \"slow\" versus \"fast\" variations of a poly resistor, or can just as oftern refer to a set of such variations within a given technology. In the latter case `Corner` values are often expanded by PDK-level code to include each constituent device variation. For example `my.pdk.corner(Corner.FAST)` may expand to definitions of \"fast\" Cmos transistors, resistors, and capacitors.\n\nQuantities which can be varied are often keyed by a `CornerType`. In similar pseudo-code:\n\n```\nCornerType = MOS | CMOS | RES | CAP | ...\n```\n\nA particularly common such use case pairs NMOS and PMOS transistors into a `CmosCornerPair`. CMOS circuits are then commonly evauated at its four extremes, plus their typical case. These five conditions are enumerated in the `CmosCorner` type:\n\n```python\n@dataclass\nclass CmosCornerPair:\n    nmos: Corner\n    pmos: Corner\n```\n\n```\nCmosCorner = TT | FF | SS | SF | FS\n```\n\nHdl21 exposes each of these corner-types as Python enumerations and combinations thereof. Each PDK package then defines its mapping from these `Corner` types to the content they include, typically in the form of external files.\n\n### PDK Installations and Sites\n\nMuch of the content of a typical process technology - even the subset that Hdl21 cares about - is not defined in Python. Transistor models and SPICE \"library\" files, such as those defining the `PMOS` and `NMOS` above, are common examples pertinent to Hdl21. Tech-files, layout libraries, and the like are similarly necessary for related pieces of EDA software. These PDK contents are commonly stored in a technology-specific arrangement of interdependent files. Hdl21 PDK packages structure this external content as a `PdkInstallation` type.\n\nEach `PdkInstallation` is a runtime type-checked Python `dataclass` which extends the base `hdl21.pdk.PdkInstallation` type. Installations are free to define arbitrary fields and methods, which will be type-validated for each `Install` instance. Example:\n\n```python\n\"\"\" A sample PDK package with an `Install` type \"\"\"\n\nfrom pydantic.dataclasses import dataclass\nfrom hdl21.pdk import PdkInstallation\n\n@dataclass\nclass Install(PdkInstallation):\n    \"\"\"Sample Pdk Installation Data\"\"\"\n\n    model_lib: Path  # Filesystem `Path` to transistor models\n```\n\nThe name of each PDK's installation-type is by convention `Install` with a capital I. PDK packages which include an installation-type also conventionally include an `Install` instance named `install`, with a lower-case i. Code using the PDK package can then refer to the PDK's `install` attribute. Extending the example above:\n\n```python\n\"\"\" A sample PDK package with an `Install` type \"\"\"\n\n@dataclass\nclass Install(PdkInstallation):\n    \"\"\"Sample Pdk Installation Data\"\"\"\n\n    model_lib: Path  # Filesystem `Path` to transistor models\n\ninstall: Optional[Install] = None  # The active installation, if any\n```\n\nThe content of this installation data varies from site to site. To enable \"site-portable\" code to use the PDK installation, Hdl21 PDK users conventionally define a \"site-specific\" module or package which:\n\n- Imports the target PDK module\n- Creates an instance of its `PdkInstallation` subtype\n- Affixes that instance to the PDK package's `install` attribute\n\nFor example:\n\n```python\n# In \"sitepdks.py\" or similar\nimport mypdk\n\nmypdk.install = mypdk.Install(\n    models = \"/path/to/models\",\n    path2 = \"/path/2\",\n    # etc.\n)\n```\n\nThese \"site packages\" are named `sitepdks` by convention. They can often be shared among several PDKs on a given filesystem. Hdl21 includes one built-in example such site-package, [SampleSitePdks](./SampleSitePdks/), which demonstrates setting up both built-in PDKs, Sky130 and ASAP7:\n\n```python\n# The built-in sample `sitepdks` package\nfrom pathlib import Path\n\nimport sky130_hdl21\nsky130_hdl21.install = sky130_hdl21.Install(model_lib=Path(\"pdks\") / \"sky130\" / ... / \"sky130.lib.spice\")\n\nimport asap7_hdl21\nasap7_hdl21.install = asap7_hdl21.Install(model_lib=Path(\"pdks\") / \"asap7\" / ... / \"TT.pm\")\n```\n\n\"Site-portable\" code requiring external PDK content can then refer to the PDK package's `install`, without being directly aware of its contents.\nAn example simulation using `mypdk`'s models with the `sitepdk`s defined above:\n\n```python\n# sim_my_pdk.py\nimport hdl21 as h\nfrom hdl21.sim import Lib\nimport sitepdks as _ # <= This sets up `mypdk.install`\nimport mypdk\n\n@h.sim\nclass SimMyPdk:\n    # A set of simulation input using `mypdk`'s installation\n    tb = MyTestBench()\n    models = Lib(\n        path=mypdk.install.models, # <- Here\n        section=\"ss\"\n    )\n\n# And run it!\nSimMyPdk.run()\n```\n\nNote that `sim_my_pdk.py` need not necessarily import or directly depend upon `sitepdks` itself. So long as `sitepdks` is imported and configures the PDK installation anywhere in the Python program, further code will be able to refer to the PDK's `install` fields.\n\n### Creating PDK Packages\n\nHdl21's source tree includes a [cookiecutter template](https://github.com/cookiecutter/cookiecutter) for creating a new PDK package, available at [pdks/PdkTemplate](./pdks/PdkTemplate).\n\n## Bundles\n\nHdl21 `Bundle`s are _structured connection types_ which can include `Signal`s and instances of other `Bundle`s.\nThink of them as \"connection structs\". Similar ideas are implemented by Chisel's `Bundle`s and SystemVerilog's `interface`s.\n\n```python\n@h.bundle\nclass Diff:\n    p = h.Signal()\n    n = h.Signal()\n\n@h.bundle\nclass Quadrature:\n    i = Diff()\n    q = Diff()\n```\n\nLike `Module`s, `Bundle`s can be defined either procedurally or as a class decorated by the `hdl21.bundle` function.\n\n```python\n# This creates the same stuff as the class-based definitions above:\n\nDiff = h.Bundle(name=\"Diff\")\nDiff.add(h.Signal(name=\"p\"))\nDiff.add(h.Signal(name=\"n\"))\n\nQuadrature = h.Bundle(name=\"Quadrature\")\nQuadrature.add(Diff(name=\"i\"))\nQuadrature.add(Diff(name=\"q\"))\n```\n\nCalling a `Bundle` as in the calls to `Diff()` and `Diff(name=q)` creates an instance of that `Bundle`.\n\n## Bundle Ports\n\nBundles are commonly most valuable for shipping collections of related `Signal`s between `Module`s.\nModules can accordingly have Bundle-valued ports. To create a Bundle-port, set the `port` argument to either the boolean `True`\nor the `hdl21.Visibility.PORT` value.\n\n```python\n@h.module\nclass HasDiffs:\n    d1 = Diff(port=True)\n    d2 = Diff(port=h.Visbility.PORT)\n```\n\nPort directions on bundle-ports can be set by either of two methods.\nThe first is to set the directions directly on the Bundle's constituent `Signal`s.\nTo swap directions, pass the bundle-instances through the `hdl21.flipped` function,\nor set the `flipped` argument to the instance-constructor.\n\n```python\n@h.bundle\nclass Inner:\n    i = h.Input()\n    o = h.Output()\n\n@h.bundle\nclass Outer:\n    b1 = Inner()\n    b2 = h.flipped(Inner())\n    b3 = Inner(flipped=True)\n```\n\nHere:\n\n- An `Inner` bundle defines an `Input` and an `Output`\n- An `Outer` bundle instantiates three of them\n  - Instance `b1` is not flipped; its `i` is an input, and its `o` is an output\n  - Instance `b2` is flipped; its `i` is an _output_, and its `o` is an _input_\n  - Instance `b3` is also flipped, via its constructor argument\n\nThese \"flipping based\" bundles require that all constituent signals, including nested ones, have port-visibility.\nThe rules for flipping port directions are:\n\n- Inputs become Outputs\n- Outputs become Inputs\n- Inouts and undirected ports (`direction=NONE`) retain their directions\n\n```python\n@h.bundle\nclass B:\n    clk = h.Output()\n    data = h.Input()\n\n@h.module\nclass X: # Module with a `clk` output and `data` input\n    b = B(port=True)\n\n@h.module\nclass Y: # Module with a `clk` input and `data` output\n    b = B(flipped=True, port=True)\n\n@h.module\nclass Z:\n    b = B() # Internal instance of the `B` bundle\n    x = X(b=b)\n    y = Y(b=b)\n```\n\nThe second method for setting bundle-port directions is with `Role`s.\nEach Hdl21 bundle either explicitly or implicitly defines a set of `Role`s, which might alternately be called \"endpoints\".\nThese are the expected \"end users\" of the Bundle.\nSignal directions are then defined on each signal's `src` (source) and `dest` (destination) arguments, which can be set to any of the bundle's roles.\n\n```python\n@h.roles\nclass HostDevice(Enum):\n    HOST = auto()\n    DEVICE = auto()\n\n@h.bundle\nclass Jtag:\n    roles = HostDevice # Set the bundle's roles\n    # Note each signal sets one of the roles as `src` and another as `dest`\n    tck, tdi, tms = h.Signals(3, src=roles.HOST, dest=roles.DEVICE)\n    tdo = h.Signal(src=roles.DEVICE, dest=roles.HOST)\n```\n\nBundle-valued ports are then assigned a role and associated signal-port directions via their `role` constructor argument.\n\n```python\n@h.module\nclass Widget: # with a Jtag Device port\n    jtag = Jtag(port=True, role=Jtag.roles.DEVICE)\n\n@h.module\nclass Debugger: # with a Jtag Host port\n    jtag = Jtag(port=True, role=Jtag.roles.HOST)\n\n@h.module\nclass System: # combining the two\n    widget = Widget()\n    debugger = Debugger(jtag=widget.jtag)\n```\n\nThe rules for port-directions of role-based bundles are:\n\n- If the bundle's role is the signal's source, the signal is an `Output`\n- If the bundle's role is the signal's destination, the signal is an `Input`\n- Otherwise the signal is assigned no direction, i.e. `direction=NONE`\n\n## Collecting Bundles\n\nIt is often helpful or necessary to collect existing signals into a bundle, or to \"re-arrange\" signals from one bundle into another.\nThe primary mechanism for doing so is the `hdl21.bundlize` function which creates them.\nEach call to `bundlize` creates an \"anonymous\" bundle which lacks a backing bundle-definition type.\n\n```python\n@h.bundle\nclass Uart:\n    tx = h.Output()\n    rx = h.Input()\n\n@h.module\nclass HasUart:\n    # Module with a `Uart` port\n    uart = Uart(port=True)\n\n@h.module\nclass ConnectTwo:\n    # Connect two `HasUart`s, swapping `tx` and `rx`.\n    uart = Uart()\n    m1 = HasUart(uart=uart)\n    m2 = HasUart(uart=h.bundlize(tx=uart.rx, rx=uart.tx))\n```\n\n## Examples\n\n### Built-In Examples Library\n\nHdl21's source tree includes a built-in [examples](./examples/) library. Each is designed to be a straightforward but realistic use-case, and is a self-contained Python program which can be run directly, e.g. with:\n\n```bash\npython examples/rdac.py\n```\n\nThe built-in examples include:\n\n- [Current DAC](./examples/idac.py)\n- [MOS Transistor Simulation](./examples/mos_sim.py)\n- [Ring Oscillator Generator](./examples/ro.py)\n- [Resistor-Ladder DAC](./examples/rdac.py)\n- [Recursive Binary to One-Hot Encoders](./examples/encoder.py)\n\nReading, copying, or cloning these example programs is generally among the best ways to get started.  \nAnd adding an example is a **highly** encouraged form of [pull request](https://github.com/dan-fritchman/Hdl21/pulls)!\n\n### Featured Community Examples\n\n- [Continuous-Time Delta-Sigma ADC Generators](https://github.com/aviralpandey/CT-DS-ADC_generator)\n- [USB 2.0 PHY](https://github.com/Vlsir/Usb2Phy/tree/main/Usb2PhyAna)\n- [VCO-Based ADC Generators](https://github.com/aviralpandey) (Coming soon!)\n\n## Related Projects\n\n- [VLSIR](https://github.com/vlsir/vlsir)\n- [Hdl21 Schematics](https://github.com/vlsir/hdl21schematics)\n- [Layout21](https://github.com/dan-fritchman/Layout21)\n\n## Why Use Python?\n\nCustom IC design is a complicated field. Its practitioners have to know\n[a](https://people.eecs.berkeley.edu/~boser/courses/240B/lectures/M07%20OTA%20II.pdf) |\n[lot](http://rfic.eecs.berkeley.edu/~niknejad/ee142_fa05lects/pdf/lect24.pdf) |\n[of](https://www.delroy.com/PLL_dir/ISSCC2004/PLLTutorialISSCC2004.pdf) |\n[stuff](https://inst.eecs.berkeley.edu/~ee247/fa10/files07/lectures/L25_2_f10.pdf),\nindependent of any programming background. Many have little or no programming experience at all. Python is renowned for its accessibility to new programmers, largely attributable to its concise syntax, prototyping-friendly execution model, and thriving community. Moreover, Python has also become a hotbed for many of the tasks hardware designers otherwise learn programming for: numerical analysis, data visualization, machine learning, and the like.\n\nHdl21 exposes the ideas they're used to - `Modules`, `Ports`, `Signals` - via as simple of a Python interface as it can. `Generators` are just functions. For many, this fact alone is enough to create powerfully reusable hardware.\n\n## Why _Not_ Use {X}?\n\nWe know you have plenty of choice when you fly, and appreciate you choosing Hdl21.  \nA few alternatives and how they compare:\n\n### Schematics\n\nGraphical schematics have been the lingua franca of the custom-circuit field for, well, as long as it's been around. Most practitioners are most comfortable in this graphical form. (For plenty of circuits, so are Hdl21's authors.) Their most obvious limitation is the lack of capacity for programmable manipulation via something like Hdl21 `Generators`. Some schematic-GUI programs attempt to include \"embedded scripting\", perhaps even in Hdl21's own language (Python). We see those GUIs as entombing your programs in their badness. Hdl21 is instead a library, designed to be used by any Python program you like, sharable and runnable by anyone who has Python. (Which is everyone.)\n\n### Netlists (Spice et al)\n\nTake all of the shortcomings listed for schematics above, and add to them an under-expressive, under-specified, ill-formed, incomplete suite of \"programming languages\", and you've got netlists. Their primary redeeming quality: existing EDA CAD tools take them as direct input. So Hdl21 Modules export netlists of most popular formats instead.\n\n### (System)Verilog, VHDL, other Existing Dedicated HDLs\n\nThe industry's primary, 80s-born digital HDLs Verilog and VHDL have more of the good stuff we want here - notably an open, text-based format, and a more reasonable level of parametrization. And they have the desirable trait of being primary input to the EDA industry's core tools. They nonetheless lack the levels of programmability present here. And they generally require one of those EDA tools to execute and do, well, much of anything. Parsing and manipulating them is well-reknowned for requiring a high pain tolerance. Again Hdl21 sees these as export formats.\n\n### Chisel\n\nExplicitly designed for digital-circuit generators at the same home as Hdl21 (UC Berkeley), Chisel encodes RTL-level hardware in Scala-language classes. It's the closest of the alternatives in spirit to Hdl21. (And it's aways more mature.) If you want big, custom, RTL-level circuits - processors, full SoCs, and the like - you should probably turn to Chisel instead. Chisel makes a number of decisions that make it less desirable for custom circuits, and have accordingly kept their designers' hands-off.\n\nThe Chisel library's primary goal is producing a compiler-style intermediate representation (FIRRTL) to be manipulated by a series of compiler-style passes. We like the compiler-style IR (and may some day output FIRRTL). But custom circuits really don't want that compiler. The point of designing custom circuits is dictating exactly what comes out - the compiler _output_. The compiler is, at best, in the way.\n\nNext, Chisel targets _RTL-level_ hardware. This includes lots of things that would need something like a logic-synthesis tool to resolve to the structural circuits targeted by Hdl21. For example in Chisel (as well as Verilog and VHDL), it's semantically valid to perform an operation like `Signal + Signal`. In custom-circuit-land, it's much harder to say what that addition-operator would mean. Should it infer a digital adder? Short two currents together? Stick two capacitors in series?\nMany custom-circuit primitives such as individual transistors actively fight the signal-flow/RTL modeling style assumed by the Chisel semantics and compiler. Again, it's in the way. Perhaps more important, many of Chisel's abstractions actively hide much of the detail custom circuits are designed to explicitly create. Implicit clock and reset signals serve as prominent examples.\n\nAbove all - Chisel is embedded in Scala. It's niche, it's complicated, it's subtle, it requires dragging around a JVM. It's not a language anyone would recommend to expert-designer/novice-programmers for any reason other than using Chisel. For Hdl21's goals, Scala itself is Chisel's biggest burden.\n\n### Other Fancy Modern HDLs\n\nThere are lots of other very cool hardware-description projects out there which take Hdl21's big-picture approach - embedding hardware idioms as a library in a modern programming language. All focus on logical and/or RTL-level descriptions, unlike Hdl21's structural/custom/analog focus. We recommend checking them out:\n\n- [SpinalHDL](https://github.com/SpinalHDL/SpinalHDL)\n- [MyHDL](http://www.myhdl.org/)\n- [Migen](https://github.com/m-labs/migen) / [nMigen](https://github.com/m-labs/nmigen)\n- [Magma](https://github.com/phanrahan/magma)\n- [PyMtl](https://github.com/cornell-brg/pymtl) / [PyMtl3](https://github.com/pymtl/pymtl3)\n- [Clash](https://clash-lang.org/)\n\n---\n\n## Development\n\n- Clone this repository & navigate to it.\n- `bash scripts/install-dev.sh`. See the note below.\n- `pytest -s` should yield something like:\n\n```\n$ pytest -s\n============================ test session starts =============================\ncollected 126 items\n\nhdl21/pdk/test_pdk.py ...\nhdl21/pdk/sample_pdk/test_sample_pdk.py ...\nhdl21/sim/tests/test_sim.py .........s\nhdl21/tests/test_builtin_generators.py ..\nhdl21/tests/test_bundles.py ............\nhdl21/tests/test_conns.py ..............\nhdl21/tests/test_exports.py x............\nhdl21/tests/test_hdl21.py ...............x..............x...x........x...\nhdl21/tests/test_params.py .....x\nhdl21/tests/test_prefix.py ..........\nhdl21/tests/test_source_info.py .\npdks/Asap7/asap7/test_asap7.py .\npdks/Sky130/sky130/test_sky130.py ....\n\n================= 119 passed, 1 skipped, 6 xfailed in 0.55s ==================\n```\n\nNote: Hdl21 is commonly co-developed with the [VLSIR](https://github.com/Vlsir/Vlsir) interchange formats.\nThe [scripts](./scripts) folder includes two short installation scripts which install VLSIR from either PyPi or GitHub. Tweaks to PyPi-released versions Hdl21 may be able to use the PyPi versions of VLSIR. Most Hdl21 development cannot, and should clone VLSIR from GitHub. The `install-dev` script will install VLSIR alongside `Hdl21/`, i.e. in the parent directory of the Hdl21 clone.\n\n","description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":null,"keywords":"HDL, EDA, analog, circuit","license":null,"maintainer":null,"maintainer_email":"Dan Fritchman <dan@fritch.mn>","name":"hdl21","package_url":"https://pypi.org/project/hdl21/","platform":null,"project_url":"https://pypi.org/project/hdl21/","project_urls":{"Bug Tracker":"https://github.com/dan-fritchman/Hdl21/issues","Documentation":"https://github.com/dan-fritchman/Hdl21/blob/main/readme.md","Homepage":"https://github.com/dan-fritchman/Hdl21","Repository":"https://github.com/dan-fritchman/Hdl21"},"provides_extra":["dev"],"release_url":"https://pypi.org/project/hdl21/6.0.0/","requires_dist":["vlsir<7,>=6.0.0","vlsirtools<7,>=6.0.0","pydantic<2.7,>=1.9.0","pytest==7.1; extra == \"dev\"","coverage; extra == \"dev\"","pytest-cov; extra == \"dev\"","pre-commit==2.20; extra == \"dev\"","black==22.6; extra == \"dev\"","flit; extra == \"dev\""],"requires_python":"<3.13,>=3.7","summary":"Hardware Description Library","version":"6.0.0","yanked":false,"yanked_reason":null},"last_serial":23366012,"releases":{"0.1.0":[{"comment_text":"","digests":{"blake2b_256":"25a71db529a97b2a73aaa7536af2dae733e0bf18bb22f46ec322f8f4cfc78a1f","md5":"a7ac3877338eb64f0fb6d2f4ffe2bf09","sha256":"acd919d57cca678c9e5a8697c2c8ce250dfe93d11f647d412e7d8ca3b5f24dc3"},"downloads":-1,"filename":"hdl21-0.1.0-py3-none-any.whl","has_sig":false,"md5_digest":"a7ac3877338eb64f0fb6d2f4ffe2bf09","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.7,<4.0","size":71290,"upload_time":"2021-10-15T16:33:26","upload_time_iso_8601":"2021-10-15T16:33:26.975844Z","url":"https://files.pythonhosted.org/packages/25/a7/1db529a97b2a73aaa7536af2dae733e0bf18bb22f46ec322f8f4cfc78a1f/hdl21-0.1.0-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"66144ad61f3c0473bd12cbcab4a403c9a087a46eae90c8a541c3f353b7e59f33","md5":"901e797e11934758ab0b79a22a3e20b2","sha256":"577a59054470ab9f93babadb0e089c1f5926e0714b7fdaa35ce5e8f331300e81"},"downloads":-1,"filename":"hdl21-0.1.0.tar.gz","has_sig":false,"md5_digest":"901e797e11934758ab0b79a22a3e20b2","packagetype":"sdist","python_version":"source","requires_python":">=3.7,<4.0","size":65361,"upload_time":"2021-10-15T16:33:29","upload_time_iso_8601":"2021-10-15T16:33:29.102803Z","url":"https://files.pythonhosted.org/packages/66/14/4ad61f3c0473bd12cbcab4a403c9a087a46eae90c8a541c3f353b7e59f33/hdl21-0.1.0.tar.gz","yanked":false,"yanked_reason":null}],"0.1.1":[{"comment_text":"","digests":{"blake2b_256":"79fc7fa8629ae8bc17d5bcb5aef0d32c3eb72d15b9cf8147f57f8db64aaa5a8d","md5":"65938f06cc672317e30ec061d88e7b34","sha256":"10b43a3715d226c905540940aaafef7e8a659eda16f438b53810f34493563dbd"},"downloads":-1,"filename":"hdl21-0.1.1-py3-none-any.whl","has_sig":false,"md5_digest":"65938f06cc672317e30ec061d88e7b34","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.7,<4.0","size":74189,"upload_time":"2021-10-29T16:33:09","upload_time_iso_8601":"2021-10-29T16:33:09.794200Z","url":"https://files.pythonhosted.org/packages/79/fc/7fa8629ae8bc17d5bcb5aef0d32c3eb72d15b9cf8147f57f8db64aaa5a8d/hdl21-0.1.1-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"b16d7c3f0a94bf48cffc29ac5d5e4081c11a427e300101ad0b5242a71602d067","md5":"39c3a8511db3af89243cfb741c66e318","sha256":"c3e28fdfd2b7f6adc0c3fd5d3498fd314b225672f2525435daa4d3ec1bc80a22"},"downloads":-1,"filename":"hdl21-0.1.1.tar.gz","has_sig":false,"md5_digest":"39c3a8511db3af89243cfb741c66e318","packagetype":"sdist","python_version":"source","requires_python":">=3.7,<4.0","size":68078,"upload_time":"2021-10-29T16:33:12","upload_time_iso_8601":"2021-10-29T16:33:12.354230Z","url":"https://files.pythonhosted.org/packages/b1/6d/7c3f0a94bf48cffc29ac5d5e4081c11a427e300101ad0b5242a71602d067/hdl21-0.1.1.tar.gz","yanked":false,"yanked_reason":null}],"0.2.0":[{"comment_text":"","digests":{"blake2b_256":"b5481df4d5fd708abffe133450a27fe334f513a61f5d1fc1d77c5187ad402c40","md5":"72488d1a98416e73dd73bd85430dadd5","sha256":"028b7835af793c3b4a4aa85a7b543c9f28e155d03125f92aff4cfc0cd8b9bdbd"},"downloads":-1,"filename":"hdl21-0.2.0.tar.gz","has_sig":false,"md5_digest":"72488d1a98416e73dd73bd85430dadd5","packagetype":"sdist","python_version":"source","requires_python":">=3.8, <4","size":95222,"upload_time":"2022-02-17T19:58:55","upload_time_iso_8601":"2022-02-17T19:58:55.761654Z","url":"https://files.pythonhosted.org/packages/b5/48/1df4d5fd708abffe133450a27fe334f513a61f5d1fc1d77c5187ad402c40/hdl21-0.2.0.tar.gz","yanked":false,"yanked_reason":null}],"0.2.0rc1":[{"comment_text":"","digests":{"blake2b_256":"84a4e1a4a2ee3bf4d2e465bc7b36c1919f35bbc4823ae02ff05629919cf160bf","md5":"6ddbe0ae43b55ce426770083e700192d","sha256":"8b1b27eb9ac7cea318ee40c69282bbf6500cb2944d099dbbbc438d521596a23b"},"downloads":-1,"filename":"hdl21-0.2.0rc1.tar.gz","has_sig":false,"md5_digest":"6ddbe0ae43b55ce426770083e700192d","packagetype":"sdist","python_version":"source","requires_python":">=3.8, <4","size":95317,"upload_time":"2022-02-17T19:22:18","upload_time_iso_8601":"2022-02-17T19:22:18.853567Z","url":"https://files.pythonhosted.org/packages/84/a4/e1a4a2ee3bf4d2e465bc7b36c1919f35bbc4823ae02ff05629919cf160bf/hdl21-0.2.0rc1.tar.gz","yanked":false,"yanked_reason":null}],"1.0.0":[{"comment_text":"","digests":{"blake2b_256":"14159594cf187c41b037a9aeb5831616c3b0d588f9d827c056e3ff3d3c095563","md5":"f0d2c5aef920fe7cb98c91a795652bf0","sha256":"5f179ab3b6b4aef78b22e17ef36c910e717f1b103da69a53803a84ab5f2904ca"},"downloads":-1,"filename":"hdl21-1.0.0.tar.gz","has_sig":false,"md5_digest":"f0d2c5aef920fe7cb98c91a795652bf0","packagetype":"sdist","python_version":"source","requires_python":">=3.8, <4","size":123473,"upload_time":"2022-06-15T18:35:43","upload_time_iso_8601":"2022-06-15T18:35:43.993935Z","url":"https://files.pythonhosted.org/packages/14/15/9594cf187c41b037a9aeb5831616c3b0d588f9d827c056e3ff3d3c095563/hdl21-1.0.0.tar.gz","yanked":false,"yanked_reason":null}],"1.0.0rc0":[{"comment_text":"","digests":{"blake2b_256":"2ffd53e7a9e16f1e40b24b723e6d20a95e15eb313637c83c80c91417bee74413","md5":"b7855e5c2a842a1398dc2725d8168771","sha256":"c81b960d756385e1806669de80e6c5fdc6e4b5244c909903d27031a2c182a41d"},"downloads":-1,"filename":"hdl21-1.0.0rc0.tar.gz","has_sig":false,"md5_digest":"b7855e5c2a842a1398dc2725d8168771","packagetype":"sdist","python_version":"source","requires_python":">=3.8, <4","size":123394,"upload_time":"2022-06-13T20:53:49","upload_time_iso_8601":"2022-06-13T20:53:49.557617Z","url":"https://files.pythonhosted.org/packages/2f/fd/53e7a9e16f1e40b24b723e6d20a95e15eb313637c83c80c91417bee74413/hdl21-1.0.0rc0.tar.gz","yanked":false,"yanked_reason":null}],"2.0.0":[{"comment_text":"","digests":{"blake2b_256":"b3a343c2b4aebcd3b3f013a0d0ddad7e3130e9bdadd7f4a28113a0bd76e04ada","md5":"4e16434a91b8412b6a776d6d8e7dcd80","sha256":"b585f095de61f5c763ccf8cc183df8cee6170a54eb086b8d2efa1635d0e6b8a8"},"downloads":-1,"filename":"hdl21-2.0.0.tar.gz","has_sig":false,"md5_digest":"4e16434a91b8412b6a776d6d8e7dcd80","packagetype":"sdist","python_version":"source","requires_python":">=3.7, <4","size":169693,"upload_time":"2022-11-04T21:43:35","upload_time_iso_8601":"2022-11-04T21:43:35.979935Z","url":"https://files.pythonhosted.org/packages/b3/a3/43c2b4aebcd3b3f013a0d0ddad7e3130e9bdadd7f4a28113a0bd76e04ada/hdl21-2.0.0.tar.gz","yanked":false,"yanked_reason":null}],"2.0.dev0":[{"comment_text":"","digests":{"blake2b_256":"8baa4d73b97621e2f3f700829915ce3fc3c75a82803eff01c5aeb5a9e881a8ee","md5":"4a035c59c9d6667c964031763eb357bc","sha256":"4344f25a9a91480cfa614bf34144ce03dd196c2fd936b58a50a95f5787d3156a"},"downloads":-1,"filename":"hdl21-2.0.dev0.tar.gz","has_sig":false,"md5_digest":"4a035c59c9d6667c964031763eb357bc","packagetype":"sdist","python_version":"source","requires_python":">=3.7, <4","size":168962,"upload_time":"2022-11-04T20:21:39","upload_time_iso_8601":"2022-11-04T20:21:39.292421Z","url":"https://files.pythonhosted.org/packages/8b/aa/4d73b97621e2f3f700829915ce3fc3c75a82803eff01c5aeb5a9e881a8ee/hdl21-2.0.dev0.tar.gz","yanked":false,"yanked_reason":null}],"3.0":[{"comment_text":"","digests":{"blake2b_256":"1ccc4e13613248053d17ee25e139671816b75dea5b3c79fbb028e863f0d48061","md5":"29df5a7bb342ec079bb113511ff34b78","sha256":"cd6efc2cee1f8008258ce3c7b6e4eedb0464a2f43bc3abf834ee332442caf685"},"downloads":-1,"filename":"hdl21-3.0.tar.gz","has_sig":false,"md5_digest":"29df5a7bb342ec079bb113511ff34b78","packagetype":"sdist","python_version":"source","requires_python":">=3.7, <4","size":151773,"upload_time":"2023-02-17T17:34:05","upload_time_iso_8601":"2023-02-17T17:34:05.628529Z","url":"https://files.pythonhosted.org/packages/1c/cc/4e13613248053d17ee25e139671816b75dea5b3c79fbb028e863f0d48061/hdl21-3.0.tar.gz","yanked":false,"yanked_reason":null}],"3.0.1":[{"comment_text":"","digests":{"blake2b_256":"84a7ceb3a1b3954a483da9bf7febea67b453abf2f62bf5a8c78d033dce776fef","md5":"f07648143ab1e9442874ea0c142c3050","sha256":"b38d5a965cf265323d4e70b67a29a9130a74f2a839c56479a43e047d9de851c8"},"downloads":-1,"filename":"hdl21-3.0.1.tar.gz","has_sig":false,"md5_digest":"f07648143ab1e9442874ea0c142c3050","packagetype":"sdist","python_version":"source","requires_python":">=3.7, <4","size":174246,"upload_time":"2023-03-02T01:42:39","upload_time_iso_8601":"2023-03-02T01:42:39.104934Z","url":"https://files.pythonhosted.org/packages/84/a7/ceb3a1b3954a483da9bf7febea67b453abf2f62bf5a8c78d033dce776fef/hdl21-3.0.1.tar.gz","yanked":false,"yanked_reason":null}],"3.0.dev0":[{"comment_text":"","digests":{"blake2b_256":"949c78459fdb6778648acd19ff747885cb9ebb6d7ee94fa7572966ebdc705c26","md5":"5dfaf9ff3e47ed25d309e1ec35268d16","sha256":"ae6719aefaef9d34010d9c342eda222c69609d7bb88002dc6ae0d11d78544854"},"downloads":-1,"filename":"hdl21-3.0.dev0.tar.gz","has_sig":false,"md5_digest":"5dfaf9ff3e47ed25d309e1ec35268d16","packagetype":"sdist","python_version":"source","requires_python":">=3.7, <4","size":160910,"upload_time":"2022-11-25T23:41:40","upload_time_iso_8601":"2022-11-25T23:41:40.930046Z","url":"https://files.pythonhosted.org/packages/94/9c/78459fdb6778648acd19ff747885cb9ebb6d7ee94fa7572966ebdc705c26/hdl21-3.0.dev0.tar.gz","yanked":false,"yanked_reason":null}],"3.0.dev2":[{"comment_text":"","digests":{"blake2b_256":"1306dee6168c76fb98b7d5c15cc458771f0b31da46bf96431a0ad860738954d6","md5":"768256ddeecc1ebed223998c8c30db15","sha256":"cb846be6dd56729c6f6c00a71d224f713e52bcc253b9d50722505dc253f99e43"},"downloads":-1,"filename":"hdl21-3.0.dev2.tar.gz","has_sig":false,"md5_digest":"768256ddeecc1ebed223998c8c30db15","packagetype":"sdist","python_version":"source","requires_python":">=3.7, <4","size":167251,"upload_time":"2022-12-06T00:47:19","upload_time_iso_8601":"2022-12-06T00:47:19.840898Z","url":"https://files.pythonhosted.org/packages/13/06/dee6168c76fb98b7d5c15cc458771f0b31da46bf96431a0ad860738954d6/hdl21-3.0.dev2.tar.gz","yanked":false,"yanked_reason":null}],"3.0.dev3":[{"comment_text":"","digests":{"blake2b_256":"dc11d08ea0d26d45be6bc657728ef00d769f32aeb37fcf59c95c7dd7d9a27e1b","md5":"5f5353adbf7051b1d577ca56e31a0779","sha256":"09a5acf5b6f46295a64b33a1038b65edbb1f105fde76d2f4f8a0b1e655aaa56f"},"downloads":-1,"filename":"hdl21-3.0.dev3.tar.gz","has_sig":false,"md5_digest":"5f5353adbf7051b1d577ca56e31a0779","packagetype":"sdist","python_version":"source","requires_python":">=3.7, <4","size":173764,"upload_time":"2023-01-17T23:17:34","upload_time_iso_8601":"2023-01-17T23:17:34.659273Z","url":"https://files.pythonhosted.org/packages/dc/11/d08ea0d26d45be6bc657728ef00d769f32aeb37fcf59c95c7dd7d9a27e1b/hdl21-3.0.dev3.tar.gz","yanked":false,"yanked_reason":null}],"4.0.0":[{"comment_text":"","digests":{"blake2b_256":"eea37b5d98480fd2b01e1bdc9400d33bf31c65b716e754cc28b533bce6fa73a8","md5":"757cc976d36109f30acb230113c1c49c","sha256":"5ece5e6f5a6c9b17ee1847601008cbd6d3ab1be69acf50b91c2b2dd58a666fff"},"downloads":-1,"filename":"hdl21-4.0.0.tar.gz","has_sig":false,"md5_digest":"757cc976d36109f30acb230113c1c49c","packagetype":"sdist","python_version":"source","requires_python":">=3.7, <3.12","size":203619,"upload_time":"2023-07-11T20:26:08","upload_time_iso_8601":"2023-07-11T20:26:08.357366Z","url":"https://files.pythonhosted.org/packages/ee/a3/7b5d98480fd2b01e1bdc9400d33bf31c65b716e754cc28b533bce6fa73a8/hdl21-4.0.0.tar.gz","yanked":false,"yanked_reason":null}],"4.0.0rc0":[{"comment_text":"","digests":{"blake2b_256":"b2cc9c87b71b14895460cfbf56c1e6b6bb9c4daf9d28c676fdade22544462358","md5":"ca1d38b5b4d3b02e7e529ebf3eb7b738","sha256":"de334d04375bcca6ba1624ba3e0a46094cd5b5da04435d5e66704ed2fba4fa8d"},"downloads":-1,"filename":"hdl21-4.0.0rc0.tar.gz","has_sig":false,"md5_digest":"ca1d38b5b4d3b02e7e529ebf3eb7b738","packagetype":"sdist","python_version":"source","requires_python":">=3.7, <3.12","size":203644,"upload_time":"2023-07-11T16:53:06","upload_time_iso_8601":"2023-07-11T16:53:06.447246Z","url":"https://files.pythonhosted.org/packages/b2/cc/9c87b71b14895460cfbf56c1e6b6bb9c4daf9d28c676fdade22544462358/hdl21-4.0.0rc0.tar.gz","yanked":false,"yanked_reason":null}],"5.0.0":[{"comment_text":"","digests":{"blake2b_256":"0968031d7ce8a7cc3c2333078e61a003abbdfeca79837da12f6832eca175479b","md5":"261b58158dac6060f6f436ced3277701","sha256":"2b9f6e86b95d75c174336e9698411c1c3072fc8ab105cd39ec78ffbb9328f574"},"downloads":-1,"filename":"hdl21-5.0.0.tar.gz","has_sig":false,"md5_digest":"261b58158dac6060f6f436ced3277701","packagetype":"sdist","python_version":"source","requires_python":">=3.7, <3.12","size":212126,"upload_time":"2023-11-14T18:40:11","upload_time_iso_8601":"2023-11-14T18:40:11.800876Z","url":"https://files.pythonhosted.org/packages/09/68/031d7ce8a7cc3c2333078e61a003abbdfeca79837da12f6832eca175479b/hdl21-5.0.0.tar.gz","yanked":false,"yanked_reason":null}],"6.0.0":[{"comment_text":"","digests":{"blake2b_256":"2650612c2b940a12c28428950cd08619d84e83f96f0b2e513b5da30d1849644b","md5":"00b7f75bbfbbc7fec6edeb2cd4b1e9fc","sha256":"b43787a444a51cbd49ae633be269c8e3bb35f75379a5ee8ad0711e76ed85a17d"},"downloads":-1,"filename":"hdl21-6.0.0.tar.gz","has_sig":false,"md5_digest":"00b7f75bbfbbc7fec6edeb2cd4b1e9fc","packagetype":"sdist","python_version":"source","requires_python":"<3.13,>=3.7","size":173728,"upload_time":"2024-05-24T17:15:55","upload_time_iso_8601":"2024-05-24T17:15:55.905792Z","url":"https://files.pythonhosted.org/packages/26/50/612c2b940a12c28428950cd08619d84e83f96f0b2e513b5da30d1849644b/hdl21-6.0.0.tar.gz","yanked":false,"yanked_reason":null}],"6.0.0rc0":[{"comment_text":"","digests":{"blake2b_256":"a887d4b1bba4326e5ecce49b781a8a9e1411efe61dbee0da3b029e4a1fa54321","md5":"e3526e2564acb5cf2b2b76e14ca26022","sha256":"09233d32a7dd929a7c88d8d1c2927f1e32cfbb542de53fae9f830b6bd8fdfe38"},"downloads":-1,"filename":"hdl21-6.0.0rc0.tar.gz","has_sig":false,"md5_digest":"e3526e2564acb5cf2b2b76e14ca26022","packagetype":"sdist","python_version":"source","requires_python":"<3.13,>=3.7","size":173769,"upload_time":"2024-05-24T16:55:25","upload_time_iso_8601":"2024-05-24T16:55:25.394423Z","url":"https://files.pythonhosted.org/packages/a8/87/d4b1bba4326e5ecce49b781a8a9e1411efe61dbee0da3b029e4a1fa54321/hdl21-6.0.0rc0.tar.gz","yanked":false,"yanked_reason":null}],"7.0.0.dev0":[{"comment_text":"","digests":{"blake2b_256":"28a6da1b65f14fe6efd24cbb24cb1184bc9bce914923b79c623e78faef34d7e5","md5":"60c243809087fcf43469bb0c3a8f819a","sha256":"9a070c041c376db012bb878a9438f15492abf55cf50310ae23d186eaf900ede5"},"downloads":-1,"filename":"hdl21-7.0.0.dev0.tar.gz","has_sig":false,"md5_digest":"60c243809087fcf43469bb0c3a8f819a","packagetype":"sdist","python_version":"source","requires_python":"<3.13,>=3.7","size":173764,"upload_time":"2024-05-24T17:35:09","upload_time_iso_8601":"2024-05-24T17:35:09.216744Z","url":"https://files.pythonhosted.org/packages/28/a6/da1b65f14fe6efd24cbb24cb1184bc9bce914923b79c623e78faef34d7e5/hdl21-7.0.0.dev0.tar.gz","yanked":false,"yanked_reason":null}],"7.0.0.dev1":[{"comment_text":"","digests":{"blake2b_256":"cb3d124bfbdd7cc539c4b05d1975a4c185136424fa3b6f236fa4a0a1482567c7","md5":"8109baafacf6f0503d80f719f7a0b85b","sha256":"f3f59f7453a7808586b9f1ba3551fb519f3b48dfa4704c1409ea325b85486662"},"downloads":-1,"filename":"hdl21-7.0.0.dev1.tar.gz","has_sig":false,"md5_digest":"8109baafacf6f0503d80f719f7a0b85b","packagetype":"sdist","python_version":"source","requires_python":"<3.13,>=3.7","size":173673,"upload_time":"2024-05-24T17:46:02","upload_time_iso_8601":"2024-05-24T17:46:02.261833Z","url":"https://files.pythonhosted.org/packages/cb/3d/124bfbdd7cc539c4b05d1975a4c185136424fa3b6f236fa4a0a1482567c7/hdl21-7.0.0.dev1.tar.gz","yanked":false,"yanked_reason":null}]},"urls":[{"comment_text":"","digests":{"blake2b_256":"2650612c2b940a12c28428950cd08619d84e83f96f0b2e513b5da30d1849644b","md5":"00b7f75bbfbbc7fec6edeb2cd4b1e9fc","sha256":"b43787a444a51cbd49ae633be269c8e3bb35f75379a5ee8ad0711e76ed85a17d"},"downloads":-1,"filename":"hdl21-6.0.0.tar.gz","has_sig":false,"md5_digest":"00b7f75bbfbbc7fec6edeb2cd4b1e9fc","packagetype":"sdist","python_version":"source","requires_python":"<3.13,>=3.7","size":173728,"upload_time":"2024-05-24T17:15:55","upload_time_iso_8601":"2024-05-24T17:15:55.905792Z","url":"https://files.pythonhosted.org/packages/26/50/612c2b940a12c28428950cd08619d84e83f96f0b2e513b5da30d1849644b/hdl21-6.0.0.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[]}
