{"info":{"author":null,"author_email":"Cameron Simpson <cs@cskk.id.au>","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Environment :: Console","Intended Audience :: Developers","License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)","Operating System :: OS Independent","Programming Language :: Python :: 3","Topic :: Software Development :: Libraries :: Python Modules"],"description":"Facilities associated with binary data parsing and transcription.\nThe classes in this module support easy parsing of binary data\nstructures,\nreturning instances with the binary data decoded into attributes\nand capable of transcribing themselves in binary form\n(trivially via `bytes(instance)` and also otherwise).\n\n*Latest release 20240630*:\n* flatten: do not yield empty str-as-ascii-bytes - we want to ensure that flatten never yields an empty bytes instance.\n* New AbstractBinary.write(f) method to write the binary form of this object to a file.\n* New BinarySingleValue.value_from_bytes(bytes) class method to return the value from a bytes instance.\n* Drop BinaryMixin, now folded directly into AbstractBinary.\n* AbstractBinary.scan: pass extra keyword arguments to AbstractBinary.parse, supporting plumbing eg a logging parameter through.\n\nNote: this module requires Python 3.6+ because various default\nbehaviours rely on `dict`s preserving their insert order.\n\nSee `cs.iso14496` for an ISO 14496 (eg MPEG4) parser\nbuilt using this module.\n\nTerminology used below:\n* buffer:\n  an instance of `cs.buffer.CornuCopyBuffer`,\n  which manages an iterable of bytes-like values\n  and has various useful methods;\n  it also has a few factory methods to make one from a variety of sources\n  such as bytes, iterables, binary files, `mmap`ped files,\n  TCP data streams, etc.\n* chunk:\n  a piece of binary data obeying the buffer protocol,\n  almost always a `bytes` instance or a `memoryview`,\n  but in principle also things like `bytearray`.\n\nThere are 5 main classes on which an implementor should base their data structures:\n* `BinarySingleStruct`: a factory for classes based\n  on a `struct.struct` format string with a single value;\n  this builds a `namedtuple` subclass\n* `BinaryMultiStruct`: a factory for classes based\n  on a `struct.struct` format string with multiple values;\n  this also builds a `namedtuple` subclass\n* `BinarySingleValue`: a base class for subclasses\n  parsing and transcribing a single value\n* `BinaryMultiValue`: a base class for subclasses\n  parsing and transcribing multiple values\n  with no variation\n* `SimpleBinary`: a base class for subclasses\n  with custom `.parse` and `.transcribe` methods,\n  for structures with variable fields\n\nAny the classes derived from the above inherit all the methods\nof `AbstractBinary`.\nAmongst other things, this means that the binary transcription\ncan be had simply from `bytes(instance)`,\nalthough there are more transcription methods provided\nfor when greater flexibility is desired.\nIt also means that all classes have `parse`* and `scan`* methods\nfor parsing binary data streams.\n\nYou can also instantiate objects directly;\nthere's no requirement for the source information to be binary.\n\nThere are several presupplied subclasses for common basic types\nsuch as `UInt32BE` (an unsigned 32 bit big endian integer).\n\n## Class `AbstractBinary`\n\nAbstract class for all `Binary`* implementations,\nspecifying the abstract `parse` and `transcribe` methods\nand providing various helper methods.\n\nNaming conventions:\n- `parse`* methods parse a single instance from a buffer\n- `scan`* methods are generators yielding successive instances from a buffer\n\n*Method `AbstractBinary.__bytes__(self)`*:\nThe binary transcription as a single `bytes` object.\n\n*Method `AbstractBinary.__len__(self)`*:\nCompute the length by running a transcription and measuring it.\n\n*Method `AbstractBinary.from_bytes(bs, **parse_bytes_kw)`*:\nFactory to parse an instance from the\nbytes `bs` starting at `offset`.\nReturns the new instance.\n\nRaises `ValueError` if `bs` is not entirely consumed.\nRaises `EOFError` if `bs` has insufficient data.\n\nKeyword parameters are passed to the `.parse_bytes` method.\n\nThis relies on the `cls.parse` method for the parse.\n\n*Method `AbstractBinary.load(f)`*:\nLoad an instance from the file `f`\nwhich may be a filename or an open file as for `AbstractBinary.scan`.\nReturn the instance or `None` if the file is empty.\n\n*Method `AbstractBinary.parse(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse an instance of `cls` from the buffer `bfr`.\n\n*Method `AbstractBinary.parse_bytes(bs, offset=0, length=None, **parse_kw)`*:\nFactory to parse an instance from the\nbytes `bs` starting at `offset`.\nReturns `(instance,offset)` being the new instance and the post offset.\n\nRaises `EOFError` if `bs` has insufficient data.\n\nThe parameters `offset` and `length` are passed to the\n`CornuCopyBuffer.from_bytes` factory.\n\nOther keyword parameters are passed to the `.parse` method.\n\nThis relies on the `cls.parse` method for the parse.\n\n*Method `AbstractBinary.save(self, f)`*:\nSave this instance to the file `f`\nwhich may be a filename or an open file.\nReturn the length of the transcription.\n\n*Method `AbstractBinary.scan(bfr: cs.buffer.CornuCopyBuffer, count=None, *, min_count=None, max_count=None, with_offsets=False, **parse_kw)`*:\nFunction to scan the buffer `bfr` for repeated instances of `cls`\nuntil end of input and yield them.\n\nParameters:\n* `bfr`: the buffer to scan, or any object suitable for `CornuCopyBuffer.promote`\n* `count`: the required number of instances to scan,\n  equivalent to setting `min_count=count` and `max_count=count`\n* `min_count`: the minimum number of instances to scan\n* `max_count`: the maximum number of instances to scan\n* `with_offsets`: optional flag, default `False`;\n  if true yield `(pre_offset,obj,post_offset)`, otherwise just `obj`\nIt is in error to specify both `count` and one of `min_count` or `max_count`.\n\nOther keyword arguments are passed to `self.parse()`.\n\nScanning stops after `max_count` instances (if specified).\nIf fewer than `min_count` instances (if specified) are scanned\na warning is issued.\nThis is to accomodate nonconformant streams\nwithout raising exceptions.\nCallers wanting to validate `max_count` may want to probe `bfr.at_eof()`\nafter return.\nCallers not wanting a warning over `min_count` should not specify it,\nand instead check the number of instances returned themselves.\n\n*Method `AbstractBinary.scan_fspath(fspath: str, *, with_offsets=False, **kw)`*:\nOpen the file with filesystenm path `fspath` for read\nand yield from `self.scan(..,**kw)` or\n`self.scan_with_offsets(..,**kw)` according to the\n`with_offsets` parameter.\n\n*Deprecated; please just call `scan` with a filesystem pathname.\n\nParameters:\n* `fspath`: the filesystem path of the file to scan\n* `with_offsets`: optional flag, default `False`;\n  if true then scan with `scan_with_offsets` instead of\n  with `scan`\nOther keyword parameters are passed to `scan` or\n`scan_with_offsets`.\n\n*Method `AbstractBinary.scan_with_offsets(bfr: cs.buffer.CornuCopyBuffer, count=None, min_count=None, max_count=None)`*:\nWrapper for `scan()` which yields `(pre_offset,instance,post_offset)`\nindicating the start and end offsets of the yielded instances.\nAll parameters are as for `scan()`.\n\n*Deprecated; please just call `scan` with the `with_offsets=True` parameter.\n\n*Method `AbstractBinary.self_check(self)`*:\nInternal self check. Returns `True` if passed.\n\nIf the structure has a `FIELD_TYPES` attribute, normally a\nclass attribute, then check the fields against it. The\n`FIELD_TYPES` attribute is a mapping of `field_name` to\na specification of `required` and `types`. The specification\nmay take one of 2 forms:\n* a tuple of `(required,types)`\n* a single `type`; this is equivalent to `(True,(type,))`\nTheir meanings are as follows:\n* `required`: a Boolean. If true, the field must be present\n  in the packet `field_map`, otherwise it need not be present.\n* `types`: a tuple of acceptable field types\n\nThere are some special semantics involved here.\n\nAn implementation of a structure may choose to make some\nfields plain instance attributes instead of binary objects\nin the `field_map` mapping, particularly variable structures\nsuch as a `cs.iso14496.BoxHeader`, whose `.length` may be parsed\ndirectly from its binary form or computed from other fields\ndepending on the `box_size` value. Therefore, checking for\na field is first done via the `field_map` mapping, then by\n`getattr`, and as such the acceptable `types` may include\nnonstructure types such as `int`.\n\nHere is the `cs.iso14496` `Box.FIELD_TYPES` definition as an example:\n\n    FIELD_TYPES = {\n        'header': BoxHeader,\n        'body': BoxBody,\n        'unparsed': list,\n        'offset': int,\n        'unparsed_offset': int,\n        'end_offset': int,\n    }\n\nNote that `length` includes some nonstructure types,\nand that it is written as a tuple of `(True,types)` because\nit has more than one acceptable type.\n\n*Method `AbstractBinary.transcribe(self)`*:\nReturn or yield `bytes`, ASCII string, `None` or iterables\ncomprising the binary form of this instance.\n\nThis aims for maximum convenience when transcribing a data structure.\n\nThis may be implemented as a generator, yielding parts of the structure.\n\nThis may be implemented as a normal function, returning:\n* `None`: no bytes of data,\n  for example for an omitted or empty structure\n* a `bytes`-like object: the full data bytes for the structure\n* an ASCII compatible string:\n  this will be encoded with the `'ascii'` encoding to make `bytes`\n* an iterable:\n  the components of the structure,\n  including substranscriptions which themselves\n  adhere to this protocol - they may be `None`, `bytes`-like objects,\n  ASCII compatible strings or iterables.\n  This supports directly returning or yielding the result of a field's\n  `.transcribe` method.\n\n*Method `AbstractBinary.transcribe_flat(self)`*:\nReturn a flat iterable of chunks transcribing this field.\n\n*Method `AbstractBinary.transcribed_length(self)`*:\nCompute the length by running a transcription and measuring it.\n\n*Method `AbstractBinary.write(self, file, *, flush=False)`*:\nWrite this instance to `file`, a file-like object supporting\n`.write(bytes)` and `.flush()`.\nReturn the number of bytes written.\n\n## Class `BinaryByteses(AbstractBinary)`\n\nA list of `bytes` parsed directly from the native iteration of the buffer.\n\n## Function `BinaryFixedBytes(class_name: str, length: int)`\n\nFactory for an `AbstractBinary` subclass matching `length` bytes of data.\nThe bytes are saved as the attribute `.data`.\n\n## Class `BinaryListValues(AbstractBinary)`\n\nA list of values with a common parse specification,\nsuch as sample or Boxes in an ISO14496 Box structure.\n\n*Method `BinaryListValues.parse(bfr: cs.buffer.CornuCopyBuffer, count=None, *, end_offset=None, min_count=None, max_count=None, pt)`*:\nRead values from `bfr`.\nReturn a `BinaryListValue` containing the values.\n\nParameters:\n* `count`: optional count of values to read;\n  if specified, exactly this many values are expected.\n* `end_offset`: an optional bounding end offset of the buffer.\n* `min_count`: the least acceptable number of values.\n* `max_count`: the most acceptable number of values.\n* `pt`: a parse/transcribe specification\n  as accepted by the `pt_spec()` factory.\n  The values will be returned by its parse function.\n\n*Method `BinaryListValues.transcribe(self)`*:\nTranscribe all the values.\n\n## Function `BinaryMultiStruct(class_name: str, struct_format: str, field_names: Union[str, List[str]])`\n\nA class factory for `AbstractBinary` `namedtuple` subclasses\nbuilt around complex `struct` formats.\n\nParameters:\n* `class_name`: name for the generated class\n* `struct_format`: the `struct` format string\n* `field_names`: field name list,\n  a space separated string or an interable of strings\n\nExample:\n\n    # an \"access point\" record from the .ap file\n    Enigma2APInfo = BinaryMultiStruct('Enigma2APInfo', '>QQ', 'pts offset')\n\n    # a \"cut\" record from the .cuts file\n    Enigma2Cut = BinaryMultiStruct('Enigma2Cut', '>QL', 'pts type')\n\n## Function `BinaryMultiValue(class_name, field_map, field_order=None)`\n\nConstruct a `SimpleBinary` subclass named `class_name`\nwhose fields are specified by the mapping `field_map`.\n\nThe `field_map` is a mapping of field name to buffer parsers and transcribers.\n\n*Note*:\nif `field_order` is not specified\nit is constructed by iterating over `field_map`.\nPrior to Python 3.6, `dict`s do not provide a reliable order\nand should be accompanied by an explicit `field_order`.\nFrom 3.6 onward a `dict` is enough and its insertion order\nwill dictate the default `field_order`.\n\nFor a fixed record structure\nthe default `.parse` and `.transcribe` methods will suffice;\nthey parse or transcribe each field in turn.\nSubclasses with variable records should override\nthe `.parse` and `.transcribe` methods\naccordingly.\n\nThe `field_map` is a mapping of field name\nto a class returned by the `pt_spec()` function.\n\nIf the class has both `parse_value` and `transcribe_value` methods\nthen the value itself will be directly stored.\nOtherwise the class it presumed to be more complex subclass\nof `AbstractBinary` and the instance is stored.\n\nHere is an example exhibiting various ways of defining each field:\n* `n1`: defined with the *`_value` methods of `UInt8`,\n  which return or transcribe the `int` from an unsigned 8 bit value;\n  this stores a `BinarySingleValue` whose `.value` is an `int`\n* `n2`: defined from the `UInt8` class,\n  which parses an unsigned 8 bit value;\n  this stores an `UInt8` instance\n  (also a `BinarySingleValue` whole `.value` is an `int`)\n* `n3`: like `n2`\n* `data1`: defined with the *`_value` methods of `BSData`,\n  which return or transcribe the data `bytes`\n  from a run length encoded data chunk;\n  this stores a `BinarySingleValue` whose `.value` is a `bytes`\n* `data2`: defined from the `BSData` class\n  which parses a run length encoded data chunk;\n  this is a `BinarySingleValue` so we store its `bytes` value directly.\n\n      >>> class BMV(BinaryMultiValue(\"BMV\", {\n      ...         'n1': (UInt8.parse_value, UInt8.transcribe_value),\n      ...         'n2': UInt8,\n      ...         'n3': UInt8,\n      ...         'nd': ('>H4s', 'short bs'),\n      ...         'data1': (\n      ...             BSData.parse_value,\n      ...             BSData.transcribe_value,\n      ...         ),\n      ...         'data2': BSData,\n      ... })):\n      ...     pass\n      >>> BMV.FIELD_ORDER\n      ['n1', 'n2', 'n3', 'nd', 'data1', 'data2']\n      >>> bmv = BMV.from_bytes(b'\\x11\\x22\\x77\\x81\\x82zyxw\\x02AB\\x04DEFG')\n      >>> bmv.n1  #doctest: +ELLIPSIS\n      17\n      >>> bmv.n2\n      34\n      >>> bmv  #doctest: +ELLIPSIS\n      BMV(n1=17, n2=34, n3=119, nd=nd_1_short__bs(short=33154, bs=b'zyxw'), data1=b'AB', data2=b'DEFG')\n      >>> bmv.nd  #doctest: +ELLIPSIS\n      nd_1_short__bs(short=33154, bs=b'zyxw')\n      >>> bmv.nd.bs\n      b'zyxw'\n      >>> bytes(bmv.nd)\n      b'zyxw'\n      >>> bmv.data1\n      b'AB'\n      >>> bmv.data2\n      b'DEFG'\n      >>> bytes(bmv)\n      b'\\x11\"w\\x81\\x82zyxw\\x02AB\\x04DEFG'\n      >>> list(bmv.transcribe_flat())\n      [b'\\x11', b'\"', b'w', b'\\x81\\x82zyxw', b'\\x02', b'AB', b'\\x04', b'DEFG']\n\n## Function `BinarySingleStruct(class_name: str, struct_format: str, field_name: Optional[str] = None)`\n\nA convenience wrapper for `BinaryMultiStruct`\nfor `struct_format`s with a single field.\n\nParameters:\n* `class_name`: the class name for the generated class\n* `struct_format`: the struct format string, specifying a\n  single struct field\n* `field_name`: optional field name for the value,\n  default `'value'`\n\nExample:\n\n    >>> UInt16BE = BinarySingleStruct('UInt16BE', '>H')\n    >>> UInt16BE.__name__\n    'UInt16BE'\n    >>> UInt16BE.format\n    '>H'\n    >>> UInt16BE.struct   #doctest: +ELLIPSIS\n    <_struct.Struct object at ...>\n    >>> field = UInt16BE.from_bytes(bytes((2,3)))\n    >>> field\n    UInt16BE(value=515)\n    >>> field.value\n    515\n\n## Class `BinarySingleValue(AbstractBinary)`\n\nA representation of a single value as the attribute `.value`.\n\nSubclasses must implement:\n* `parse` or `parse_value`\n* `transcribe` or `transcribe_value`\n\n*Method `BinarySingleValue.parse(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse an instance from `bfr`.\n\nSubclasses must implement this method or `parse_value`.\n\n*Method `BinarySingleValue.parse_value(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse a value from `bfr` based on this class.\n\nSubclasses must implement this method or `parse`.\n\n*Method `BinarySingleValue.parse_value_from_bytes(bs, offset=0, length=None, **kw)`*:\nParse a value from the bytes `bs` based on this class.\nReturn `(value,offset)`.\n\n*Method `BinarySingleValue.scan_values(bfr: cs.buffer.CornuCopyBuffer, **kw)`*:\nScan `bfr`, yield values.\n\n*Method `BinarySingleValue.transcribe(self)`*:\nTranscribe this instance as bytes.\n\nSubclasses must implement this method or `transcribe_value`.\n\n*Method `BinarySingleValue.transcribe_value(value)`*:\nTranscribe `value` as bytes based on this class.\n\nSubclasses must implement this method or `transcribe`.\n\n*Method `BinarySingleValue.value_from_bytes(bs, **from_bytes_kw)`*:\nDecode an instance from `bs` using `.from_bytes`\nand return the `.value` attribute.\nKeyword arguments are passed to `cls.from_bytes`.\n\n## Class `BinaryUTF16NUL(BinarySingleValue)`\n\nA NUL terminated UTF-16 string.\n\n*Method `BinaryUTF16NUL.__init__(self, value: str, *, encoding: str)`*:\npylint: disable=super-init-not-called\n\n*Method `BinaryUTF16NUL.parse(bfr: cs.buffer.CornuCopyBuffer, *, encoding: str)`*:\nParse the encoding and value and construct an instance.\n\n*Method `BinaryUTF16NUL.parse_value(bfr: cs.buffer.CornuCopyBuffer, *, encoding: str) -> str`*:\nRead a NUL terminated UTF-16 string from `bfr`, return a `UTF16NULField`.\nThe mandatory parameter `encoding` specifies the UTF16 encoding to use\n(`'utf_16_be'` or `'utf_16_le'`).\n\n*Method `BinaryUTF16NUL.transcribe(self)`*:\nTranscribe `self.value` in UTF-16 with a terminating NUL.\n\n*Method `BinaryUTF16NUL.transcribe_value(value: str, encoding='utf-16')`*:\nTranscribe `value` in UTF-16 with a terminating NUL.\n\n## Class `BinaryUTF8NUL(BinarySingleValue)`\n\nA NUL terminated UTF-8 string.\n\n*Method `BinaryUTF8NUL.parse_value(bfr: cs.buffer.CornuCopyBuffer) -> str`*:\nRead a NUL terminated UTF-8 string from `bfr`, return field.\n\n*Method `BinaryUTF8NUL.transcribe_value(s)`*:\nTranscribe the `value` in UTF-8 with a terminating NUL.\n\n## Class `BSData(BinarySingleValue)`\n\nA run length encoded data chunk, with the length encoded as a `BSUInt`.\n\n*Property `BSData.data`*:\nAn alias for the `.value` attribute.\n\n*Property `BSData.data_offset`*:\nThe length of the length indicator,\nuseful for computing the location of the raw data.\n\n*Method `BSData.data_offset_for(bs) -> int`*:\nCompute the `data_offset` which would obtain for the bytes `bs`.\n\n*Method `BSData.parse_value(bfr: cs.buffer.CornuCopyBuffer) -> bytes`*:\nParse the data from `bfr`.\n\n*Method `BSData.transcribe_value(data)`*:\nTranscribe the payload length and then the payload.\n\n## Class `BSSFloat(BinarySingleValue)`\n\nA float transcribed as a `BSString` of `str(float)`.\n\n*Method `BSSFloat.parse_value(bfr: cs.buffer.CornuCopyBuffer) -> float`*:\nParse a `BSSFloat` from a buffer and return the `float`.\n\n*Method `BSSFloat.transcribe_value(f)`*:\nTranscribe a `float`.\n\n## Class `BSString(BinarySingleValue)`\n\nA run length encoded string, with the length encoded as a BSUInt.\n\n*Method `BSString.parse_value(bfr: cs.buffer.CornuCopyBuffer, encoding='utf-8', errors='strict') -> str`*:\nParse a run length encoded string from `bfr`.\n\n*Method `BSString.transcribe_value(value: str, encoding='utf-8')`*:\nTranscribe a string.\n\n## Class `BSUInt(BinarySingleValue)`\n\nA binary serialised unsigned `int`.\n\nThis uses a big endian byte encoding where continuation octets\nhave their high bit set. The bits contributing to the value\nare in the low order 7 bits.\n\n*Method `BSUInt.decode_bytes(data, offset=0) -> Tuple[int, int]`*:\nDecode an extensible byte serialised unsigned `int` from `data` at `offset`.\nReturn value and new offset.\n\nContinuation octets have their high bit set.\nThe octets are big-endian.\n\nIf you just have a `bytes` instance, this is the go. If you're\nreading from a stream you're better off with `parse` or `parse_value`.\n\nExamples:\n\n    >>> BSUInt.decode_bytes(b'\\0')\n    (0, 1)\n\nNote: there is of course the usual `AbstractBinary.parse_bytes`\nbut that constructs a buffer to obtain the individual bytes;\nthis static method will be more performant\nif all you are doing is reading this serialisation\nand do not already have a buffer.\n\n*Method `BSUInt.parse_value(bfr: cs.buffer.CornuCopyBuffer) -> int`*:\nParse an extensible byte serialised unsigned `int` from a buffer.\n\nContinuation octets have their high bit set.\nThe value is big-endian.\n\nThis is the go for reading from a stream. If you already have\na bare bytes instance then the `.decode_bytes` static method\nis probably most efficient;\nthere is of course the usual `AbstractBinary.parse_bytes`\nbut that constructs a buffer to obtain the individual bytes.\n\n*Method `BSUInt.transcribe_value(n)`*:\nEncode an unsigned int as an entensible byte serialised octet\nsequence for decode. Return the bytes object.\n\n## Function `flatten(chunks)`\n\nFlatten `chunks` into an iterable of `bytes`-like instances.\nNone of the `bytes` instances will be empty.\n\nThis exists to allow subclass methods to easily return\ntranscribeable things (having a `.transcribe` method), ASCII\nstrings or bytes or iterables or even `None`, in turn allowing\nthem simply to return their superclass' chunks iterators\ndirectly instead of having to unpack them.\n\nAn example from the `cs.iso14496.METABoxBody` class:\n\n    def transcribe(self):\n        yield super().transcribe()\n        yield self.theHandler\n        yield self.boxes\n\nThe binary classes `flatten` the result of the `.transcribe`\nmethod to obtain `bytes` insteances for the object's bnary\ntranscription.\n\n## Class `Float64BE(Float64BE, AbstractBinary)`\n\nAn `AbstractBinary` `namedtuple` which parses and transcribes\nthe struct format `'>d'` and presents the attributes ('value',).\n\n*Method `Float64BE.parse(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse from `bfr` via `struct.unpack`.\n\n*Method `Float64BE.parse_value(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse a value from `bfr`, return the value.\n\n*Method `Float64BE.transcribe(self)`*:\nTranscribe via `struct.pack`.\n\n*Method `Float64BE.transcribe_value(value)`*:\nTranscribe a value back into bytes.\n\n## Class `Float64LE(Float64LE, AbstractBinary)`\n\nAn `AbstractBinary` `namedtuple` which parses and transcribes\nthe struct format `'<d'` and presents the attributes ('value',).\n\n*Method `Float64LE.parse(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse from `bfr` via `struct.unpack`.\n\n*Method `Float64LE.parse_value(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse a value from `bfr`, return the value.\n\n*Method `Float64LE.transcribe(self)`*:\nTranscribe via `struct.pack`.\n\n*Method `Float64LE.transcribe_value(value)`*:\nTranscribe a value back into bytes.\n\n## Class `Int16BE(Int16BE, AbstractBinary)`\n\nAn `AbstractBinary` `namedtuple` which parses and transcribes\nthe struct format `'>h'` and presents the attributes ('value',).\n\n*Method `Int16BE.parse(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse from `bfr` via `struct.unpack`.\n\n*Method `Int16BE.parse_value(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse a value from `bfr`, return the value.\n\n*Method `Int16BE.transcribe(self)`*:\nTranscribe via `struct.pack`.\n\n*Method `Int16BE.transcribe_value(value)`*:\nTranscribe a value back into bytes.\n\n## Class `Int16LE(Int16LE, AbstractBinary)`\n\nAn `AbstractBinary` `namedtuple` which parses and transcribes\nthe struct format `'<h'` and presents the attributes ('value',).\n\n*Method `Int16LE.parse(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse from `bfr` via `struct.unpack`.\n\n*Method `Int16LE.parse_value(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse a value from `bfr`, return the value.\n\n*Method `Int16LE.transcribe(self)`*:\nTranscribe via `struct.pack`.\n\n*Method `Int16LE.transcribe_value(value)`*:\nTranscribe a value back into bytes.\n\n## Class `Int32BE(Int32BE, AbstractBinary)`\n\nAn `AbstractBinary` `namedtuple` which parses and transcribes\nthe struct format `'>l'` and presents the attributes ('value',).\n\n*Method `Int32BE.parse(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse from `bfr` via `struct.unpack`.\n\n*Method `Int32BE.parse_value(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse a value from `bfr`, return the value.\n\n*Method `Int32BE.transcribe(self)`*:\nTranscribe via `struct.pack`.\n\n*Method `Int32BE.transcribe_value(value)`*:\nTranscribe a value back into bytes.\n\n## Class `Int32LE(Int32LE, AbstractBinary)`\n\nAn `AbstractBinary` `namedtuple` which parses and transcribes\nthe struct format `'<l'` and presents the attributes ('value',).\n\n*Method `Int32LE.parse(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse from `bfr` via `struct.unpack`.\n\n*Method `Int32LE.parse_value(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse a value from `bfr`, return the value.\n\n*Method `Int32LE.transcribe(self)`*:\nTranscribe via `struct.pack`.\n\n*Method `Int32LE.transcribe_value(value)`*:\nTranscribe a value back into bytes.\n\n## Function `pt_spec(pt, name=None)`\n\nConvert a parse/transcribe specification `pt`\ninto an `AbstractBinary` subclass.\n\nThis is largely used to provide flexibility\nin the specifications for the `BinaryMultiValue` factory\nbut can be used as a factory for other simple classes.\n\nIf the specification `pt` is a subclass of `AbstractBinary`\nthis is returned directly.\n\nIf `pt` is a 2-tuple of `str`\nthe values are presumed to be a format string for `struct.struct`\nand filed names separated by spaces;\na new `BinaryMultiStruct` class is created from these and returned.\n\nOtherwise two functions\n`f_parse_value(bfr)` and `f_transcribe_value(value)`\nare obtained and used to construct a new `BinarySingleValue` class\nas follows:\n\nIf `pt` has `.parse_value` and `.transcribe_value` callable attributes,\nuse those for `f_parse_value` and `f_transcribe_value` respectively.\n\nOtherwise, if `pt` is an `int`\ndefine `f_parse_value` to obtain exactly that many bytes from a buffer\nand `f_transcribe_value` to return those bytes directly.\n\nOtherwise presume `pt` is a 2-tuple of `(f_parse_value,f_transcribe_value)`.\n\n## Class `SimpleBinary(types.SimpleNamespace, AbstractBinary)`\n\nAbstract binary class based on a `SimpleNamespace`,\nthus providing a nice `__str__` and a keyword based `__init__`.\nImplementors must still define `.parse` and `.transcribe`.\n\nTo constrain the arguments passed to `__init__`,\ndefine an `__init__` which accepts specific keyword arguments\nand pass through to `super().__init__()`. Example:\n\n    def __init__(self, *, field1=None, field2):\n        \"\"\" Accept only `field1` (optional)\n            and `field2` (mandatory).\n        \"\"\"\n        super().__init__(field1=field1, field2=field2)\n\n## Class `UInt16BE(UInt16BE, AbstractBinary)`\n\nAn `AbstractBinary` `namedtuple` which parses and transcribes\nthe struct format `'>H'` and presents the attributes ('value',).\n\n*Method `UInt16BE.parse(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse from `bfr` via `struct.unpack`.\n\n*Method `UInt16BE.parse_value(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse a value from `bfr`, return the value.\n\n*Method `UInt16BE.transcribe(self)`*:\nTranscribe via `struct.pack`.\n\n*Method `UInt16BE.transcribe_value(value)`*:\nTranscribe a value back into bytes.\n\n## Class `UInt16LE(UInt16LE, AbstractBinary)`\n\nAn `AbstractBinary` `namedtuple` which parses and transcribes\nthe struct format `'<H'` and presents the attributes ('value',).\n\n*Method `UInt16LE.parse(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse from `bfr` via `struct.unpack`.\n\n*Method `UInt16LE.parse_value(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse a value from `bfr`, return the value.\n\n*Method `UInt16LE.transcribe(self)`*:\nTranscribe via `struct.pack`.\n\n*Method `UInt16LE.transcribe_value(value)`*:\nTranscribe a value back into bytes.\n\n## Class `UInt32BE(UInt32BE, AbstractBinary)`\n\nAn `AbstractBinary` `namedtuple` which parses and transcribes\nthe struct format `'>L'` and presents the attributes ('value',).\n\n*Method `UInt32BE.parse(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse from `bfr` via `struct.unpack`.\n\n*Method `UInt32BE.parse_value(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse a value from `bfr`, return the value.\n\n*Method `UInt32BE.transcribe(self)`*:\nTranscribe via `struct.pack`.\n\n*Method `UInt32BE.transcribe_value(value)`*:\nTranscribe a value back into bytes.\n\n## Class `UInt32LE(UInt32LE, AbstractBinary)`\n\nAn `AbstractBinary` `namedtuple` which parses and transcribes\nthe struct format `'<L'` and presents the attributes ('value',).\n\n*Method `UInt32LE.parse(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse from `bfr` via `struct.unpack`.\n\n*Method `UInt32LE.parse_value(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse a value from `bfr`, return the value.\n\n*Method `UInt32LE.transcribe(self)`*:\nTranscribe via `struct.pack`.\n\n*Method `UInt32LE.transcribe_value(value)`*:\nTranscribe a value back into bytes.\n\n## Class `UInt64BE(UInt64BE, AbstractBinary)`\n\nAn `AbstractBinary` `namedtuple` which parses and transcribes\nthe struct format `'>Q'` and presents the attributes ('value',).\n\n*Method `UInt64BE.parse(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse from `bfr` via `struct.unpack`.\n\n*Method `UInt64BE.parse_value(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse a value from `bfr`, return the value.\n\n*Method `UInt64BE.transcribe(self)`*:\nTranscribe via `struct.pack`.\n\n*Method `UInt64BE.transcribe_value(value)`*:\nTranscribe a value back into bytes.\n\n## Class `UInt64LE(UInt64LE, AbstractBinary)`\n\nAn `AbstractBinary` `namedtuple` which parses and transcribes\nthe struct format `'<Q'` and presents the attributes ('value',).\n\n*Method `UInt64LE.parse(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse from `bfr` via `struct.unpack`.\n\n*Method `UInt64LE.parse_value(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse a value from `bfr`, return the value.\n\n*Method `UInt64LE.transcribe(self)`*:\nTranscribe via `struct.pack`.\n\n*Method `UInt64LE.transcribe_value(value)`*:\nTranscribe a value back into bytes.\n\n## Class `UInt8(UInt8, AbstractBinary)`\n\nAn `AbstractBinary` `namedtuple` which parses and transcribes\nthe struct format `'B'` and presents the attributes ('value',).\n\n*Method `UInt8.parse(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse from `bfr` via `struct.unpack`.\n\n*Method `UInt8.parse_value(bfr: cs.buffer.CornuCopyBuffer)`*:\nParse a value from `bfr`, return the value.\n\n*Method `UInt8.transcribe(self)`*:\nTranscribe via `struct.pack`.\n\n*Method `UInt8.transcribe_value(value)`*:\nTranscribe a value back into bytes.\n\n# Release Log\n\n\n\n*Release 20240630*:\n* flatten: do not yield empty str-as-ascii-bytes - we want to ensure that flatten never yields an empty bytes instance.\n* New AbstractBinary.write(f) method to write the binary form of this object to a file.\n* New BinarySingleValue.value_from_bytes(bytes) class method to return the value from a bytes instance.\n* Drop BinaryMixin, now folded directly into AbstractBinary.\n* AbstractBinary.scan: pass extra keyword arguments to AbstractBinary.parse, supporting plumbing eg a logging parameter through.\n\n*Release 20240422*:\nNew _BinaryMultiValue_Base.for_json() method returning a dict containing the fields.\n\n*Release 20240316*:\nFixed release upload artifacts.\n\n*Release 20240201*:\nBREAKING CHANGE: drop the long deprecated PacketField related classes.\n\n*Release 20231129*:\nBinaryMultiStruct.parse: promote the buffer arguments to a CornuCopyBuffer.\n\n*Release 20230401*:\n* BinaryMixin.scan: `bfr` parameter may be any object acceptable to CornuCopyBuffer.promote.\n* BinaryMixin.scan: accept new optional with_offsets parameter; deprecate scan_with_offsets and scan_fspathi in favour of scan.\n\n*Release 20230212*:\n* BinaryMixin: new load(file) and save(file) methods.\n* BinaryMixin.scan: promote the bfr argument.\n\n*Release 20221206*:\nDocumentation fix.\n\n*Release 20220605*:\nBinaryMixin: replace scan_file with scan_fspath, as the former left uncertainty about the amount of the file consumed.\n\n*Release 20210316*:\n* BSUInt: rename parse_bytes to decode_bytes, the former name conflicted with BinaryMixin.parse_bytes and broken the semantics.\n* Minor refactors.\n\n*Release 20210306*:\nMAJOR RELEASE: The PacketField classes and friends were hard to use; this release supplied a suite of easier to use and more consistent Binary* classes, and ports most of those things based on the old scheme to the new scheme.\n\n*Release 20200229*:\n* ListField: replace transcribe method with transcribe_value method, aids external use.\n* Add `.length` attribute to struct based packet classes providing the data length of the structure (struct.Struct.size).\n* Packet: new `add_deferred_field` method to consume the raw data for a field for parsing later (done automatically if the attribute is accessed).\n* New `@deferred_field` decorator for the parser for that stashed data.\n\n*Release 20191230.3*:\nDocstring tweak.\n\n*Release 20191230.2*:\nDocumentation updates.\n\n*Release 20191230.1*:\nDocstring updates. Semantic changes were in the previous release.\n\n*Release 20191230*:\n* ListField: new __iter__ method.\n* Packet: __str__: accept optional `skip_fields` parameter to omit some field names.\n* Packet: new .add_from_value method to add a named field with a presupplied value.\n* Packet: new remove_field(field_name) and pop_field() methods to remove fields.\n* BytesesField: __iter__ yields the bytes values, transcribe=__iter__.\n* PacketField: propagate keyword arguments through various methods, required for parameterised PacketFields.\n* New UTF16NULField, a NUL terminated UTF16 string.\n* PacketField: provide a default `.transcribe_value` method which makes a new instance and calls its `.transcribe` method.\n* Documentation update and several minor changes.\n\n*Release 20190220*:\n* Packet.self_check: fields without a sanity check cause a warning, not a ValueError.\n* New Float64BE, Float64LE and BSSFloat classes for IEEE floats and floats-as-strings.\n* Additional module docstringage on subclassing Packet and PacketField.\n* BSString: drop redundant from_buffer class method.\n* PacketField.__init__: default to value=None if omitted.\n\n*Release 20181231*:\nflatten: do not yield zero length bytelike objects, can be misread as EOF on some streams.\n\n*Release 20181108*:\n* New PacketField.transcribe_value_flat convenience method to return a flat iterable of bytes-like objects.\n* New PacketField.parse_buffer generator method to parse instances of the PacketField from a buffer until end of input.\n* New PacketField.parse_buffer_values generator method to parse instances of the PacketField from a buffer and yield the `.value` attribute until end of input.\n\n*Release 20180823*:\n* Some bugfixes.\n* Define PacketField.__eq__.\n* BSUInt, BSData and BSString classes implementing the serialisations from cs.serialise.\n* New PacketField.value_from_bytes class method.\n* New PacketField.value_from_buffer method.\n\n*Release 20180810.2*:\nDocumentation improvements.\n\n*Release 20180810.1*:\nImprove module description.\n\n*Release 20180810*:\nBytesesField.from_buffer: make use of the buffer's skipto method if discard_data is true.\n\n*Release 20180805*:\n* Packet: now an abstract class, new self_check method initially checking the\n* PACKET_FIELDS class attribute against the instance, new methods get_field\n* and set_field to fetch or replace existing fields, allow keyword arguments\n* to initialise the Packet fields and document the dependency on keyword\n* argument ordering.\n* PacketField: __len__ computed directory from a transcribe, drop other __len__\n* methods.\n* EmptyField singleton to use as a placeholder for missing optional fields.\n* BytesField: implement value_s and from_buffer.\n* multi_struct_field: implement __len__ for generated class.\n* flatten: treat memoryviews like bytes.\n* Assorted docstrings and fixes.\n\n*Release 20180801*:\nInitial PyPI release.\n","description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":null,"keywords":"python3","license":"GNU General Public License v3 or later (GPLv3+)","maintainer":null,"maintainer_email":null,"name":"cs.binary","package_url":"https://pypi.org/project/cs.binary/","platform":null,"project_url":"https://pypi.org/project/cs.binary/","project_urls":{"MonoRepo Commits":"https://bitbucket.org/cameron_simpson/css/commits/branch/main","Monorepo Git Mirror":"https://github.com/cameron-simpson/css","Monorepo Hg/Mercurial Mirror":"https://hg.sr.ht/~cameron-simpson/css","Source":"https://github.com/cameron-simpson/css/blob/main/lib/python/cs/binary.py"},"provides_extra":null,"release_url":"https://pypi.org/project/cs.binary/20240630/","requires_dist":["cs.buffer>=20240630","cs.deco>=20240630","cs.gimmicks>=20240316","cs.lex>=20240630","cs.pfx>=20240630","cs.seq>=20221118"],"requires_python":null,"summary":"Facilities associated with binary data parsing and transcription. The classes in this module support easy parsing of binary data structures, returning instances with the binary data decoded into attributes and capable of transcribing themselves in binary form (trivially via `bytes(instance)` and also otherwise).","version":"20240630","yanked":false,"yanked_reason":null},"last_serial":23911381,"releases":{"20180801":[{"comment_text":"","digests":{"blake2b_256":"ac1f36cd473ce89ccee42719ba7ec9e3f80a42faa781438ef3004f3808ce5856","md5":"4f7061791ca98c45e9cde6d484400a00","sha256":"72ed8c091a5f260ddd43e942e5a1ee5123f020818bfadb175d0484eebbd9b671"},"downloads":-1,"filename":"cs.binary-20180801.tar.gz","has_sig":false,"md5_digest":"4f7061791ca98c45e9cde6d484400a00","packagetype":"sdist","python_version":"source","requires_python":null,"size":7010,"upload_time":"2018-08-01T01:08:43","upload_time_iso_8601":"2018-08-01T01:08:43.205711Z","url":"https://files.pythonhosted.org/packages/ac/1f/36cd473ce89ccee42719ba7ec9e3f80a42faa781438ef3004f3808ce5856/cs.binary-20180801.tar.gz","yanked":false,"yanked_reason":null}],"20180805":[{"comment_text":"","digests":{"blake2b_256":"c8ae8258d2259d0cbcbedcadbc647ae8f672218cafd78349591e5650bd2a1ab8","md5":"bb5d025ae3e4733619e0d85066cf57f5","sha256":"fbce0f378ad5c25678d5033f5975309bb569a2c7c2480b00628faa053443ed92"},"downloads":-1,"filename":"cs.binary-20180805.tar.gz","has_sig":false,"md5_digest":"bb5d025ae3e4733619e0d85066cf57f5","packagetype":"sdist","python_version":"source","requires_python":null,"size":9304,"upload_time":"2018-08-05T11:02:38","upload_time_iso_8601":"2018-08-05T11:02:38.487378Z","url":"https://files.pythonhosted.org/packages/c8/ae/8258d2259d0cbcbedcadbc647ae8f672218cafd78349591e5650bd2a1ab8/cs.binary-20180805.tar.gz","yanked":false,"yanked_reason":null}],"20180810":[{"comment_text":"","digests":{"blake2b_256":"bf570a4194bc76f74746504818cb189af7d37f2652383d0588bc9a7ae074bed0","md5":"fd95a999da7a4931394e033b9594bc4c","sha256":"91395927b8bd582d36f9338066aa982c9a0f23b452a628c36505e06784078db1"},"downloads":-1,"filename":"cs.binary-20180810.tar.gz","has_sig":false,"md5_digest":"fd95a999da7a4931394e033b9594bc4c","packagetype":"sdist","python_version":"source","requires_python":null,"size":9429,"upload_time":"2018-08-09T23:09:48","upload_time_iso_8601":"2018-08-09T23:09:48.843765Z","url":"https://files.pythonhosted.org/packages/bf/57/0a4194bc76f74746504818cb189af7d37f2652383d0588bc9a7ae074bed0/cs.binary-20180810.tar.gz","yanked":false,"yanked_reason":null}],"20180810.1":[{"comment_text":"","digests":{"blake2b_256":"93fb65986c09d4c6121ce844eb4399b30bfe32a1aabb981f12660f6a60a215e3","md5":"1561ed403b90a35d61809dcb5f1df0ef","sha256":"8ef1bd098b39896c7c446befb2a905502acbcc359f3a5e3f0e28d8ffb66ea5a2"},"downloads":-1,"filename":"cs.binary-20180810.1.tar.gz","has_sig":false,"md5_digest":"1561ed403b90a35d61809dcb5f1df0ef","packagetype":"sdist","python_version":"source","requires_python":null,"size":10885,"upload_time":"2018-08-09T23:51:34","upload_time_iso_8601":"2018-08-09T23:51:34.582805Z","url":"https://files.pythonhosted.org/packages/93/fb/65986c09d4c6121ce844eb4399b30bfe32a1aabb981f12660f6a60a215e3/cs.binary-20180810.1.tar.gz","yanked":false,"yanked_reason":null}],"20180810.2":[{"comment_text":"","digests":{"blake2b_256":"ffc0fcfb4ecb89ae720b701247dc8f449b4a5d091d44fdceb05e431ef38efbcf","md5":"9f6aa643aaa16e89c2d6bd78585241c5","sha256":"b8149c55d38e88d8896e0ca8a01604a69a0386932b47faa9883228fbc0178ce1"},"downloads":-1,"filename":"cs.binary-20180810.2.tar.gz","has_sig":false,"md5_digest":"9f6aa643aaa16e89c2d6bd78585241c5","packagetype":"sdist","python_version":"source","requires_python":null,"size":11269,"upload_time":"2018-08-10T01:55:44","upload_time_iso_8601":"2018-08-10T01:55:44.191888Z","url":"https://files.pythonhosted.org/packages/ff/c0/fcfb4ecb89ae720b701247dc8f449b4a5d091d44fdceb05e431ef38efbcf/cs.binary-20180810.2.tar.gz","yanked":false,"yanked_reason":null}],"20180823":[{"comment_text":"","digests":{"blake2b_256":"6783181631b6a10945d8f3fb0097df1b04baa213de430f11ff83fdf475cec5e7","md5":"2b924c2442739d8ead720fb48e3e0e2d","sha256":"a423163137719148686548decd29dd023d4f284971183049aeef089d13e7068a"},"downloads":-1,"filename":"cs.binary-20180823.tar.gz","has_sig":false,"md5_digest":"2b924c2442739d8ead720fb48e3e0e2d","packagetype":"sdist","python_version":"source","requires_python":null,"size":14126,"upload_time":"2018-08-23T02:19:25","upload_time_iso_8601":"2018-08-23T02:19:25.182849Z","url":"https://files.pythonhosted.org/packages/67/83/181631b6a10945d8f3fb0097df1b04baa213de430f11ff83fdf475cec5e7/cs.binary-20180823.tar.gz","yanked":false,"yanked_reason":null}],"20181108":[{"comment_text":"","digests":{"blake2b_256":"de9c3e95b0cf82d389d117659bd62a0f19831414e960e8ca59ae4439e0e8066d","md5":"7085c1f8b8d3300c3fefd713f1d47b70","sha256":"19391685a31b751e13a5bacfdc5e4c6ff859d5cf5ef0ccea94da4b9c05d200af"},"downloads":-1,"filename":"cs.binary-20181108.tar.gz","has_sig":false,"md5_digest":"7085c1f8b8d3300c3fefd713f1d47b70","packagetype":"sdist","python_version":"source","requires_python":null,"size":14217,"upload_time":"2018-11-08T03:55:01","upload_time_iso_8601":"2018-11-08T03:55:01.128696Z","url":"https://files.pythonhosted.org/packages/de/9c/3e95b0cf82d389d117659bd62a0f19831414e960e8ca59ae4439e0e8066d/cs.binary-20181108.tar.gz","yanked":false,"yanked_reason":null}],"20181231":[{"comment_text":"","digests":{"blake2b_256":"7c7bbf932ba9ebb7742f90be39f5040505698178b383a17a896018ecfe337df3","md5":"1bc62cca3ea3b06d58c0e4c1f6d1aec4","sha256":"f1b150dd903c3ea5fa880f0c421aac876e676122857eda5e1316757dd61d1858"},"downloads":-1,"filename":"cs.binary-20181231.tar.gz","has_sig":false,"md5_digest":"1bc62cca3ea3b06d58c0e4c1f6d1aec4","packagetype":"sdist","python_version":"source","requires_python":null,"size":14230,"upload_time":"2018-12-31T10:13:12","upload_time_iso_8601":"2018-12-31T10:13:12.733923Z","url":"https://files.pythonhosted.org/packages/7c/7b/bf932ba9ebb7742f90be39f5040505698178b383a17a896018ecfe337df3/cs.binary-20181231.tar.gz","yanked":false,"yanked_reason":null}],"20190220":[{"comment_text":"","digests":{"blake2b_256":"bb88d00aa74118c8607e9a36875c785041ec1bf969217b7f81b00c802215f073","md5":"9a7821ece70f07ee8b6daed884ddc696","sha256":"9983df2636babdd2078ccfd590c9580b77f1564a9c813142c013980ac3158889"},"downloads":-1,"filename":"cs.binary-20190220.tar.gz","has_sig":false,"md5_digest":"9a7821ece70f07ee8b6daed884ddc696","packagetype":"sdist","python_version":"source","requires_python":null,"size":15687,"upload_time":"2019-02-20T08:54:21","upload_time_iso_8601":"2019-02-20T08:54:21.774160Z","url":"https://files.pythonhosted.org/packages/bb/88/d00aa74118c8607e9a36875c785041ec1bf969217b7f81b00c802215f073/cs.binary-20190220.tar.gz","yanked":false,"yanked_reason":null}],"20191230":[{"comment_text":"","digests":{"blake2b_256":"848e2d3566df6423245e0a49333ec006fd01b4f497265c0569a17d8bd59c3ee8","md5":"2b59951d24a391fa75a963e062f50c78","sha256":"0d808523478261fbb66ce4d63d9570e391e70d28f74b9ed2ab6c214358d24bb4"},"downloads":-1,"filename":"cs.binary-20191230.tar.gz","has_sig":false,"md5_digest":"2b59951d24a391fa75a963e062f50c78","packagetype":"sdist","python_version":"source","requires_python":null,"size":23520,"upload_time":"2019-12-30T02:22:47","upload_time_iso_8601":"2019-12-30T02:22:47.967575Z","url":"https://files.pythonhosted.org/packages/84/8e/2d3566df6423245e0a49333ec006fd01b4f497265c0569a17d8bd59c3ee8/cs.binary-20191230.tar.gz","yanked":false,"yanked_reason":null}],"20191230.1":[{"comment_text":"","digests":{"blake2b_256":"966a1fd1a5d577f9e141bcb031c284238eda920538b9d8bab6353318a7aea6f7","md5":"fe0a9720993d47f96d06c4fcd8d49dae","sha256":"06226e3fe7aa03733d7aca6f9f0412f5c360b97d61a8275d500b462d530738b9"},"downloads":-1,"filename":"cs.binary-20191230.1.tar.gz","has_sig":false,"md5_digest":"fe0a9720993d47f96d06c4fcd8d49dae","packagetype":"sdist","python_version":"source","requires_python":null,"size":23621,"upload_time":"2019-12-30T02:48:07","upload_time_iso_8601":"2019-12-30T02:48:07.957161Z","url":"https://files.pythonhosted.org/packages/96/6a/1fd1a5d577f9e141bcb031c284238eda920538b9d8bab6353318a7aea6f7/cs.binary-20191230.1.tar.gz","yanked":false,"yanked_reason":null}],"20191230.2":[{"comment_text":"","digests":{"blake2b_256":"514f20703100a5cf11d02097008b281c9d39ae9ca8244a759ec730c77c355a2b","md5":"968869f6c1b22de2e2a76939abb19452","sha256":"fef56abbf6a065ca62d60c24d60765f1fac86334ff44ecc2203c2abbce2466e7"},"downloads":-1,"filename":"cs.binary-20191230.2.tar.gz","has_sig":false,"md5_digest":"968869f6c1b22de2e2a76939abb19452","packagetype":"sdist","python_version":"source","requires_python":null,"size":23883,"upload_time":"2019-12-30T04:18:18","upload_time_iso_8601":"2019-12-30T04:18:18.471415Z","url":"https://files.pythonhosted.org/packages/51/4f/20703100a5cf11d02097008b281c9d39ae9ca8244a759ec730c77c355a2b/cs.binary-20191230.2.tar.gz","yanked":false,"yanked_reason":null}],"20191230.3":[{"comment_text":"","digests":{"blake2b_256":"7ddbefb104b26bffa7e729ab05d8275c50b3a48e9c9456cf9e34c90a2a7dd4dd","md5":"078943b56298d1e63a2f4d751ce358d9","sha256":"c44c4cad674db711bdbb0d0952c7cd1dffbdeb824661b3ffde8780009e979599"},"downloads":-1,"filename":"cs.binary-20191230.3.tar.gz","has_sig":false,"md5_digest":"078943b56298d1e63a2f4d751ce358d9","packagetype":"sdist","python_version":"source","requires_python":null,"size":23910,"upload_time":"2019-12-30T04:21:00","upload_time_iso_8601":"2019-12-30T04:21:00.280662Z","url":"https://files.pythonhosted.org/packages/7d/db/efb104b26bffa7e729ab05d8275c50b3a48e9c9456cf9e34c90a2a7dd4dd/cs.binary-20191230.3.tar.gz","yanked":false,"yanked_reason":null}],"20200229":[{"comment_text":"","digests":{"blake2b_256":"bf1dbd7ed9a41072fa2589a9b07e77133593faac3fd3a24c70845209a3285326","md5":"41653df7a025d7739de4eaf9b97ee80c","sha256":"3af805697f3c308e261056d4c806bb9a86eaafc85568cf4a9ef4f5748c85859d"},"downloads":-1,"filename":"cs.binary-20200229.tar.gz","has_sig":false,"md5_digest":"41653df7a025d7739de4eaf9b97ee80c","packagetype":"sdist","python_version":"source","requires_python":null,"size":25098,"upload_time":"2020-02-29T05:01:02","upload_time_iso_8601":"2020-02-29T05:01:02.625320Z","url":"https://files.pythonhosted.org/packages/bf/1d/bd7ed9a41072fa2589a9b07e77133593faac3fd3a24c70845209a3285326/cs.binary-20200229.tar.gz","yanked":false,"yanked_reason":null}],"20210306":[{"comment_text":"","digests":{"blake2b_256":"fdb28124bc3ebd0996eedd13359692117c08becca8b9e059261f2ea1c263389c","md5":"33aa1814f73f2a390551237584650ce9","sha256":"c6145387d36dec16397d9016c10057ab2b861293e00442ddb342af0b16cf4c74"},"downloads":-1,"filename":"cs.binary-20210306.tar.gz","has_sig":false,"md5_digest":"33aa1814f73f2a390551237584650ce9","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":68944,"upload_time":"2021-03-05T22:51:59","upload_time_iso_8601":"2021-03-05T22:51:59.227963Z","url":"https://files.pythonhosted.org/packages/fd/b2/8124bc3ebd0996eedd13359692117c08becca8b9e059261f2ea1c263389c/cs.binary-20210306.tar.gz","yanked":false,"yanked_reason":null}],"20210316":[{"comment_text":"","digests":{"blake2b_256":"2522cc14853547b49fe27048a84b8357f3d6cf477c983c97772bd30d3fe85976","md5":"5e6608ebcd52606225e64dbb5031ba8d","sha256":"494b361bbc3bce93154ef05e809dc5cb907c29905f042f9e3b382a1217871507"},"downloads":-1,"filename":"cs.binary-20210316.tar.gz","has_sig":false,"md5_digest":"5e6608ebcd52606225e64dbb5031ba8d","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":69843,"upload_time":"2021-03-15T23:17:56","upload_time_iso_8601":"2021-03-15T23:17:56.211469Z","url":"https://files.pythonhosted.org/packages/25/22/cc14853547b49fe27048a84b8357f3d6cf477c983c97772bd30d3fe85976/cs.binary-20210316.tar.gz","yanked":false,"yanked_reason":null}],"20220605":[{"comment_text":"","digests":{"blake2b_256":"e6f97e2aa4f39dcc72254fcb6085a9f7965078cc991e2f2d1e336af8046d27ef","md5":"49bbc53fe0d2ce0a6b318672970376ba","sha256":"ea2135c0536a21894b8261bf6141022a016bc49221f1df91a00a0c79102821ee"},"downloads":-1,"filename":"cs.binary-20220605-py3-none-any.whl","has_sig":false,"md5_digest":"49bbc53fe0d2ce0a6b318672970376ba","packagetype":"bdist_wheel","python_version":"py3","requires_python":null,"size":29853,"upload_time":"2022-06-05T11:19:30","upload_time_iso_8601":"2022-06-05T11:19:30.494773Z","url":"https://files.pythonhosted.org/packages/e6/f9/7e2aa4f39dcc72254fcb6085a9f7965078cc991e2f2d1e336af8046d27ef/cs.binary-20220605-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"e2a4675d09c522bbe769c2a832ad9efacb2ffa2ead79596a9f2ef2fb0eb6f5cb","md5":"d37eba47638b1232a8b5c8abff4ba5ef","sha256":"40c4a39c31dfebbeddb031f6474c6b1ba2109583a95c3576d667ec86472c9c8f"},"downloads":-1,"filename":"cs.binary-20220605.tar.gz","has_sig":false,"md5_digest":"d37eba47638b1232a8b5c8abff4ba5ef","packagetype":"sdist","python_version":"source","requires_python":null,"size":50924,"upload_time":"2022-06-05T11:19:33","upload_time_iso_8601":"2022-06-05T11:19:33.332181Z","url":"https://files.pythonhosted.org/packages/e2/a4/675d09c522bbe769c2a832ad9efacb2ffa2ead79596a9f2ef2fb0eb6f5cb/cs.binary-20220605.tar.gz","yanked":false,"yanked_reason":null}],"20221206":[{"comment_text":"","digests":{"blake2b_256":"f3e51b6eeb20a7d66862c786fe3a2aeb7cd8fd112057b6ac5cef3c703ee2dedc","md5":"9ba44fb413fda533886951d57d1196e3","sha256":"51b1f454bd85eecfc465ca0936782bc2b9fbdd9c3e26bd67f27fcd8e5dc5222c"},"downloads":-1,"filename":"cs.binary-20221206-py3-none-any.whl","has_sig":false,"md5_digest":"9ba44fb413fda533886951d57d1196e3","packagetype":"bdist_wheel","python_version":"py3","requires_python":null,"size":30066,"upload_time":"2022-12-05T23:25:25","upload_time_iso_8601":"2022-12-05T23:25:25.192939Z","url":"https://files.pythonhosted.org/packages/f3/e5/1b6eeb20a7d66862c786fe3a2aeb7cd8fd112057b6ac5cef3c703ee2dedc/cs.binary-20221206-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"495c534fe257fef39bf0ae49e4a00245947235af992e63358cdfb298c86ed8dd","md5":"0aba294fc391912d9e85fb3114080b35","sha256":"22974cea86b157984f9a9529d228ca1223777d639166150126defdd33c8828b1"},"downloads":-1,"filename":"cs.binary-20221206.tar.gz","has_sig":false,"md5_digest":"0aba294fc391912d9e85fb3114080b35","packagetype":"sdist","python_version":"source","requires_python":null,"size":51692,"upload_time":"2022-12-05T23:25:27","upload_time_iso_8601":"2022-12-05T23:25:27.361581Z","url":"https://files.pythonhosted.org/packages/49/5c/534fe257fef39bf0ae49e4a00245947235af992e63358cdfb298c86ed8dd/cs.binary-20221206.tar.gz","yanked":false,"yanked_reason":null}],"20230212":[{"comment_text":"","digests":{"blake2b_256":"6d269e649abf7b6772e6eaf1eca9a432d364491debdd80f41373be9ed8f59194","md5":"8f054fde409bf1f557e659f68d436fcf","sha256":"cea501b696e0c76ce91590d602c486fdcd75169b50ea6b75d32eb0df7d6178c1"},"downloads":-1,"filename":"cs.binary-20230212-py3-none-any.whl","has_sig":false,"md5_digest":"8f054fde409bf1f557e659f68d436fcf","packagetype":"bdist_wheel","python_version":"py3","requires_python":null,"size":30353,"upload_time":"2023-02-12T03:35:52","upload_time_iso_8601":"2023-02-12T03:35:52.042240Z","url":"https://files.pythonhosted.org/packages/6d/26/9e649abf7b6772e6eaf1eca9a432d364491debdd80f41373be9ed8f59194/cs.binary-20230212-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"ec929bbe884116d5160e4c8639cc3cc46be39d9c1e183c103d667295947e057f","md5":"7567f74ee7347bbee460add83ff9d47f","sha256":"f3c1b4f9ab7302fed69cde6a19b61376699c10d45fbdc7520410fb77e2c9de7f"},"downloads":-1,"filename":"cs.binary-20230212.tar.gz","has_sig":false,"md5_digest":"7567f74ee7347bbee460add83ff9d47f","packagetype":"sdist","python_version":"source","requires_python":null,"size":52322,"upload_time":"2023-02-12T03:35:53","upload_time_iso_8601":"2023-02-12T03:35:53.791463Z","url":"https://files.pythonhosted.org/packages/ec/92/9bbe884116d5160e4c8639cc3cc46be39d9c1e183c103d667295947e057f/cs.binary-20230212.tar.gz","yanked":false,"yanked_reason":null}],"20230401":[{"comment_text":"","digests":{"blake2b_256":"a973a2f1752d3e925d1eacf4615bfa20de927045aa3eccc1d03074a8fe550ed9","md5":"c89543d3db950bb6864b78db8728289a","sha256":"409f5f36bafce98eadf818aa693cec5afa7b1fa6e91de5f4d0de050d4f1ae3f1"},"downloads":-1,"filename":"cs.binary-20230401-py3-none-any.whl","has_sig":false,"md5_digest":"c89543d3db950bb6864b78db8728289a","packagetype":"bdist_wheel","python_version":"py3","requires_python":null,"size":30554,"upload_time":"2023-04-01T05:17:43","upload_time_iso_8601":"2023-04-01T05:17:43.714264Z","url":"https://files.pythonhosted.org/packages/a9/73/a2f1752d3e925d1eacf4615bfa20de927045aa3eccc1d03074a8fe550ed9/cs.binary-20230401-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"b78c8c9631e652334327a84c34dc4a70240676e34871cc4791d15e07fb37457f","md5":"625aebb6797274b8feb9474e0147e289","sha256":"6b0f94681b3523df96647b48b0623f501035a4c68eb4198aeaf70654e6d5a00b"},"downloads":-1,"filename":"cs.binary-20230401.tar.gz","has_sig":false,"md5_digest":"625aebb6797274b8feb9474e0147e289","packagetype":"sdist","python_version":"source","requires_python":null,"size":53723,"upload_time":"2023-04-01T05:17:46","upload_time_iso_8601":"2023-04-01T05:17:46.003752Z","url":"https://files.pythonhosted.org/packages/b7/8c/8c9631e652334327a84c34dc4a70240676e34871cc4791d15e07fb37457f/cs.binary-20230401.tar.gz","yanked":false,"yanked_reason":null}],"20231129":[{"comment_text":"","digests":{"blake2b_256":"36402a58b4367e540479305c39d1834ec89cf01ccc248f64824028015fe41d44","md5":"4a2a564ba89592f0f53cbf8dd7f91456","sha256":"b1f7ab2627a4dc8ccb9ee946d3ea7e5abbe9d87db419e5822621e66a625ca521"},"downloads":-1,"filename":"cs.binary-20231129-py3-none-any.whl","has_sig":false,"md5_digest":"4a2a564ba89592f0f53cbf8dd7f91456","packagetype":"bdist_wheel","python_version":"py3","requires_python":null,"size":30586,"upload_time":"2023-11-29T10:35:39","upload_time_iso_8601":"2023-11-29T10:35:39.453666Z","url":"https://files.pythonhosted.org/packages/36/40/2a58b4367e540479305c39d1834ec89cf01ccc248f64824028015fe41d44/cs.binary-20231129-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"2f67398f443bfdff18389c569fc6684ca9e0233d738964735ec0f3fef5d912d5","md5":"444a4304abd48a3341352650f1f7e878","sha256":"3cd53e642f51e1d9ef0d17ae83ac83bf4e07d9567fd36ff58cebfbcf0a5db99f"},"downloads":-1,"filename":"cs.binary-20231129.tar.gz","has_sig":false,"md5_digest":"444a4304abd48a3341352650f1f7e878","packagetype":"sdist","python_version":"source","requires_python":null,"size":54094,"upload_time":"2023-11-29T10:35:42","upload_time_iso_8601":"2023-11-29T10:35:42.566669Z","url":"https://files.pythonhosted.org/packages/2f/67/398f443bfdff18389c569fc6684ca9e0233d738964735ec0f3fef5d912d5/cs.binary-20231129.tar.gz","yanked":false,"yanked_reason":null}],"20240201":[{"comment_text":"","digests":{"blake2b_256":"e10b2a2d62ae9a93c00e4e9184662b1d42e053fa4e9e975b1234a199700641a3","md5":"64e3abadbfa4c450bc69b9c97a0b6f7a","sha256":"c68a0c8de35ce26f680fe15783727db7a51d5efecda370fc846bffc03eeb8b6c"},"downloads":-1,"filename":"cs.binary-20240201-py3-none-any.whl","has_sig":false,"md5_digest":"64e3abadbfa4c450bc69b9c97a0b6f7a","packagetype":"bdist_wheel","python_version":"py3","requires_python":null,"size":21133,"upload_time":"2024-02-01T03:25:11","upload_time_iso_8601":"2024-02-01T03:25:11.333531Z","url":"https://files.pythonhosted.org/packages/e1/0b/2a2d62ae9a93c00e4e9184662b1d42e053fa4e9e975b1234a199700641a3/cs.binary-20240201-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"67a7d07bfd40c02c0678b55151b87a661cbede11215c21c052b400dda97cea95","md5":"b175b8de60c643be7808b03e6f98a394","sha256":"9ceb4513789ed5bf667e09e6303793a0e3d1e6335f1e0e2825e93ebf126a4876"},"downloads":-1,"filename":"cs.binary-20240201.tar.gz","has_sig":false,"md5_digest":"b175b8de60c643be7808b03e6f98a394","packagetype":"sdist","python_version":"source","requires_python":null,"size":32309,"upload_time":"2024-02-01T03:25:13","upload_time_iso_8601":"2024-02-01T03:25:13.347579Z","url":"https://files.pythonhosted.org/packages/67/a7/d07bfd40c02c0678b55151b87a661cbede11215c21c052b400dda97cea95/cs.binary-20240201.tar.gz","yanked":false,"yanked_reason":null}],"20240316":[{"comment_text":"","digests":{"blake2b_256":"753a25a020659bdd74ba99fb2f351c1b5d32aad8defc20f7960c2ecfdb4086af","md5":"6edb7704356d84594577b27f6e9d96c3","sha256":"2aa9fff13a1218a7bca05b16890b9c668062da6e82a6cf1b28ac9d9597293437"},"downloads":-1,"filename":"cs.binary-20240316-py3-none-any.whl","has_sig":false,"md5_digest":"6edb7704356d84594577b27f6e9d96c3","packagetype":"bdist_wheel","python_version":"py3","requires_python":null,"size":21127,"upload_time":"2024-03-16T06:57:20","upload_time_iso_8601":"2024-03-16T06:57:20.501145Z","url":"https://files.pythonhosted.org/packages/75/3a/25a020659bdd74ba99fb2f351c1b5d32aad8defc20f7960c2ecfdb4086af/cs.binary-20240316-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"5000ac8a2c2e7ad56f39fb62c5f6906f6c0ff957cdf1d5cc82de44e1a6fb3468","md5":"40a5dd38399d2537ca740883183d6b2f","sha256":"1db896ae46075a9373f87ceaaffadfb11e99145fa0ddc1968e80c9eb27483bd6"},"downloads":-1,"filename":"cs.binary-20240316.tar.gz","has_sig":false,"md5_digest":"40a5dd38399d2537ca740883183d6b2f","packagetype":"sdist","python_version":"source","requires_python":null,"size":31208,"upload_time":"2024-03-16T06:57:22","upload_time_iso_8601":"2024-03-16T06:57:22.918791Z","url":"https://files.pythonhosted.org/packages/50/00/ac8a2c2e7ad56f39fb62c5f6906f6c0ff957cdf1d5cc82de44e1a6fb3468/cs.binary-20240316.tar.gz","yanked":false,"yanked_reason":null}],"20240422":[{"comment_text":"","digests":{"blake2b_256":"531c8f7643db3576b3d54f468af7f3bd38a159683b63bb19ad07a9cc9aa3acc4","md5":"968a07ea7fec9acdfb88d661a43843ac","sha256":"efd0a9be8cf95cb07695b6c526774464f0188b0af146b40ecb1e84f92fc97607"},"downloads":-1,"filename":"cs.binary-20240422-py3-none-any.whl","has_sig":false,"md5_digest":"968a07ea7fec9acdfb88d661a43843ac","packagetype":"bdist_wheel","python_version":"py3","requires_python":null,"size":24312,"upload_time":"2024-04-22T06:31:03","upload_time_iso_8601":"2024-04-22T06:31:03.018582Z","url":"https://files.pythonhosted.org/packages/53/1c/8f7643db3576b3d54f468af7f3bd38a159683b63bb19ad07a9cc9aa3acc4/cs.binary-20240422-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"6564ca2a6141c5a6ed53bcaadbb7c0a7b02643017b4d4386e5d9e5e121f35db3","md5":"9aff0d54def1ebf735b024afe3001e3f","sha256":"e152907a487bba28feca58144ab6641032f46b79aac95aac5a5b49bb9a5bd95a"},"downloads":-1,"filename":"cs.binary-20240422.tar.gz","has_sig":false,"md5_digest":"9aff0d54def1ebf735b024afe3001e3f","packagetype":"sdist","python_version":"source","requires_python":null,"size":48522,"upload_time":"2024-04-22T06:31:05","upload_time_iso_8601":"2024-04-22T06:31:05.860511Z","url":"https://files.pythonhosted.org/packages/65/64/ca2a6141c5a6ed53bcaadbb7c0a7b02643017b4d4386e5d9e5e121f35db3/cs.binary-20240422.tar.gz","yanked":false,"yanked_reason":null}],"20240630":[{"comment_text":"","digests":{"blake2b_256":"3edf4d3ae19a8052abad0b3952d162e5dceb2fd7a42f3a849b0a759bb4ab1d13","md5":"1437bc37ba5f0794b95267da93868c0b","sha256":"10fa61a19238470f1e87cc0fe040ea91a1c7d6b9532ee6ce8c4f694ecb553ff5"},"downloads":-1,"filename":"cs.binary-20240630-py3-none-any.whl","has_sig":false,"md5_digest":"1437bc37ba5f0794b95267da93868c0b","packagetype":"bdist_wheel","python_version":"py3","requires_python":null,"size":25206,"upload_time":"2024-06-30T01:56:31","upload_time_iso_8601":"2024-06-30T01:56:31.741888Z","url":"https://files.pythonhosted.org/packages/3e/df/4d3ae19a8052abad0b3952d162e5dceb2fd7a42f3a849b0a759bb4ab1d13/cs.binary-20240630-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"fa87a4a70c9701645ea381d24467fe3bfa57eab699ecc8f930a66ae1c8ab90a8","md5":"996ca66a3e181241eee655389bfcbde6","sha256":"6ff5b0ea7564ffa0b3a104164d0b54c849661c9631c44af5b46efda6a12f1f82"},"downloads":-1,"filename":"cs.binary-20240630.tar.gz","has_sig":false,"md5_digest":"996ca66a3e181241eee655389bfcbde6","packagetype":"sdist","python_version":"source","requires_python":null,"size":50417,"upload_time":"2024-06-30T01:56:34","upload_time_iso_8601":"2024-06-30T01:56:34.519900Z","url":"https://files.pythonhosted.org/packages/fa/87/a4a70c9701645ea381d24467fe3bfa57eab699ecc8f930a66ae1c8ab90a8/cs.binary-20240630.tar.gz","yanked":false,"yanked_reason":null}]},"urls":[{"comment_text":"","digests":{"blake2b_256":"3edf4d3ae19a8052abad0b3952d162e5dceb2fd7a42f3a849b0a759bb4ab1d13","md5":"1437bc37ba5f0794b95267da93868c0b","sha256":"10fa61a19238470f1e87cc0fe040ea91a1c7d6b9532ee6ce8c4f694ecb553ff5"},"downloads":-1,"filename":"cs.binary-20240630-py3-none-any.whl","has_sig":false,"md5_digest":"1437bc37ba5f0794b95267da93868c0b","packagetype":"bdist_wheel","python_version":"py3","requires_python":null,"size":25206,"upload_time":"2024-06-30T01:56:31","upload_time_iso_8601":"2024-06-30T01:56:31.741888Z","url":"https://files.pythonhosted.org/packages/3e/df/4d3ae19a8052abad0b3952d162e5dceb2fd7a42f3a849b0a759bb4ab1d13/cs.binary-20240630-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"fa87a4a70c9701645ea381d24467fe3bfa57eab699ecc8f930a66ae1c8ab90a8","md5":"996ca66a3e181241eee655389bfcbde6","sha256":"6ff5b0ea7564ffa0b3a104164d0b54c849661c9631c44af5b46efda6a12f1f82"},"downloads":-1,"filename":"cs.binary-20240630.tar.gz","has_sig":false,"md5_digest":"996ca66a3e181241eee655389bfcbde6","packagetype":"sdist","python_version":"source","requires_python":null,"size":50417,"upload_time":"2024-06-30T01:56:34","upload_time_iso_8601":"2024-06-30T01:56:34.519900Z","url":"https://files.pythonhosted.org/packages/fa/87/a4a70c9701645ea381d24467fe3bfa57eab699ecc8f930a66ae1c8ab90a8/cs.binary-20240630.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[]}
