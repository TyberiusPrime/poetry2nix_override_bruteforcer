{"info":{"author":"tintinweb","author_email":"tintinweb@oststrom.com","bugtrack_url":null,"classifiers":[],"description":"# ethereum-dasm \nethereum evm bytecode disassembler with static- and dynamic-analysis and function signature lookup\n\n[https://github.com/ethereum/] [https://www.ethereum.org/]\n\n![windows](https://user-images.githubusercontent.com/2865694/42905736-28e71672-8ad9-11e8-9a2d-baa6f4260dbc.png)\n\n**disassembles evm bytecode**\n\n[![asciicast](https://asciinema.org/a/256036.png)](https://asciinema.org/a/256036)\n\n**decompile a contract to pseudocode**\n\n[![asciicast](https://asciinema.org/a/0xJvR55Zr7svqibS0oLHA2vY5.png)](https://asciinema.org/a/0xJvR55Zr7svqibS0oLHA2vY5)\n\n\n## install\n\n```\n#> python3 -m pip install -r requirements*.txt\n#> python3 -m pip install ethereum-dasm[mythril,abidecoder]\n#> python3 -m ethereum-dasm  # verify installation\n```\n\n```\n#> python3 -m ethereum_dasm -a 0x44919b8026f38d70437a8eb3be47b06ab1c3e4bf  # jusst to verify installation\n```\n\n## usage\n\n```\nUsage: ethereum_dasm.py [options]\n\n       example: ethereum_dasm.py [-L -F -v] <file_or_bytecode>\n                ethereum_dasm.py [-L -F -v] # read from stdin\n                ethereum_dasm.py [-L -F -a <address>] # fetch contract code from infura.io\n\n\nOptions:\n  -h, --help            show this help message and exit\n  -v VERBOSITY, --verbosity=VERBOSITY\n                        available loglevels:\n                        critical,fatal,error,warning,warn,info,debug,notset\n                        [default: critical]\n  -L, --listing         disables table mode, outputs assembly only\n  -F, --no-online-lookup\n                        disable online function signature lookup\n  -a ADDRESS, --address=ADDRESS\n                        fetch contract bytecode from address\n  -C, --no-color        disable color mode (requires pip install colorama)\n  -A, --guess-abi       guess the ABI for that contract\n  -D, --no-dynamic-analysis\n                        disable dynamic analysis / symolic execution\n  -S, --no-static-analysis\n                        disable static analysis\n  -s, --simplify        simplify disassembly to human readable code\n  -x, --simplify-show-asm\n                        simplify: show or hide asm annotations in simplified\n                        code\n  -y, --simplify-show-unreachable\n                        simplify: show or hide annotations for unreachable\n                        instructions in simplified code\n  -n NETWORK, --network=NETWORK\n                        network for address lookup (default: mainnet, ropsten,\n                        rinkeby, kovan\n```\n\n    #> echo \"0x12345678\" | python3 -m ethereum_dasm\n    #> python3 -m ethereum_dasm 0x12345678\n    #> python3 -m ethereum_dasm ether_contract.evm\n    #> python3 -m ethereum_dasm -a <contract address>\n    #> python3 -m ethereum_dasm -a <contract address>  -A\n    #> python3 -m ethereum_dasm -a <contract address>  --simplify [--simplify-show-asm, --simplify-show-unreachable]\n\n## features\n\n* disassemble evm bytecode\n* decompile evm bytecode to pseudocode\n* provide the path to the ethereum vm bytecode or the bytecode as an argument to evmdasm. Tries to read from stdin by default.\n* returns !=0 on errors\n* various output modes (`-L` to switch from table to listing mode)\n* color-mode\n* invalid opcodes are prefixed with `UNKNOWN_`\n* gas consumption for instruction\n* return value and arguments for instruction\n* basic jump/xref analysis\n* basicblocking\n* online function signature and method name lookup, operand annotations\n* payable modifier detection\n* dynamic analysis based on symbolic execution (depends on mythril)\n* ABI.json download (from etherchain.org)\n* ABI.json reconstruction from static analysis of the evm bytecode\n* main interface `Contract()`.\n\n## examples\n\n**abi online lookup or reconstruction**\n```#>python3 -m ethereum_dasm -a 0x44919b8026f38d70437a8eb3be47b06ab1c3e4bf  -A```\n```python\n# [....]\n[{'stateMutability': 'nonpayable', 'constant': False, 'type': 'function', 'name': 'enter', 'signature': '0x124c32a1', 'outputs': [{'type': 'bool', 'name': ''}], 'inputs': [{'type': 'bytes32', 'name': '_passcode'\n}, {'type': 'bytes8', 'name': '_gateKey'}], 'payable': False}, {'stateMutability': 'pure', 'constant': True, 'type': 'function', 'name': 'maxEntrants', 'signature': '0x60643652', 'outputs': [{'type': 'uint8', 'n\name': ''}], 'inputs': [], 'payable': False}, {'stateMutability': 'view', 'constant': True, 'type': 'function', 'name': 'totalEntrants', 'signature': '0x694463a2', 'outputs': [{'type': 'uint8', 'name': ''}], 'inp\nuts': [], 'payable': False}, {'stateMutability': 'nonpayable', 'constant': False, 'type': 'function', 'name': 'assignAll', 'signature': '0x90ae631d', 'outputs': [{'type': 'bool', 'name': ''}], 'inputs': [], 'pay\nable': False}, {'inputs': [], 'stateMutability': 'nonpayable', 'payable': False, 'type': 'constructor'}]\n```\n\n**abi reconstruction from dasm if abi is not available**\n`#> python3 -m ethereum_dasm -a 0x8f8bed23a644f3bbb4e227e28704c050e67c35be -A`\n```\n[{'signature': '0x95d89b41', 'outputs': [], 'stateMutability': None, 'name': 'symbol', 'constant': None, 'inputs': [], 'payable': True, 'type': 'function', 'address': 598}, {'signature': '0x095ea7b3', 'outputs':\n [], 'stateMutability': None, 'name': 'approve', 'constant': None, 'inputs': ['bytes32', '<bytes??>'], 'payable': True, 'type': 'function', 'address': 328}, {'signature': '0x313ce567', 'outputs': [], 'stateMutab\nility': None, 'name': 'decimals', 'constant': None, 'inputs': [], 'payable': True, 'type': 'function', 'address': 486}, {'signature': '0xdd62ed3e', 'outputs': [], 'stateMutability': None, 'name': 'allowance', 'c\nonstant': None, 'inputs': ['bytes32', '<bytes??>'], 'payable': True, 'type': 'function', 'address': 691}, {'signature': '0x66188463', 'outputs': [], 'stateMutability': None, 'name': 'decreaseApproval', 'constant\n': None, 'inputs': ['bytes32', '<bytes??>'], 'payable': True, 'type': 'function', 'address': 529}, {'signature': '0x23b872dd', 'outputs': [], 'stateMutability': None, 'name': 'transferFrom', 'constant': None, 'i\nnputs': ['bytes32', 'bytes32', '<bytes??>'], 'payable': True, 'type': 'function', 'address': 423}, {'signature': '0x2ff2e9dc', 'outputs': [], 'stateMutability': None, 'name': 'INITIAL_SUPPLY', 'constant': None,\n'inputs': [], 'payable': True, 'type': 'function', 'address': 465}, {'signature': '0x06fdde03', 'outputs': [], 'stateMutability': None, 'name': 'name', 'constant': None, 'inputs': [], 'payable': True, 'type': 'f\nunction', 'address': 190}, {'signature': '0x18160ddd', 'outputs': [], 'stateMutability': None, 'name': 'totalSupply', 'constant': None, 'inputs': [], 'payable': True, 'type': 'function', 'address': 384}, {'signa\nture': '0x70a08231', 'outputs': [], 'stateMutability': None, 'name': 'balanceOf', 'constant': None, 'inputs': ['<bytes??>'], 'payable': True, 'type': 'function', 'address': 565}, {'signature': '0xa9059cbb', 'out\nputs': [], 'stateMutability': None, 'name': 'transfer', 'constant': None, 'inputs': [{'type': 'address', 'name': 'arg0'}, {'type': 'uint256', 'name': 'arg1'}], 'payable': True, 'type': 'function', 'address': 619\n}, {'signature': '0xd73dd623', 'outputs': [], 'stateMutability': None, 'name': 'increaseApproval', 'constant': None, 'inputs': ['bytes32', '<bytes??>'], 'payable': True, 'type': 'function', 'address': 655}]\n```\n\n\n**detailed listing**\n\n```python3 -m ethereum_dasm -a 0x44919b8026f38d70437a8eb3be47b06ab1c3e4bf  -A --no-color ```\n```python\n  Inst   addr  hex    gas | mnemonic        operand                                               xrefs        description                                                           retval           args\n------------------------------------------------------------------------------------------------  -----------  --------------------------------------------------------------------  ---------------  --------------------\n:loc_0x0\n     0 [   0 0x0000 ]   3 | PUSH1           0x60                                                               # Place 1 byte item on stack.                                         item\n     1 [   2 0x0002 ]   3 | PUSH1           0x40                                                               # Place 1 byte item on stack.                                         item\n     2 [   4 0x0004 ]   3 | MSTORE                                                                             # Save word to memory.                                                                 value, offset\n     3 [   5 0x0005 ]   3 | PUSH1           0x04                                                               # Place 1 byte item on stack.                                         item\n     4 [   7 0x0007 ]   2 | CALLDATASIZE                                                                       # Get size of input data in current environment.                      msg.data.length\n     5 [   8 0x0008 ]   3 | LT                                                                                 # Lesser-than comparison                                              flag             a, b\n     6 [   9 0x0009 ]   3 | PUSH2           0x0048                                                             # Place 2-byte item on stack.                                         item\n     7 [  12 0x000c ]  10 | JUMPI           @0x48                                                              # Conditionally alter the program counter.                                             evm.pc, condition\n     8 [  13 0x000d ]   3 | PUSH4           0xffffffff                                                         # Place 4-byte item on stack.                                         item\n     9 [  18 0x0012 ]   3 | PUSH1           0xe0                                                               # Place 1 byte item on stack.                                         item\n    10 [  20 0x0014 ]   3 | PUSH1           0x02                                                               # Place 1 byte item on stack.                                         item\n    11 [  22 0x0016 ]  10 | EXP                                                                                # Exponential operation.                                              result           base, exponent\n    12 [  23 0x0017 ]   3 | PUSH1           0x00                                                               # Place 1 byte item on stack.                                         item\n    13 [  25 0x0019 ]   3 | CALLDATALOAD                                                                       # Get input data of current environment.                              msg.data         unknown\n    14 [  26 0x001a ]   5 | DIV                                                                                # Integer division operation.                                         result           a, b\n    15 [  27 0x001b ]   3 | AND                                                                                # Bitwise AND operation.                                              result           a, b\n    16 [  28 0x001c ]   3 | PUSH4           0x124c32a1  --> 'function enter(bytes32,bytes8)'                   # Place 4-byte item on stack.                                         item\n    17 [  33 0x0021 ]   3 | DUP2                                                                               # Duplicate 2nd stack item.\n    18 [  34 0x0022 ]   3 | EQ                                                                                 # Equality  comparison                                                flag             a, b\n    19 [  35 0x0023 ]   3 | PUSH2           0x004d                                                             # Place 2-byte item on stack.                                         item\n    20 [  38 0x0026 ]  10 | JUMPI           @0x4d                                                              # Conditionally alter the program counter.                                             evm.pc, condition\n    21 [  39 0x0027 ]   3 | DUP1                                                                               # Duplicate 1st stack item.\n    22 [  40 0x0028 ]   3 | PUSH4           0x60643652  --> 'function maxEntrants()'                           # Place 4-byte item on stack.                                         item\n    23 [  45 0x002d ]   3 | EQ                                                                                 # Equality  comparison                                                flag             a, b\n    24 [  46 0x002e ]   3 | PUSH2           0x0095                                                             # Place 2-byte item on stack.                                         item\n    25 [  49 0x0031 ]  10 | JUMPI           @0x95                                                              # Conditionally alter the program counter.                                             evm.pc, condition\n    26 [  50 0x0032 ]   3 | DUP1                                                                               # Duplicate 1st stack item.\n    27 [  51 0x0033 ]   3 | PUSH4           0x694463a2  --> 'function totalEntrants()'                         # Place 4-byte item on stack.                                         item\n    28 [  56 0x0038 ]   3 | EQ                                                                                 # Equality  comparison                                                flag             a, b\n    29 [  57 0x0039 ]   3 | PUSH2           0x00be                                                             # Place 2-byte item on stack.                                         item\n    30 [  60 0x003c ]  10 | JUMPI           @0xbe                                                              # Conditionally alter the program counter.                                             evm.pc, condition\n    31 [  61 0x003d ]   3 | DUP1                                                                               # Duplicate 1st stack item.\n    32 [  62 0x003e ]   3 | PUSH4           0x90ae631d  --> 'function assignAll()'                             # Place 4-byte item on stack.                                         item\n    33 [  67 0x0043 ]   3 | EQ                                                                                 # Equality  comparison                                                flag             a, b\n    34 [  68 0x0044 ]   3 | PUSH2           0x00d1                                                             # Place 2-byte item on stack.                                         item\n    35 [  71 0x0047 ]  10 | JUMPI           @0xd1                                                              # Conditionally alter the program counter.                                             evm.pc, condition\n\n:loc_0x48\n    36 [  72 0x0048 ]   1 | JUMPDEST                                                              JUMPI@0xc    # Mark a valid destination for jumps.\n    37 [  73 0x0049 ]   3 | PUSH1           0x00                                                               # Place 1 byte item on stack.                                         item\n    38 [  75 0x004b ]   3 | DUP1                                                                               # Duplicate 1st stack item.\n    39 [  76 0x004c ]   0 | REVERT                                                                             # throw an error                                                                       offset, size\n:loc_0x4d\n  /*******************************************************************\n    function enter(bytes32,bytes8)\n    payable: False\n    inputs: (2) ['bytes32', '<bytes??>']\n    potential signatures: ['enter(bytes32,bytes8)']\n  *******************************************************************/\n    40 [  77 0x004d ]   1 | JUMPDEST                                                              JUMPI@0x26   # Mark a valid destination for jumps.\n    41 [  78 0x004e ]   2 | CALLVALUE                                                                          # Get deposited value by the instruction/transaction responsible for  msg.value\n                                                                                                                 this execution.\n    42 [  79 0x004f ]   3 | ISZERO                                                                             # Simple not operator                                                 flag             a\n    43 [  80 0x0050 ]   3 | PUSH2           0x0058                                                             # Place 2-byte item on stack.                                         item\n    44 [  83 0x0053 ]  10 | JUMPI           @0x58                                                              # Conditionally alter the program counter.                                             evm.pc, condition\n    45 [  84 0x0054 ]   3 | PUSH1           0x00                                                               # Place 1 byte item on stack.                                         item\n    46 [  86 0x0056 ]   3 | DUP1                                                                               # Duplicate 1st stack item.\n    47 [  87 0x0057 ]   0 | REVERT                                                                             # throw an error                                                                       offset, size\n:loc_0x58\n    48 [  88 0x0058 ]   1 | JUMPDEST                                                              JUMPI@0x53   # Mark a valid destination for jumps.\n    49 [  89 0x0059 ]   3 | PUSH2           0x0081                                                             # Place 2-byte item on stack.                                         item\n    50 [  92 0x005c ]   3 | PUSH1           0x04                                                               # Place 1 byte item on stack.                                         item\n    51 [  94 0x005e ]   3 | CALLDATALOAD                                                                       # Get input data of current environment.                              msg.data         unknown\n    52 [  95 0x005f ]   3 | PUSH24          0xffffffffffffffffffffffffffffffffffffffffffffffff                 # Place 24-byte item on stack.                                        item\n    53 [ 120 0x0078 ]   3 | NOT                                                                                # Bitwise NOT operation.                                              result           a, b\n    54 [ 121 0x0079 ]   3 | PUSH1           0x24                                                               # Place 1 byte item on stack.                                         item\n    55 [ 123 0x007b ]   3 | CALLDATALOAD                                                                       # Get input data of current environment.                              msg.data         unknown\n    56 [ 124 0x007c ]   3 | AND                                                                                # Bitwise AND operation.                                              result           a, b\n    57 [ 125 0x007d ]   3 | PUSH2           0x00e4                                                             # Place 2-byte item on stack.                                         item\n    58 [ 128 0x0080 ]   8 | JUMP            @0xe4                                                              # Alter the program counter.                                                           evm.pc\n\n:loc_0x81\n    59 [ 129 0x0081 ]   1 | JUMPDEST                                                                           # Mark a valid destination for jumps.\n    60 [ 130 0x0082 ]   3 | PUSH1           0x40                                                               # Place 1 byte item on stack.                                         item\n    61 [ 132 0x0084 ]   3 | MLOAD                                                                              # Load word from memory.                                                               offset\n    62 [ 133 0x0085 ]   3 | SWAP1                                                                              # Exchange 1st and 2nd stack items.\n    63 [ 134 0x0086 ]   3 | ISZERO                                                                             # Simple not operator                                                 flag             a\n    64 [ 135 0x0087 ]   3 | ISZERO                                                                             # Simple not operator                                                 flag             a\n    65 [ 136 0x0088 ]   3 | DUP2                                                                               # Duplicate 2nd stack item.\n    66 [ 137 0x0089 ]   3 | MSTORE                                                                             # Save word to memory.                                                                 value, offset\n    67 [ 138 0x008a ]   3 | PUSH1           0x20                                                               # Place 1 byte item on stack.                                         item\n    68 [ 140 0x008c ]   3 | ADD                                                                                # Addition operation.                                                 result           a, b\n    69 [ 141 0x008d ]   3 | PUSH1           0x40                                                               # Place 1 byte item on stack.                                         item\n    70 [ 143 0x008f ]   3 | MLOAD                                                                              # Load word from memory.                                                               offset\n    71 [ 144 0x0090 ]   3 | DUP1                                                                               # Duplicate 1st stack item.\n    72 [ 145 0x0091 ]   3 | SWAP2                                                                              # Exchange 1st and 3rd stack items.\n    73 [ 146 0x0092 ]   3 | SUB                                                                                # Subtraction operation.                                              result           a, b\n    74 [ 147 0x0093 ]   3 | SWAP1                                                                              # Exchange 1st and 2nd stack items.\n    75 [ 148 0x0094 ]   0 | RETURN                                                                             # Halt execution returning output data.                                                offset, size\n\n:loc_0x95\n  /*******************************************************************\n    function maxEntrants()\n    payable: False\n    inputs: (0) []\n    potential signatures: ['maxEntrants()']\n  *******************************************************************/\n    76 [ 149 0x0095 ]   1 | JUMPDEST                                                              JUMPI@0x31   # Mark a valid destination for jumps.\n    77 [ 150 0x0096 ]   2 | CALLVALUE                                                                          # Get deposited value by the instruction/transaction responsible for  msg.value\n                                                                                                                 this execution.\n    78 [ 151 0x0097 ]   3 | ISZERO                                                                             # Simple not operator                                                 flag             a\n    79 [ 152 0x0098 ]   3 | PUSH2           0x00a0                                                             # Place 2-byte item on stack.                                         item\n    80 [ 155 0x009b ]  10 | JUMPI           @0xa0                                                              # Conditionally alter the program counter.                                             evm.pc, condition\n    81 [ 156 0x009c ]   3 | PUSH1           0x00                                                               # Place 1 byte item on stack.                                         item\n    82 [ 158 0x009e ]   3 | DUP1                                                                               # Duplicate 1st stack item.\n    83 [ 159 0x009f ]   0 | REVERT                                                                             # throw an error                                                                       offset, size\n:loc_0xa0\n    84 [ 160 0x00a0 ]   1 | JUMPDEST                                                              JUMPI@0x9b   # Mark a valid destination for jumps.\n    85 [ 161 0x00a1 ]   3 | PUSH2           0x00a8                                                             # Place 2-byte item on stack.                                         item\n    86 [ 164 0x00a4 ]   3 | PUSH2           0x0314                                                             # Place 2-byte item on stack.                                         item\n    87 [ 167 0x00a7 ]   8 | JUMP            @0x314                                                             # Alter the program counter.                                                           evm.pc\n\n:loc_0xa8\n    88 [ 168 0x00a8 ]   1 | JUMPDEST                                                                           # Mark a valid destination for jumps.\n    89 [ 169 0x00a9 ]   3 | PUSH1           0x40                                                               # Place 1 byte item on stack.                                         item\n    90 [ 171 0x00ab ]   3 | MLOAD                                                                              # Load word from memory.                                                               offset\n    91 [ 172 0x00ac ]   3 | PUSH1           0xff                                                               # Place 1 byte item on stack.                                         item\n    92 [ 174 0x00ae ]   3 | SWAP1                                                                              # Exchange 1st and 2nd stack items.\n    93 [ 175 0x00af ]   3 | SWAP2                                                                              # Exchange 1st and 3rd stack items.\n    94 [ 176 0x00b0 ]   3 | AND                                                                                # Bitwise AND operation.                                              result           a, b\n    95 [ 177 0x00b1 ]   3 | DUP2                                                                               # Duplicate 2nd stack item.\n    96 [ 178 0x00b2 ]   3 | MSTORE                                                                             # Save word to memory.                                                                 value, offset\n    97 [ 179 0x00b3 ]   3 | PUSH1           0x20                                                               # Place 1 byte item on stack.                                         item\n    98 [ 181 0x00b5 ]   3 | ADD                                                                                # Addition operation.                                                 result           a, b\n    99 [ 182 0x00b6 ]   3 | PUSH1           0x40                                                               # Place 1 byte item on stack.                                         item\n   100 [ 184 0x00b8 ]   3 | MLOAD                                                                              # Load word from memory.                                                               offset\n   101 [ 185 0x00b9 ]   3 | DUP1                                                                               # Duplicate 1st stack item.\n   102 [ 186 0x00ba ]   3 | SWAP2                                                                              # Exchange 1st and 3rd stack items.\n   103 [ 187 0x00bb ]   3 | SUB                                                                                # Subtraction operation.                                              result           a, b\n   104 [ 188 0x00bc ]   3 | SWAP1                                                                              # Exchange 1st and 2nd stack items.\n   105 [ 189 0x00bd ]   0 | RETURN                                                                             # Halt execution returning output data.                                                offset, size\n\n:loc_0xbe\n  /*******************************************************************\n    function totalEntrants()\n    payable: False\n    inputs: (0) []\n    potential signatures: ['totalEntrants()']\n  *******************************************************************/\n   106 [ 190 0x00be ]   1 | JUMPDEST                                                              JUMPI@0x3c   # Mark a valid destination for jumps.\n   107 [ 191 0x00bf ]   2 | CALLVALUE                                                                          # Get deposited value by the instruction/transaction responsible for  msg.value\n                                                                                                                 this execution.\n   108 [ 192 0x00c0 ]   3 | ISZERO                                                                             # Simple not operator                                                 flag             a\n   109 [ 193 0x00c1 ]   3 | PUSH2           0x00c9                                                             # Place 2-byte item on stack.                                         item\n   110 [ 196 0x00c4 ]  10 | JUMPI           @0xc9                                                              # Conditionally alter the program counter.                                             evm.pc, condition\n   111 [ 197 0x00c5 ]   3 | PUSH1           0x00                                                               # Place 1 byte item on stack.                                         item\n   112 [ 199 0x00c7 ]   3 | DUP1                                                                               # Duplicate 1st stack item.\n   113 [ 200 0x00c8 ]   0 | REVERT                                                                             # throw an error                                                                       offset, size\n:loc_0xc9\n   114 [ 201 0x00c9 ]   1 | JUMPDEST                                                              JUMPI@0xc4   # Mark a valid destination for jumps.\n   115 [ 202 0x00ca ]   3 | PUSH2           0x00a8                                                             # Place 2-byte item on stack.                                         item\n   116 [ 205 0x00cd ]   3 | PUSH2           0x031a                                                             # Place 2-byte item on stack.                                         item\n   117 [ 208 0x00d0 ]   8 | JUMP            @0x31a                                                             # Alter the program counter.                                                           evm.pc\n\n:loc_0xd1\n  /*******************************************************************\n    function assignAll()\n    payable: False\n    inputs: (0) []\n    potential signatures: ['assignAll()']\n  *******************************************************************/\n   118 [ 209 0x00d1 ]   1 | JUMPDEST                                                              JUMPI@0x47   # Mark a valid destination for jumps.\n   119 [ 210 0x00d2 ]   2 | CALLVALUE                                                                          # Get deposited value by the instruction/transaction responsible for  msg.value\n                                                                                                                 this execution.\n   120 [ 211 0x00d3 ]   3 | ISZERO                                                                             # Simple not operator                                                 flag             a\n   121 [ 212 0x00d4 ]   3 | PUSH2           0x00dc                                                             # Place 2-byte item on stack.                                         item\n   122 [ 215 0x00d7 ]  10 | JUMPI           @0xdc                                                              # Conditionally alter the program counter.                                             evm.pc, condition\n   123 [ 216 0x00d8 ]   3 | PUSH1           0x00                                                               # Place 1 byte item on stack.                                         item\n   124 [ 218 0x00da ]   3 | DUP1                                                                               # Duplicate 1st stack item.\n   125 [ 219 0x00db ]   0 | REVERT                                                                             # throw an error                                                                       offset, size\n:loc_0xdc\n   126 [ 220 0x00dc ]   1 | JUMPDEST                                                              JUMPI@0xd7   # Mark a valid destination for jumps.\n   127 [ 221 0x00dd ]   3 | PUSH2           0x0081                                                             # Place 2-byte item on stack.                                         item\n   128 [ 224 0x00e0 ]   3 | PUSH2           0x0320                                                             # Place 2-byte item on stack.                                         item\n   129 [ 227 0x00e3 ]   8 | JUMP            @0x320                                                             # Alter the program counter.                                                           evm.pc\n\n:loc_0xe4\n   130 [ 228 0x00e4 ]   1 | JUMPDEST                                                              JUMP@0x80    # Mark a valid destination for jumps.\n   131 [ 229 0x00e5 ]   3 | PUSH1           0x00                                                               # Place 1 byte item on stack.                                         item\n   132 [ 231 0x00e7 ]   2 | ORIGIN                                                                             # Get execution origination address.                                  tx.origin\n   133 [ 232 0x00e8 ]   3 | PUSH1           0x01                                                               # Place 1 byte item on stack.                                         item\n   134 [ 234 0x00ea ]   3 | PUSH1           0xa0                                                               # Place 1 byte item on stack.                                         item\n   135 [ 236 0x00ec ]   3 | PUSH1           0x02                                                               # Place 1 byte item on stack.                                         item\n   136 [ 238 0x00ee ]  10 | EXP                                                                                # Exponential operation.                                              result           base, exponent\n   137 [ 239 0x00ef ]   3 | SUB                                                                                # Subtraction operation.                                              result           a, b\n   138 [ 240 0x00f0 ]   3 | AND                                                                                # Bitwise AND operation.                                              result           a, b\n   139 [ 241 0x00f1 ]   2 | CALLER                                                                             # Get caller address.This is the address of the account that is       msg.sender\n                                                                                                                 directly responsible for this execution.\n   140 [ 242 0x00f2 ]   3 | PUSH1           0x01                                                               # Place 1 byte item on stack.                                         item\n   141 [ 244 0x00f4 ]   3 | PUSH1           0xa0                                                               # Place 1 byte item on stack.                                         item\n   142 [ 246 0x00f6 ]   3 | PUSH1           0x02                                                               # Place 1 byte item on stack.                                         item\n   143 [ 248 0x00f8 ]  10 | EXP                                                                                # Exponential operation.                                              result           base, exponent\n   144 [ 249 0x00f9 ]   3 | SUB                                                                                # Subtraction operation.                                              result           a, b\n   145 [ 250 0x00fa ]   3 | AND                                                                                # Bitwise AND operation.                                              result           a, b\n   146 [ 251 0x00fb ]   3 | EQ                                                                                 # Equality  comparison                                                flag             a, b\n   147 [ 252 0x00fc ]   3 | ISZERO                                                                             # Simple not operator                                                 flag             a\n   148 [ 253 0x00fd ]   3 | ISZERO                                                                             # Simple not operator                                                 flag             a\n   149 [ 254 0x00fe ]   3 | ISZERO                                                                             # Simple not operator                                                 flag             a\n   150 [ 255 0x00ff ]   3 | PUSH2           0x0107                                                             # Place 2-byte item on stack.                                         item\n   151 [ 258 0x0102 ]  10 | JUMPI           @0x107                                                             # Conditionally alter the program counter.                                             evm.pc, condition\n   152 [ 259 0x0103 ]   3 | PUSH1           0x00                                                               # Place 1 byte item on stack.                                         item\n   153 [ 261 0x0105 ]   3 | DUP1                                                                               # Duplicate 1st stack item.\n   154 [ 262 0x0106 ]   0 | REVERT                                                                             # throw an error                                                                       offset, size\n\n[...]\n\n:loc_0x5d5\n   954 [1493 0x05d5 ]   1 | JUMPDEST                                                              JUMPI@0x5c9  # Mark a valid destination for jumps.\n   955 [1494 0x05d6 ]   2 | POP                                                                                # Remove item from stack.                                                              #dummy\n   956 [1495 0x05d7 ]   3 | SWAP1                                                                              # Exchange 1st and 2nd stack items.\n   957 [1496 0x05d8 ]   8 | JUMP                                                                               # Alter the program counter.                                                           evm.pc\n   958 [1497 0x05d9 ]   0 | STOP                                                                               # Halts execution.\n   959 [1498 0x05da ] 750 | LOG1            0x65                                                               # Append log record with one topic.                                                    start, size, topic1\n   960 [1500 0x05dc ]   3 | PUSH3           0x7a7a72                                                           # Place 3-byte item on stack.                                         item\n   961 [1504 0x05e0 ]   2 | ADDRESS                                                                            # Get address of currently executing account.                         this.address\n   962 [1505 0x05e1 ]   2 | PC                                                                                 # Get the value of the program counter prior to the increment.        evm.pc\n   963 [1506 0x05e2 ]  30 | SHA3                                                                               # Compute Keccak-256 hash.                                            flag             offset, size\n   964 [1507 0x05e3 ]  -1 | UNKNOWN_0xf                                                                        # Invalid opcode\n   965 [1508 0x05e4 ]   3 | SWAP4                                                                              # Exchange 1st and 5th stack items.\n   966 [1509 0x05e5 ]   3 | SWAP14                                                                             # Exchange 1st and 15th stack items.\n   967 [1510 0x05e6 ]   2 | CALLDATASIZE                                                                       # Get size of input data in current environment.                      msg.data.length\n   968 [1511 0x05e7 ]  -1 | UNKNOWN_0xe1                                                                       # Invalid opcode\n   969 [1512 0x05e8 ]  -1 | UNKNOWN_0xcb                                                                       # Invalid opcode\n   970 [1513 0x05e9 ]   3 | PUSH22          0xc68ec825da862dc7082ea12aea89eb3783b2e0423cd2                     # Place 22-byte item on stack.                                        item\n   971 [1536 0x0600 ]  30 | SHA3                                                                               # Compute Keccak-256 hash.                                            flag             offset, size\n   972 [1537 0x0601 ]  -1 | UNKNOWN_0x28                                                                       # Invalid opcode\n   973 [1538 0x0602 ]   3 | PUSH16          0x0029                                                             # Place 16-byte item on stack.                                        item\n==============================\nreconstructed ABI:\n[{'name': 'enter', 'stateMutability': 'nonpayable', 'signature': '0x124c32a1', 'payable': False, 'inputs': [{'name': '_passcode', 'type': 'bytes32'}, {'name': '_gateKey', 'type': 'bytes8'}], 'constant': False, 'type': 'function', 'outputs': [{'name': '', 'type': 'bool'}]}, {'name': 'maxEntrants', 'stateMutability': 'pure', 'signature': '0x60643652', 'payable': False, 'inputs': [], 'constant': True, 'type': 'function', 'outputs': [{'name': '', 'type': 'uint8'}]}, {'name': 'totalEntrants', 'stateMutability': 'view', 'signature': '0x694463a2', 'payable': False, 'inputs': [], 'constant': True, 'type': 'function', 'outputs': [{'name': '', 'type': 'uint8'}]}, {'name': 'assignAll', 'stateMutability': 'nonpayable', 'signature': '0x90ae631d', 'payable': False, 'inputs': [], 'constant': False, 'type': 'function', 'outputs': [{'name': '', 'type': 'bool'}]}, {'stateMutability': 'nonpayable', 'type': 'constructor', 'payable': False, 'inputs': []}]\n\n```\n\n\n**decompile to pseudocode**\n\n```\npython3 -m ethereum_dasm -a 0x44919b8026f38d70437a8eb3be47b06ab1c3e4bf --simplify #[--simplify-show-asm, --simplify-show-unreachable]\n\n======================[simplified]\n\n:init\n        memory[0x40] = 0x60\n        if (Not(ULE(0x4, 1_calldatasize))) goto LOC_0x48\n        if (And(If(1_calldatasize <= 0x3, 0x0, 1_calldata[0x3]) == 0xa1,\n                If(1_calldatasize <= 0x2, 0x0, 1_calldata[0x2]) == 0x32,\n                If(1_calldatasize <= 0x1, 0x0, 1_calldata[0x1]) == 0x4c,\n                If(1_calldatasize <= 0x0, 0x0, 1_calldata[0x0]) == 0x12)) goto function_enter (LOC_0x4d)\n        if (And(If(1_calldatasize <= 0x3, 0x0, 1_calldata[0x3]) == 0x52,\n                If(1_calldatasize <= 0x2, 0x0, 1_calldata[0x2]) == 0x36,\n                If(1_calldatasize <= 0x1, 0x0, 1_calldata[0x1]) == 0x64,\n                If(1_calldatasize <= 0x0, 0x0, 1_calldata[0x0]) == 0x60)) goto function_maxEntrants (LOC_0x95)\n        if (And(If(1_calldatasize <= 0x3, 0x0, 1_calldata[0x3]) == 0xa2,\n                If(1_calldatasize <= 0x2, 0x0, 1_calldata[0x2]) == 0x63,\n                If(1_calldatasize <= 0x1, 0x0, 1_calldata[0x1]) == 0x44,\n                If(1_calldatasize <= 0x0, 0x0, 1_calldata[0x0]) == 0x69)) goto function_totalEntrants (LOC_0xbe)\n        if (And(If(1_calldatasize <= 0x3, 0x0, 1_calldata[0x3]) == 0x1d,\n                If(1_calldatasize <= 0x2, 0x0, 1_calldata[0x2]) == 0x63,\n                If(1_calldatasize <= 0x1, 0x0, 1_calldata[0x1]) == 0xae,\n                If(1_calldatasize <= 0x0, 0x0, 1_calldata[0x0]) == 0x90)) goto function_assignAll (LOC_0xd1)\n\n:LOC_0x48 \n        REVERT(offset=0x0, size=0x0)\n        /******* <<terminates execution>> *******/\n\n:function_enter (LOC_0x4d) \n  /*******************************************************************\n    function enter(bytes32,bytes8)\n    payable: False\n    inputs: (2) ['bytes32', '<bytes??>']\n    potential signatures: ['enter(bytes32,bytes8)']\n  *******************************************************************/\n\n        if (call_value1 == 0x0) goto LOC_0x58\n        REVERT(offset=0x0, size=0x0)\n        /******* <<terminates execution>> *******/\n\n:LOC_0x58 \n        goto LOC_0xe4\n\n:LOC_0x81 \n\n:function_maxEntrants (LOC_0x95) \n  /*******************************************************************\n    function maxEntrants()\n    payable: False\n    inputs: (0) []\n    potential signatures: ['maxEntrants()']\n  *******************************************************************/\n\n        if (call_value1 == 0x0) goto LOC_0xa0\n        REVERT(offset=0x0, size=0x0)\n        /******* <<terminates execution>> *******/\n\n:LOC_0xa0 \n        goto LOC_0x314\n\n:LOC_0xa8 \n        memory[0x60] = 0xfa\n        RETURN(offset=0x60, size=0x20)\n        /******* <<terminates execution>> *******/\n\n:function_totalEntrants (LOC_0xbe) \n  /*******************************************************************\n    function totalEntrants()\n    payable: False\n    inputs: (0) []\n    potential signatures: ['totalEntrants()']\n  *******************************************************************/\n\n        if (call_value1 == 0x0) goto LOC_0xc9\n        REVERT(offset=0x0, size=0x0)\n        /******* <<terminates execution>> *******/\n\n:LOC_0xc9 \n        goto LOC_0x31a\n\n:function_assignAll (LOC_0xd1) \n  /*******************************************************************\n    function assignAll()\n    payable: False\n    inputs: (0) []\n    potential signatures: ['assignAll()']\n  *******************************************************************/\n\n        if (call_value1 == 0x0) goto LOC_0xdc\n        REVERT(offset=0x0, size=0x0)\n        /******* <<terminates execution>> *******/\n\n:LOC_0xdc \n        goto LOC_0x320\n\n:LOC_0xe4 \n        if (Not(Extract(159, 0, origin1) ==\n                0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef)) goto LOC_0x107\n        REVERT(offset=0x0, size=0x0)\n        /******* <<terminates execution>> *******/\n\n:LOC_0x107 \n        if (True) goto LOC_0x114\n\n:LOC_0x114 \n        if (bvurem_i(1_gas, 0x1fff) == 0x0) goto LOC_0x11f\n        REVERT(offset=0x0, size=0x0)\n        /******* <<terminates execution>> *******/\n\n:LOC_0x11f \n        if (And(If(1_calldatasize <= 0x29, 0x0, 1_calldata[0x29]) == 0x0,\n                If(1_calldatasize <= 0x28, 0x0, 1_calldata[0x28]) == 0x0)) goto LOC_0x154\n        REVERT(offset=0x0, size=0x0)\n        /******* <<terminates execution>> *******/\n\n:LOC_0x154 \n        if (Not(And(If(1_calldatasize <= 0x27, 0x0, 1_calldata[0x27]) ==\n                    0x0,\n                    If(1_calldatasize <= 0x26, 0x0, 1_calldata[0x26]) ==\n                    0x0,\n                    If(1_calldatasize <= 0x25, 0x0, 1_calldata[0x25]) ==\n                    0x0,\n                    If(1_calldatasize <= 0x24, 0x0, 1_calldata[0x24]) ==\n                    0x0))) goto LOC_0x18f\n        REVERT(offset=0x0, size=0x0)\n        /******* <<terminates execution>> *******/\n\n:LOC_0x18f \n        if (And(Extract(7, 0, origin1) ==\n                If(1_calldatasize <= 0x2b, 0x0, 1_calldata[0x2b]),\n                Extract(15, 8, origin1) ==\n                If(1_calldatasize <= 0x2a, 0x0, 1_calldata[0x2a]),\n                If(1_calldatasize <= 0x29, 0x0, 1_calldata[0x29]) == 0x0,\n                If(1_calldatasize <= 0x28, 0x0, 1_calldata[0x28]) == 0x0)) goto LOC_0x1c0\n        REVERT(offset=0x0, size=0x0)\n        /******* <<terminates execution>> *******/\n\n:LOC_0x1c0 \n        if (True) goto LOC_0x1d1\n\n:LOC_0x1d1 \n        memory[0x0] = 0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef\n        memory[0x20] = 0x3\n        if (True) goto LOC_0x1f7\n\n:LOC_0x1f7 \n        memory[0x0] = Concat(0x0, Extract(159, 0, origin1))\n        memory[0x20] = 0x3\n        if (True) goto LOC_0x21d\n\n:LOC_0x21d \n        memory[0x60] = Concat(If(1_calldatasize <= 0x4, 0x0, 1_calldata[0x4]),\n                   If(1_calldatasize <= 0x5, 0x0, 1_calldata[0x5]),\n                   If(1_calldatasize <= 0x6, 0x0, 1_calldata[0x6]),\n                   If(1_calldatasize <= 0x7, 0x0, 1_calldata[0x7]),\n                   If(1_calldatasize <= 0x8, 0x0, 1_calldata[0x8]),\n                   If(1_calldatasize <= 0x9, 0x0, 1_calldata[0x9]),\n                   If(1_calldatasize <= 0xa, 0x0, 1_calldata[0xa]),\n                   If(1_calldatasize <= 0xb, 0x0, 1_calldata[0xb]),\n                   If(1_calldatasize <= 0xc, 0x0, 1_calldata[0xc]),\n                   If(1_calldatasize <= 0xd, 0x0, 1_calldata[0xd]),\n                   If(1_calldatasize <= 0xe, 0x0, 1_calldata[0xe]),\n                   If(1_calldatasize <= 0xf, 0x0, 1_calldata[0xf]),\n                   If(1_calldatasize <= 0x10, 0x0, 1_calldata[0x10]),\n                   If(1_calldatasize <= 0x11, 0x0, 1_calldata[0x11]),\n                   If(1_calldatasize <= 0x12, 0x0, 1_calldata[0x12]),\n                   If(1_calldatasize <= 0x13, 0x0, 1_calldata[0x13]),\n                   If(1_calldatasize <= 0x14, 0x0, 1_calldata[0x14]),\n                   If(1_calldatasize <= 0x15, 0x0, 1_calldata[0x15]),\n                   If(1_calldatasize <= 0x16, 0x0, 1_calldata[0x16]),\n                   If(1_calldatasize <= 0x17, 0x0, 1_calldata[0x17]),\n                   If(1_calldatasize <= 0x18, 0x0, 1_calldata[0x18]),\n                   If(1_calldatasize <= 0x19, 0x0, 1_calldata[0x19]),\n                   If(1_calldatasize <= 0x1a, 0x0, 1_calldata[0x1a]),\n                   If(1_calldatasize <= 0x1b, 0x0, 1_calldata[0x1b]),\n                   If(1_calldatasize <= 0x1c, 0x0, 1_calldata[0x1c]),\n                   If(1_calldatasize <= 0x1d, 0x0, 1_calldata[0x1d]),\n                   If(1_calldatasize <= 0x1e, 0x0, 1_calldata[0x1e]),\n                   If(1_calldatasize <= 0x1f, 0x0, 1_calldata[0x1f]),\n                   If(1_calldatasize <= 0x20, 0x0, 1_calldata[0x20]),\n                   If(1_calldatasize <= 0x21, 0x0, 1_calldata[0x21]),\n                   If(1_calldatasize <= 0x22, 0x0, 1_calldata[0x22]),\n                   If(1_calldatasize <= 0x23, 0x0, 1_calldata[0x23]))\n        memory[0x0] = KECCAC[If(1_calldatasize_<=_0x4,_0x0,_1_calldata[0x4])]\n        memory[0x20] = 0x4\n        if (False) goto LOC_0x257\n        REVERT(offset=0x0, size=0x0)\n        /******* <<terminates execution>> *******/\n\n:LOC_0x257 \n\n:LOC_0x275 \n\n:LOC_0x2d6 \n\n:LOC_0x314 \n\n:LOC_0x317 \n        goto LOC_0xa8\n\n:LOC_0x31a \n        goto LOC_0xa8\n\n:LOC_0x320 \n        if (False) goto LOC_0x338\n        REVERT(offset=0x0, size=0x0)\n        /******* <<terminates execution>> *******/\n\n:LOC_0x338 \n\n:LOC_0x347 \n\n:LOC_0x3a8 \n\n:LOC_0x3b9 \n\n:LOC_0x3d8 \n\n:LOC_0x3e0 \n\n:LOC_0x3f5 \n\n:LOC_0x459 \n\n:LOC_0x46a \n\n:LOC_0x4de \n\n:LOC_0x541 \n\n:LOC_0x552 \n\n:LOC_0x556 \n\n:LOC_0x55e \n\n:LOC_0x588 \n\n:LOC_0x592 \n\n:LOC_0x5b6 \n\n:LOC_0x5bb \n\n:LOC_0x5c1 \n\n:LOC_0x5d5 \n```\n\n","description_content_type":"text/markdown","docs_url":null,"download_url":"https://github.com/tintinweb/ethereum-dasm/tarball/v0.1.5","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/tintinweb/ethereum-dasm","keywords":"ethereum,blockchain,evm,disassembler,decompiler,pseudocode","license":"GPLv2","maintainer":"","maintainer_email":"","name":"ethereum-dasm","package_url":"https://pypi.org/project/ethereum-dasm/","platform":"","project_url":"https://pypi.org/project/ethereum-dasm/","project_urls":{"Download":"https://github.com/tintinweb/ethereum-dasm/tarball/v0.1.5","Homepage":"https://github.com/tintinweb/ethereum-dasm"},"provides_extra":null,"release_url":"https://pypi.org/project/ethereum-dasm/0.1.5/","requires_dist":["evmdasm","colorama","requests","tabulate","ethereum-input-decoder ; extra == 'abidecoder'","pyetherchain ; extra == 'abidecoder'","mythril ; extra == 'mythril'"],"requires_python":"","summary":"An ethereum bytecode disassembler with static and dynamic analysis features","version":"0.1.5","yanked":false,"yanked_reason":null},"last_serial":5495864,"releases":{"0.1":[{"comment_text":"","digests":{"blake2b_256":"c7edf021a18576928d5f0e807bc43a62c7866cf9a8e730221363778e30d32392","md5":"cb467dfb7c139dd8bb455ac34b691f68","sha256":"7d5cf537a24750380bc0a6fcf3dbdf1a4d53e430c5484e9de3e14557dc0424ed"},"downloads":-1,"filename":"ethereum-dasm-0.1.tar.gz","has_sig":false,"md5_digest":"cb467dfb7c139dd8bb455ac34b691f68","packagetype":"sdist","python_version":"source","requires_python":null,"size":42316,"upload_time":"2018-07-07T18:37:12","upload_time_iso_8601":"2018-07-07T18:37:12.549346Z","url":"https://files.pythonhosted.org/packages/c7/ed/f021a18576928d5f0e807bc43a62c7866cf9a8e730221363778e30d32392/ethereum-dasm-0.1.tar.gz","yanked":false,"yanked_reason":null}],"0.1.1":[{"comment_text":"","digests":{"blake2b_256":"1e3e2d8ab8398be69334982ee413365ed755d4d715f16d3036f6684174b44d84","md5":"eaea4fe6383b25c9c570e95456e5a62b","sha256":"ef15e82f18f8dab7b4926a98b9fe14349ce0749e1e0658270bd6edc3181141ba"},"downloads":-1,"filename":"ethereum-dasm-0.1.1.tar.gz","has_sig":false,"md5_digest":"eaea4fe6383b25c9c570e95456e5a62b","packagetype":"sdist","python_version":"source","requires_python":null,"size":45194,"upload_time":"2018-08-19T22:57:32","upload_time_iso_8601":"2018-08-19T22:57:32.565439Z","url":"https://files.pythonhosted.org/packages/1e/3e/2d8ab8398be69334982ee413365ed755d4d715f16d3036f6684174b44d84/ethereum-dasm-0.1.1.tar.gz","yanked":false,"yanked_reason":null}],"0.1.2":[{"comment_text":"","digests":{"blake2b_256":"d10282f2e7cb87d12543ce142297dc05cad8ffbbcb4d1609b7b168c971208e7c","md5":"3f8ca2c71380bdd570021af5c3b8c919","sha256":"5deca544e20459a44cbabb490167e73f4c989d8c5403e36fdaae4e4ccdb7953d"},"downloads":-1,"filename":"ethereum_dasm-0.1.2-py3-none-any.whl","has_sig":false,"md5_digest":"3f8ca2c71380bdd570021af5c3b8c919","packagetype":"bdist_wheel","python_version":"py3","requires_python":null,"size":40167,"upload_time":"2018-08-20T18:55:48","upload_time_iso_8601":"2018-08-20T18:55:48.076341Z","url":"https://files.pythonhosted.org/packages/d1/02/82f2e7cb87d12543ce142297dc05cad8ffbbcb4d1609b7b168c971208e7c/ethereum_dasm-0.1.2-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"3d303d73b5a768b73acd0f0c8e0b8a0b5c16df257bf5c33a3e3fe33e824c496e","md5":"bcdf4220617aa4db37ea7092102ebab4","sha256":"07f7ca6b8b1c8bcc529601feb67d9ef0fbf64ec27c65f9e89f2cc2566a38b6c4"},"downloads":-1,"filename":"ethereum-dasm-0.1.2.tar.gz","has_sig":false,"md5_digest":"bcdf4220617aa4db37ea7092102ebab4","packagetype":"sdist","python_version":"source","requires_python":null,"size":46287,"upload_time":"2018-08-20T18:55:31","upload_time_iso_8601":"2018-08-20T18:55:31.732576Z","url":"https://files.pythonhosted.org/packages/3d/30/3d73b5a768b73acd0f0c8e0b8a0b5c16df257bf5c33a3e3fe33e824c496e/ethereum-dasm-0.1.2.tar.gz","yanked":false,"yanked_reason":null}],"0.1.3":[{"comment_text":"","digests":{"blake2b_256":"ce21a1039a1450a17d712a95ec64065a7912eb7eae0f1e65ec5789f79f154a7e","md5":"e97f06915232476a94fc8c3e757d2916","sha256":"1c2f0d1e6a3043e27ac6c9e87d27f8d0f1cc3d1edef3af28517e240d3ebebffa"},"downloads":-1,"filename":"ethereum-dasm-0.1.3.tar.gz","has_sig":false,"md5_digest":"e97f06915232476a94fc8c3e757d2916","packagetype":"sdist","python_version":"source","requires_python":null,"size":46368,"upload_time":"2018-09-26T20:04:05","upload_time_iso_8601":"2018-09-26T20:04:05.363660Z","url":"https://files.pythonhosted.org/packages/ce/21/a1039a1450a17d712a95ec64065a7912eb7eae0f1e65ec5789f79f154a7e/ethereum-dasm-0.1.3.tar.gz","yanked":false,"yanked_reason":null}],"0.1.4":[{"comment_text":"","digests":{"blake2b_256":"6ff19556efc3b5a80254a9376bfc339aafb33579429c78b03272a9204f90b1a7","md5":"92df463b4e6e38520e28f48c3d1f331b","sha256":"1defae432dfc45b118b4a3e69e375fd76c1a676b87c032c71c51bea92552bdb5"},"downloads":-1,"filename":"ethereum_dasm-0.1.4-py3-none-any.whl","has_sig":false,"md5_digest":"92df463b4e6e38520e28f48c3d1f331b","packagetype":"bdist_wheel","python_version":"py3","requires_python":null,"size":44574,"upload_time":"2018-10-12T21:08:43","upload_time_iso_8601":"2018-10-12T21:08:43.518820Z","url":"https://files.pythonhosted.org/packages/6f/f1/9556efc3b5a80254a9376bfc339aafb33579429c78b03272a9204f90b1a7/ethereum_dasm-0.1.4-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"9ee16a65615b927cee41cf141540ef0e18aa42d8483e55d1685739eac7441b3c","md5":"4e194f2b65800accaaf43624100c8270","sha256":"bad8b20f68728592b87bc9a4145e037cce329c4e396c0a4b79fc6ac32ffac220"},"downloads":-1,"filename":"ethereum-dasm-0.1.4.tar.gz","has_sig":false,"md5_digest":"4e194f2b65800accaaf43624100c8270","packagetype":"sdist","python_version":"source","requires_python":null,"size":42200,"upload_time":"2018-10-12T21:08:45","upload_time_iso_8601":"2018-10-12T21:08:45.674366Z","url":"https://files.pythonhosted.org/packages/9e/e1/6a65615b927cee41cf141540ef0e18aa42d8483e55d1685739eac7441b3c/ethereum-dasm-0.1.4.tar.gz","yanked":false,"yanked_reason":null}],"0.1.5":[{"comment_text":"","digests":{"blake2b_256":"da6e5246ae5cc12915bcc2ef798e0011618c4407bc18ef1fd03b0137815b8716","md5":"13e04e7340efd434ece59925dfddc858","sha256":"998aff7fbc1ef70210c1a34ffa2788e25f4e014c61e164411f6e4b4c2fdf2907"},"downloads":-1,"filename":"ethereum_dasm-0.1.5-py3-none-any.whl","has_sig":false,"md5_digest":"13e04e7340efd434ece59925dfddc858","packagetype":"bdist_wheel","python_version":"py3","requires_python":null,"size":35726,"upload_time":"2019-07-06T23:44:50","upload_time_iso_8601":"2019-07-06T23:44:50.419776Z","url":"https://files.pythonhosted.org/packages/da/6e/5246ae5cc12915bcc2ef798e0011618c4407bc18ef1fd03b0137815b8716/ethereum_dasm-0.1.5-py3-none-any.whl","yanked":false,"yanked_reason":null}]},"urls":[{"comment_text":"","digests":{"blake2b_256":"da6e5246ae5cc12915bcc2ef798e0011618c4407bc18ef1fd03b0137815b8716","md5":"13e04e7340efd434ece59925dfddc858","sha256":"998aff7fbc1ef70210c1a34ffa2788e25f4e014c61e164411f6e4b4c2fdf2907"},"downloads":-1,"filename":"ethereum_dasm-0.1.5-py3-none-any.whl","has_sig":false,"md5_digest":"13e04e7340efd434ece59925dfddc858","packagetype":"bdist_wheel","python_version":"py3","requires_python":null,"size":35726,"upload_time":"2019-07-06T23:44:50","upload_time_iso_8601":"2019-07-06T23:44:50.419776Z","url":"https://files.pythonhosted.org/packages/da/6e/5246ae5cc12915bcc2ef798e0011618c4407bc18ef1fd03b0137815b8716/ethereum_dasm-0.1.5-py3-none-any.whl","yanked":false,"yanked_reason":null}],"vulnerabilities":[]}
