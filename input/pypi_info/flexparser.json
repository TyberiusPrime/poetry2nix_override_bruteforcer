{"info":{"author":null,"author_email":"\"Hernan E. Grecco\" <hernan.grecco@gmail.com>","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Developers","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Operating System :: MacOS :: MacOS X","Operating System :: Microsoft :: Windows","Operating System :: POSIX","Programming Language :: Python","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11","Programming Language :: Python :: 3.12","Programming Language :: Python :: 3.9","Topic :: Software Development :: Libraries","Topic :: System :: Filesystems","Topic :: Utilities"],"description":".. image:: https://img.shields.io/pypi/v/flexparser.svg\n    :target: https://pypi.python.org/pypi/flexparser\n    :alt: Latest Version\n\n.. image:: https://img.shields.io/pypi/l/flexparser.svg\n    :target: https://pypi.python.org/pypi/flexparser\n    :alt: License\n\n.. image:: https://img.shields.io/pypi/pyversions/flexparser.svg\n    :target: https://pypi.python.org/pypi/flexparser\n    :alt: Python Versions\n\n.. image:: https://github.com/hgrecco/flexparser/workflows/CI/badge.svg\n    :target: https://github.com/hgrecco/flexparser/actions?query=workflow%3ACI\n    :alt: CI\n\n.. image:: https://github.com/hgrecco/flexparser/workflows/Lint/badge.svg\n    :target: https://github.com/hgrecco/flexparser/actions?query=workflow%3ALint\n    :alt: LINTER\n\n.. image:: https://coveralls.io/repos/github/hgrecco/flexparser/badge.svg?branch=main\n    :target: https://coveralls.io/github/hgrecco/flexparser?branch=main\n    :alt: Coverage\n\n\nflexparser\n==========\n\nWhy write another parser? I have asked myself the same question while\nworking on this project. It is clear that there are excellent parsers out\nthere but I wanted to experiment with another way of writing them.\n\nThe idea is quite simple. You write a class for every type of content\n(called here ``ParsedStatement``) you need to parse. Each class should\nhave a ``from_string`` constructor. We used extensively the ``typing``\nmodule to make the output structure easy to use and less error prone.\n\nFor example:\n\n.. code-block:: python\n\n    from dataclasses import dataclass\n\n    import flexparser as fp\n\n    @dataclass(frozen=True)\n    class Assigment(fp.ParsedStatement):\n        \"\"\"Parses the following `this <- other`\n        \"\"\"\n\n        lhs: str\n        rhs: str\n\n        @classmethod\n        def from_string(cls, s):\n            lhs, rhs = s.split(\"<-\")\n            return cls(lhs.strip(), rhs.strip())\n\n(using a frozen dataclass is not necessary but it convenient. Being a\ndataclass you get the init, str, repr, etc for free. Being frozen, sort\nof immutable, makes them easier to reason around)\n\nIn certain cases you might want to signal the parser\nthat his class is not appropriate to parse the statement.\n\n.. code-block:: python\n\n    @dataclass(frozen=True)\n    class Assigment(fp.ParsedStatement):\n        \"\"\"Parses the following `this <- other`\n        \"\"\"\n\n        lhs: str\n        rhs: str\n\n        @classmethod\n        def from_string(cls, s):\n            if \"<-\" not in s:\n                # This means: I do not know how to parse it\n                # try with another ParsedStatement class.\n                return None\n            lhs, rhs = s.split(\"<-\")\n            return cls(lhs.strip(), rhs.strip())\n\n\nYou might also want to indicate that this is the right ``ParsedStatement``\nbut something is not right:\n\n.. code-block:: python\n\n    @dataclass(frozen=True)\n    class InvalidIdentifier(fp.ParsingError):\n        value: str\n\n\n    @dataclass(frozen=True)\n    class Assigment(fp.ParsedStatement):\n        \"\"\"Parses the following `this <- other`\n        \"\"\"\n\n        lhs: str\n        rhs: str\n\n        @classmethod\n        def from_string(cls, s):\n            if \"<-\" not in s:\n                # This means: I do not know how to parse it\n                # try with another ParsedStatement class.\n                return None\n            lhs, rhs = (p.strip() for p in s.split(\"<-\"))\n\n            if not str.isidentifier(lhs):\n                return InvalidIdentifier(lhs)\n\n            return cls(lhs, rhs)\n\n\nPut this into ``source.txt``\n\n.. code-block:: text\n\n    one <- other\n    2two <- new\n    three <- newvalue\n    one == three\n\nand then run the following code:\n\n.. code-block:: python\n\n    parsed = fp.parse(\"source.txt\", Assigment)\n    for el in parsed.iter_statements():\n        print(repr(el))\n\nwill produce the following output:\n\n.. code-block:: text\n\n    BOF(start_line=0, start_col=0, end_line=0, end_col=0, raw=None, content_hash=Hash(algorithm_name='blake2b', hexdigest='37bc23cde7cad3ece96b7abf64906c84decc116de1e0486679eb6ca696f233a403f756e2e431063c82abed4f0e342294c2fe71af69111faea3765b78cb90c03f'), path=PosixPath('/Users/grecco/Documents/code/flexparser/examples/in_readme/source1.txt'), mtime=1658550284.9419456)\n    Assigment(start_line=1, start_col=0, end_line=1, end_col=12, raw='one <- other', lhs='one', rhs='other')\n    InvalidIdentifier(start_line=2, start_col=0, end_line=2, end_col=11, raw='2two <- new', value='2two')\n    Assigment(start_line=3, start_col=0, end_line=3, end_col=17, raw='three <- newvalue', lhs='three', rhs='newvalue')\n    UnknownStatement(start_line=4, start_col=0, end_line=4, end_col=12, raw='one == three')\n    EOS(start_line=5, start_col=0, end_line=5, end_col=0, raw=None)\n\n\nThe result is a collection of ``ParsedStatement`` or ``ParsingError`` (flanked by\n``BOF`` and ``EOS`` indicating beginning of file and ending of stream respectively\nAlternative, it can beginning with ``BOR`` with means beginning of resource and it\nis used when parsing a Python Resource provided with a package).\n\nNotice that there are two correctly parsed statements (``Assigment``), one\nerror found (``InvalidIdentifier``) and one unknown (``UnknownStatement``).\n\nCool, right? Just writing a ``from_string`` method that outputs a datastructure\nproduces a usable structure of parsed objects.\n\nNow what? Let's say we want to support equality comparison. Simply do:\n\n.. code-block:: python\n\n    @dataclass(frozen=True)\n    class EqualityComparison(fp.ParsedStatement):\n        \"\"\"Parses the following `this == other`\n        \"\"\"\n\n        lhs: str\n        rhs: str\n\n        @classmethod\n        def from_string(cls, s):\n            if \"==\" not in s:\n                return None\n            lhs, rhs = (p.strip() for p in s.split(\"==\"))\n\n            return cls(lhs, rhs)\n\n    parsed = fp.parse(\"source.txt\", (Assigment, Equality))\n    for el in parsed.iter_statements():\n        print(repr(el))\n\nand run it again:\n\n.. code-block:: text\n\n    BOF(start_line=0, start_col=0, end_line=0, end_col=0, raw=None, content_hash=Hash(algorithm_name='blake2b', hexdigest='37bc23cde7cad3ece96b7abf64906c84decc116de1e0486679eb6ca696f233a403f756e2e431063c82abed4f0e342294c2fe71af69111faea3765b78cb90c03f'), path=PosixPath('/Users/grecco/Documents/code/flexparser/examples/in_readme/source1.txt'), mtime=1658550284.9419456)\n    Assigment(start_line=1, start_col=0, end_line=1, end_col=12, raw='one <- other', lhs='one', rhs='other')\n    InvalidIdentifier(start_line=2, start_col=0, end_line=2, end_col=11, raw='2two <- new', value='2two')\n    Assigment(start_line=3, start_col=0, end_line=3, end_col=17, raw='three <- newvalue', lhs='three', rhs='newvalue')\n    EqualityComparison(start_line=4, start_col=0, end_line=4, end_col=12, raw='one == three', lhs='one', rhs='three')\n    EOS(start_line=5, start_col=0, end_line=5, end_col=0, raw=None)\n\n\nYou need to group certain statements together: welcome to ``Block``\nThis construct allows you to group\n\n.. code-block:: python\n\n    class Begin(fp.ParsedStatement):\n\n        @classmethod\n        def from_string(cls, s):\n            if s == \"begin\":\n                return cls()\n\n            return None\n\n    class End(fp.ParsedStatement):\n\n        @classmethod\n        def from_string(cls, s):\n            if s == \"end\":\n                return cls()\n\n            return None\n\n    class ParserConfig:\n        pass\n\n    class AssigmentBlock(fp.Block[Begin, Assigment, End, ParserConfig]):\n        pass\n\n    parsed = fp.parse(\"source.txt\", (AssigmentBlock, Equality))\n\n\nRun the code:\n\n.. code-block:: text\n\n    BOF(start_line=0, start_col=0, end_line=0, end_col=0, raw=None, content_hash=Hash(algorithm_name='blake2b', hexdigest='37bc23cde7cad3ece96b7abf64906c84decc116de1e0486679eb6ca696f233a403f756e2e431063c82abed4f0e342294c2fe71af69111faea3765b78cb90c03f'), path=PosixPath('/Users/grecco/Documents/code/flexparser/examples/in_readme/source1.txt'), mtime=1658550284.9419456)\n    UnknownStatement(start_line=1, start_col=0, end_line=1, end_col=12, raw='one <- other')\n    UnknownStatement(start_line=2, start_col=0, end_line=2, end_col=11, raw='2two <- new')\n    UnknownStatement(start_line=3, start_col=0, end_line=3, end_col=17, raw='three <- newvalue')\n    UnknownStatement(start_line=4, start_col=0, end_line=4, end_col=12, raw='one == three')\n    EOS(start_line=5, start_col=0, end_line=5, end_col=0, raw=None)\n\n\nNotice that there are a lot of ``UnknownStatement`` now, because we instructed\nthe parser to only look for assignment within a block. So change your text file to:\n\n.. code-block:: text\n\n    begin\n    one <- other\n    2two <- new\n    three <- newvalue\n    end\n    one == three\n\nand try again:\n\n.. code-block:: text\n\n    BOF(start_line=0, start_col=0, end_line=0, end_col=0, raw=None, content_hash=Hash(algorithm_name='blake2b', hexdigest='3d8ce0051dcdd6f0f80ef789a0df179509d927874f242005ac41ed886ae0b71a30b845b9bfcb30194461c0ef6a3ca324c36f411dfafc7e588611f1eb0269bb5a'), path=PosixPath('/Users/grecco/Documents/code/flexparser/examples/in_readme/source2.txt'), mtime=1658550707.1248093)\n    Begin(start_line=1, start_col=0, end_line=1, end_col=5, raw='begin')\n    Assigment(start_line=2, start_col=0, end_line=2, end_col=12, raw='one <- other', lhs='one', rhs='other')\n    InvalidIdentifier(start_line=3, start_col=0, end_line=3, end_col=11, raw='2two <- new', value='2two')\n    Assigment(start_line=4, start_col=0, end_line=4, end_col=17, raw='three <- newvalue', lhs='three', rhs='newvalue')\n    End(start_line=5, start_col=0, end_line=5, end_col=3, raw='end')\n    EqualityComparison(start_line=6, start_col=0, end_line=6, end_col=12, raw='one == three', lhs='one', rhs='three')\n    EOS(start_line=7, start_col=0, end_line=7, end_col=0, raw=None)\n\n\nUntil now we have used ``parsed.iter_statements`` to iterate over all parsed statements.\nBut let's look inside ``parsed``, an object of ``ParsedProject`` type. It is a thin wrapper\nover a dictionary mapping files to parsed content. Because we have provided a single file\nand this does not contain a link another, our ``parsed`` object contains a single element.\nThe key is ``None`` indicating that the file 'source.txt' was loaded from the root location\n(None). The content is a ``ParsedSourceFile`` object with the following attributes:\n\n- **path**: full path of the source file\n- **mtime**: modification file of the source file\n- **content_hash**: hash of the pickled content\n- **config**: extra parameters that can be given to the parser (see below).\n\n.. code-block:: text\n\n    ParsedSource(\n        parsed_source=parse.<locals>.CustomRootBlock(\n            opening=BOF(start_line=0, start_col=0, end_line=0, end_col=0, raw=None, content_hash=Hash(algorithm_name='blake2b', hexdigest='3d8ce0051dcdd6f0f80ef789a0df179509d927874f242005ac41ed886ae0b71a30b845b9bfcb30194461c0ef6a3ca324c36f411dfafc7e588611f1eb0269bb5a'), path=PosixPath('/Users/grecco/Documents/code/flexparser/examples/in_readme/source2.txt'), mtime=1658550707.1248093),\n            body=(\n                Block.subclass_with.<locals>.CustomBlock(\n                    opening=Begin(start_line=1, start_col=0, end_line=1, end_col=5, raw='begin'),\n                    body=(\n                        Assigment(start_line=2, start_col=0, end_line=2, end_col=12, raw='one <- other', lhs='one', rhs='other'),\n                        InvalidIdentifier(start_line=3, start_col=0, end_line=3, end_col=11, raw='2two <- new', value='2two'),\n                        Assigment(start_line=4, start_col=0, end_line=4, end_col=17, raw='three <- newvalue', lhs='three', rhs='newvalue')\n                    ),\n                    closing=End(start_line=5, start_col=0, end_line=5, end_col=3, raw='end')),\n                EqualityComparison(start_line=6, start_col=0, end_line=6, end_col=12, raw='one == three', lhs='one', rhs='three')),\n            closing=EOS(start_line=7, start_col=0, end_line=7, end_col=0, raw=None)),\n        config=None\n    )\n\n\nA few things to notice:\n\n1. We were using a block before without knowing. The ``RootBlock`` is a\n   special type of Block that starts and ends automatically with the\n   file.\n2. ``opening``, ``body``, ``closing`` are automatically annotated with the\n   possible ``ParsedStatement`` (plus `ParsingError`),\n   therefore autocompletes works in most IDEs.\n3. The same is true for the defined ``ParsedStatement`` (we have use\n   ``dataclass`` for a reason). This makes using the actual\n   result of the parsing a charm!.\n4. That annoying ``subclass_with.<locals>`` is because we have built\n   a class on the fly when we used ``Block.subclass_with``. You can\n   get rid of it (which is actually useful for pickling) by explicit\n   subclassing Block in your code (see below).\n\n\nMultiple source files\n---------------------\n\nMost projects have more than one source file internally connected.\nA file might refer to another that also need to be parsed (e.g. an\n`#include` statement in c). **flexparser** provides the ``IncludeStatement``\nbase class specially for this purpose.\n\n.. code-block:: python\n\n    @dataclass(frozen=True)\n    class Include(fp.IncludeStatement):\n        \"\"\"A naive implementation of #include \"file\"\n        \"\"\"\n\n        value: str\n\n        @classmethod\n        def from_string(cls, s):\n            if s.startwith(\"#include \"):\n                return None\n\n            value = s[len(\"#include \"):].strip().strip('\"')\n\n            return cls(value)\n\n        @propery\n        def target(self):\n            return self.value\n\nThe only difference is that you need to implement a ``target`` property\nthat returns the file name or resource that this statement refers to.\n\n\nCustomizing statementization\n----------------------------\n\nstatementi ... what? **flexparser** works by trying to parse each statement with\none of the known classes. So it is fair to ask what is an statement in this\ncontext and how can you configure it to your needs. A text file is split into\nnon overlapping strings called **statements**. Parsing work as follows:\n\n1. each file is split into statements (can be single or multi line).\n2. each statement is parsed with the first of the contextually\n   available ParsedStatement or Block subclassed that returns\n   a ``ParsedStatement`` or ``ParsingError``\n\nYou can customize how to split each line into statements with two arguments\nprovided to parse:\n\n- **strip_spaces** (`bool`): indicates that leading and trailing spaces must\n  be removed before attempting to parse.\n  (default: True)\n- **delimiters** (`dict`): indicates how each line must be subsplit.\n  (default: do not divide)\n\nAn delimiter example might be\n``{\";\": (fp.DelimiterInclude.SKIP, fp.DelimiterAction.CONTINUE)}``\nwhich tells the statementizer (sorry) that when a \";\" is found a new statement should\nbegin. ``DelimiterMode.SKIP`` tells that \";\" should not be added to the previous\nstatement nor to the next. Other valid values are ``SPLIT_AFTER`` and ``SPLIT_BEFORE``\nto append or prepend the delimiter character to the previous or next statement.\nThe second element tells the statementizer (sorry again) what to do next:\nvalid values are: `CONTINUE`, `CAPTURE_NEXT_TIL_EOL`, `STOP_PARSING_LINE`, and\n`STOP_PARSING`.\n\nThis is useful with comments. For example,\n``{\"#\": (fp.DelimiterMode.WITH_NEXT, fp.DelimiterAction.CAPTURE_NEXT_TIL_EOL))}``\ntells the statementizer (it is not funny anymore) that after the first \"#\"\nit should stop splitting and capture all.\n\nThis allows:\n\n.. code-block:: text\n\n    ## This will work as a single statement\n    # This will work as a single statement #\n    # This will work as # a single statement #\n    a = 3 # this will produce two statements (a=3, and the rest)\n\n\nExplicit Block classes\n----------------------\n\n.. code-block:: python\n\n    class AssigmentBlock(fp.Block[Begin, Assigment, End]):\n        pass\n\n    class EntryBlock(fp.RootBlock[Union[AssigmentBlock, Equality]]):\n        pass\n\n    parsed = fp.parse(\"source.txt\", EntryBlock)\n\n\nCustomizing parsing\n-------------------\n\nIn certain cases you might want to leave to the user some configuration\ndetails. We have method for that!. Instead of overriding ``from_string``\noverride ``from_string_and_config``. The second argument is an object\nthat can be given to the parser, which in turn will be passed to each\n``ParsedStatement`` class.\n\n.. code-block:: python\n\n    @dataclass(frozen=True)\n    class NumericAssigment(fp.ParsedStatement):\n        \"\"\"Parses the following `this <- other`\n        \"\"\"\n\n        lhs: str\n        rhs: numbers.Number\n\n        @classmethod\n        def from_string_and_config(cls, s, config):\n            if \"==\" not in s:\n                # This means: I do not know how to parse it\n                # try with another ParsedStatement class.\n                return None\n            lhs, rhs = s.split(\"==\")\n            return cls(lhs.strip(), config.numeric_type(rhs.strip()))\n\n    class Config:\n\n        numeric_type = float\n\n    parsed = fp.parse(\"source.txt\", NumericAssigment, Config)\n\n----\n\nThis project was started as a part of Pint_, the python units package.\n\nSee AUTHORS_ for a list of the maintainers.\n\nTo review an ordered list of notable changes for each version of a project,\nsee CHANGES_\n\n.. _`AUTHORS`: https://github.com/hgrecco/flexparser/blob/main/AUTHORS\n.. _`CHANGES`: https://github.com/hgrecco/flexparser/blob/main/CHANGES\n.. _`Pint`: https://github.com/hgrecco/pint\n","description_content_type":"text/x-rst","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":null,"keywords":"parser, code, parsing, source","license":"BSD-3-Clause","maintainer":null,"maintainer_email":"\"Hernan E. Grecco\" <hernan.grecco@gmail.com>","name":"flexparser","package_url":"https://pypi.org/project/flexparser/","platform":null,"project_url":"https://pypi.org/project/flexparser/","project_urls":{"Homepage":"https://github.com/hgrecco/flexparser"},"provides_extra":null,"release_url":"https://pypi.org/project/flexparser/0.3.1/","requires_dist":["typing-extensions","pytest; extra == \"test\"","pytest-mpl; extra == \"test\"","pytest-cov; extra == \"test\"","pytest-subtests; extra == \"test\""],"requires_python":">=3.9","summary":"Parsing made fun ... using typing.","version":"0.3.1","yanked":false,"yanked_reason":null},"last_serial":23548508,"releases":{"0.1":[{"comment_text":"","digests":{"blake2b_256":"9c06a8cacc2ac6b2a8593cd42a7e8f13a99869401540b760489cb29a70836bf6","md5":"a2a91ce3a2b6e2d76ae80e9ed3708553","sha256":"0a2913dde5c9cfdfefc78885d8669d9d77d4ff5913b1c05c7e5364dc0280313b"},"downloads":-1,"filename":"flexparser-0.1.tar.gz","has_sig":false,"md5_digest":"a2a91ce3a2b6e2d76ae80e9ed3708553","packagetype":"sdist","python_version":"source","requires_python":">=3.7","size":24983,"upload_time":"2022-06-04T18:50:59","upload_time_iso_8601":"2022-06-04T18:50:59.923201Z","url":"https://files.pythonhosted.org/packages/9c/06/a8cacc2ac6b2a8593cd42a7e8f13a99869401540b760489cb29a70836bf6/flexparser-0.1.tar.gz","yanked":false,"yanked_reason":null}],"0.2":[{"comment_text":"","digests":{"blake2b_256":"574c8499d75e0d75ce2232c18005a709e413509542b8158e5541ca913ea81686","md5":"28d06d67724be965fba6d94e8f65d60d","sha256":"eb0c3fe38940e0298f3c64a28404272ef1c47b1652447d70a26a7a473f1c4770"},"downloads":-1,"filename":"flexparser-0.2-py3-none-any.whl","has_sig":false,"md5_digest":"28d06d67724be965fba6d94e8f65d60d","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.9","size":26443,"upload_time":"2023-11-27T01:08:48","upload_time_iso_8601":"2023-11-27T01:08:48.907531Z","url":"https://files.pythonhosted.org/packages/57/4c/8499d75e0d75ce2232c18005a709e413509542b8158e5541ca913ea81686/flexparser-0.2-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"36870306a2117760789d0ca6204441e062bac0426cf1e96e8b2fe0daca7a3513","md5":"de32664210d22ff0572cdcf6a828d090","sha256":"327e94ee1ef7d3dc4e11a5c35593f15cc246007dbf9457afc5fa2b9b0bcf853b"},"downloads":-1,"filename":"flexparser-0.2.tar.gz","has_sig":false,"md5_digest":"de32664210d22ff0572cdcf6a828d090","packagetype":"sdist","python_version":"source","requires_python":">=3.9","size":30684,"upload_time":"2023-11-27T01:08:50","upload_time_iso_8601":"2023-11-27T01:08:50.875996Z","url":"https://files.pythonhosted.org/packages/36/87/0306a2117760789d0ca6204441e062bac0426cf1e96e8b2fe0daca7a3513/flexparser-0.2.tar.gz","yanked":false,"yanked_reason":null}],"0.2.1":[{"comment_text":"","digests":{"blake2b_256":"cbc23682a77629e509057380a8b44c9184079d3050df64966eb98ee7d21947c6","md5":"aa8142b121bdb9ec4468d3c6795841ad","sha256":"6b7076cbfd29626bdd83806910befcf8e7f1595053afc93ee627be946e391029"},"downloads":-1,"filename":"flexparser-0.2.1-py3-none-any.whl","has_sig":false,"md5_digest":"aa8142b121bdb9ec4468d3c6795841ad","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.9","size":26877,"upload_time":"2024-03-08T21:35:37","upload_time_iso_8601":"2024-03-08T21:35:37.234290Z","url":"https://files.pythonhosted.org/packages/cb/c2/3682a77629e509057380a8b44c9184079d3050df64966eb98ee7d21947c6/flexparser-0.2.1-py3-none-any.whl","yanked":true,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"30d0e646499ef11597258677625bbec43dc5ec450ed14e45329c1f3b717d93fe","md5":"778708b0ec08f420640dd4209be7736a","sha256":"47892d375bb9b6f5b3a41216e78e17c829eba9a3fbd81a620c3f551f479d456f"},"downloads":-1,"filename":"flexparser-0.2.1.tar.gz","has_sig":false,"md5_digest":"778708b0ec08f420640dd4209be7736a","packagetype":"sdist","python_version":"source","requires_python":">=3.9","size":31151,"upload_time":"2024-03-08T21:35:39","upload_time_iso_8601":"2024-03-08T21:35:39.290130Z","url":"https://files.pythonhosted.org/packages/30/d0/e646499ef11597258677625bbec43dc5ec450ed14e45329c1f3b717d93fe/flexparser-0.2.1.tar.gz","yanked":true,"yanked_reason":null}],"0.3":[{"comment_text":"","digests":{"blake2b_256":"c1c7149e21a9c483022aa70f27eeba0519972345293533a7a84e57dc5208847d","md5":"da657ba5bc0da54db98ba043f1469a44","sha256":"aa362a3898851595765ead76822cbf55eae40dfaeebd5232a06391dce6ee0567"},"downloads":-1,"filename":"flexparser-0.3-py3-none-any.whl","has_sig":false,"md5_digest":"da657ba5bc0da54db98ba043f1469a44","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.9","size":26974,"upload_time":"2024-03-09T01:01:59","upload_time_iso_8601":"2024-03-09T01:01:59.393459Z","url":"https://files.pythonhosted.org/packages/c1/c7/149e21a9c483022aa70f27eeba0519972345293533a7a84e57dc5208847d/flexparser-0.3-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"2eab2208802e7a57cc1f38c8f09b561cac478c0f6b444a646606539d9c95ab57","md5":"da9d31f36372805e470da52b2d45636b","sha256":"692e7524d9e14b2b1231b772b091d7d6296951deb383f5a67bfbd0ecb0b9fa9a"},"downloads":-1,"filename":"flexparser-0.3.tar.gz","has_sig":false,"md5_digest":"da9d31f36372805e470da52b2d45636b","packagetype":"sdist","python_version":"source","requires_python":">=3.9","size":31288,"upload_time":"2024-03-09T01:02:01","upload_time_iso_8601":"2024-03-09T01:02:01.145904Z","url":"https://files.pythonhosted.org/packages/2e/ab/2208802e7a57cc1f38c8f09b561cac478c0f6b444a646606539d9c95ab57/flexparser-0.3.tar.gz","yanked":false,"yanked_reason":null}],"0.3.1":[{"comment_text":"","digests":{"blake2b_256":"a3285ce78a4838bb9da1bd9f64bc79ba12ddbfcb4824a11ef41da6f05d3240ef","md5":"40b15b88e5dafdda764d4caaa78afe58","sha256":"2e3e2936bec1f9277f777ef77297522087d96adb09624d4fe4240fd56885c013"},"downloads":-1,"filename":"flexparser-0.3.1-py3-none-any.whl","has_sig":false,"md5_digest":"40b15b88e5dafdda764d4caaa78afe58","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.9","size":27289,"upload_time":"2024-06-06T00:53:36","upload_time_iso_8601":"2024-06-06T00:53:36.714083Z","url":"https://files.pythonhosted.org/packages/a3/28/5ce78a4838bb9da1bd9f64bc79ba12ddbfcb4824a11ef41da6f05d3240ef/flexparser-0.3.1-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"dce4a73612499d9c8c450c8f4878e8bb8b3b2dce4bf671b21dd8d5c6549525a7","md5":"0548caa6dd104740ff6cfa9af88156c6","sha256":"36f795d82e50f5c9ae2fde1c33f21f88922fdd67b7629550a3cc4d0b40a66856"},"downloads":-1,"filename":"flexparser-0.3.1.tar.gz","has_sig":false,"md5_digest":"0548caa6dd104740ff6cfa9af88156c6","packagetype":"sdist","python_version":"source","requires_python":">=3.9","size":31422,"upload_time":"2024-06-06T00:53:38","upload_time_iso_8601":"2024-06-06T00:53:38.425812Z","url":"https://files.pythonhosted.org/packages/dc/e4/a73612499d9c8c450c8f4878e8bb8b3b2dce4bf671b21dd8d5c6549525a7/flexparser-0.3.1.tar.gz","yanked":false,"yanked_reason":null}]},"urls":[{"comment_text":"","digests":{"blake2b_256":"a3285ce78a4838bb9da1bd9f64bc79ba12ddbfcb4824a11ef41da6f05d3240ef","md5":"40b15b88e5dafdda764d4caaa78afe58","sha256":"2e3e2936bec1f9277f777ef77297522087d96adb09624d4fe4240fd56885c013"},"downloads":-1,"filename":"flexparser-0.3.1-py3-none-any.whl","has_sig":false,"md5_digest":"40b15b88e5dafdda764d4caaa78afe58","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.9","size":27289,"upload_time":"2024-06-06T00:53:36","upload_time_iso_8601":"2024-06-06T00:53:36.714083Z","url":"https://files.pythonhosted.org/packages/a3/28/5ce78a4838bb9da1bd9f64bc79ba12ddbfcb4824a11ef41da6f05d3240ef/flexparser-0.3.1-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"dce4a73612499d9c8c450c8f4878e8bb8b3b2dce4bf671b21dd8d5c6549525a7","md5":"0548caa6dd104740ff6cfa9af88156c6","sha256":"36f795d82e50f5c9ae2fde1c33f21f88922fdd67b7629550a3cc4d0b40a66856"},"downloads":-1,"filename":"flexparser-0.3.1.tar.gz","has_sig":false,"md5_digest":"0548caa6dd104740ff6cfa9af88156c6","packagetype":"sdist","python_version":"source","requires_python":">=3.9","size":31422,"upload_time":"2024-06-06T00:53:38","upload_time_iso_8601":"2024-06-06T00:53:38.425812Z","url":"https://files.pythonhosted.org/packages/dc/e4/a73612499d9c8c450c8f4878e8bb8b3b2dce4bf671b21dd8d5c6549525a7/flexparser-0.3.1.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[]}
