{"info":{"author":"","author_email":"Tibor Leupold <tibor@lpld.io>","bugtrack_url":null,"classifiers":["Development Status :: 3 - Alpha","Framework :: Django","Framework :: Django :: 3.2","Framework :: Django :: 4.0","Framework :: Django :: 4.1","Framework :: Django :: 4.2","Framework :: Django :: 5.0","Intended Audience :: Developers","License :: OSI Approved :: BSD License","Operating System :: OS Independent","Programming Language :: Python","Programming Language :: Python :: 3","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11","Programming Language :: Python :: 3.12","Programming Language :: Python :: 3.8","Programming Language :: Python :: 3.9"],"description":"# Laces\n\n[![License: BSD-3-Clause](https://img.shields.io/badge/License-BSD--3--Clause-blue.svg)](https://opensource.org/licenses/BSD-3-Clause)\n[![PyPI version](https://badge.fury.io/py/laces.svg)](https://badge.fury.io/py/laces)\n[![laces CI](https://github.com/tbrlpld/laces/actions/workflows/test.yml/badge.svg)](https://github.com/tbrlpld/laces/actions/workflows/test.yml)\n[![codecov](https://codecov.io/gh/tbrlpld/laces/graph/badge.svg?token=FMHEHNVPSX)](https://codecov.io/gh/tbrlpld/laces)\n\n---\n\nDjango components that know how to render themselves.\n\nLaces components provide a simple way to combine data (in the form of Python objects) with the Django templates that are meant to render that data.\nThe components can then be simply rendered in any other template using the `{% component %}` template tag.\nThat parent template does not need to know anything about the component's template or data.\nNo need to receive, filter, restructure or pass any data to the component's template.\nJust let the component render itself.\n\nTemplate and data are tied together (sorry, not sorry ðŸ˜…) in the component, and they can be passed around together.\nThis becomes especially useful when components are nested â€” it allows us to avoid building the same nested structure twice (once in the data and again in the templates).\n\nWorking with objects that know how to render themselves as HTML elements is a common pattern found in complex Django applications, such as the [Wagtail](https://github.com/wagtail/wagtail) admin interface.\nThe Wagtail admin is also where the APIs provided in this package have previously been discovered, developed and solidified.\nThe purpose of this package is to make these tools available to other Django projects outside the Wagtail ecosystem.\n\n## Links\n\n- [Getting started](#getting-started)\n    - [Installation](#installation)\n    - [Creating components](#creating-components)\n    - [Passing context to the component template](#passing-context-to-the-component-template)\n    - [Using components in other templates](#using-components-in-other-templates)\n    - [Adding JavaScript and CSS assets to a component](#adding-javascript-and-css-assets-to-a-component)\n- [Patterns for using components](#patterns-for-using-components)\n  - [Nesting components](#nesting-components)\n  - [Nested groups of components](#nested-groups-of-components)\n  - [Container components](#container-components)\n  - [Using dataclasses](#using-dataclasses)\n- [About Laces and components](#about-laces-and-components)\n- [Contributing](#contributing)\n- [Changelog](https://github.com/tbrlpld/laces/blob/main/CHANGELOG.md)\n- [Discussions](https://github.com/tbrlpld/laces/discussions)\n- [Security](https://github.com/tbrlpld/laces/security)\n\n## Getting started\n\n### Installation\n\nFirst, install with pip:\n```sh\n$ python -m pip install laces\n```\n\nThen, add to your installed apps:\n\n```python\n# settings.py\n\nINSTALLED_APPS = [\"laces\", ...]\n```\n\nThat's it.\n\n### Creating components\n\nThe simplest way to create a component is to define a subclass of `laces.components.Component` and specify a `template_name` attribute on it.\n\n```python\n# my_app/components.py\n\nfrom laces.components import Component\n\n\nclass WelcomePanel(Component):\n    template_name = \"my_app/components/welcome.html\"\n```\n\n```html+django\n{# my_app/templates/my_app/components/welcome.html #}\n\n<h1>Hello World!</h1>\n```\n\nWith the above in place, you then instantiate the component (e.g., in a view) and pass it to another template for rendering.\n\n```python\n# my_app/views.py\n\nfrom django.shortcuts import render\n\nfrom my_app.components import WelcomePanel\n\n\ndef home(request):\n    welcome = WelcomePanel()  # <-- Instantiates the component\n    return render(\n        request,\n        \"my_app/home.html\",\n        {\"welcome\": welcome},  # <-- Passes the component to the view template\n    )\n```\n\nIn the view template, we `load` the `laces` tag library and use the `{% component %}` tag to render the component.\n\n```html+django\n{# my_app/templates/my_app/home.html #}\n\n{% load laces %}\n{% component welcome %}  {# <-- Renders the component #}\n```\n\nThat's it!\nThe component's template will be rendered right there in the view template.\n\nOf course, this is a very simple example and not much more useful than using a simple `include`.\nWe will go into some more useful use cases below.\n\n### Without a template\n\nBefore we dig deeper into the component use cases, just a quick note that components don't have to have a template.\nFor simple cases that don't require a template, the `render_html` method can be overridden instead.\nIf the return value contains HTML, it should be marked as safe using `django.utils.html.format_html` or `django.utils.safestring.mark_safe`.\n\n```python\n# my_app/components.py\n\nfrom django.utils.html import format_html\nfrom laces.components import Component\n\n\nclass WelcomePanel(Component):\n    def render_html(self, parent_context):\n        return format_html(\"<h1>Hello World!</h1>\")\n```\n\n### Passing context to the component template\n\nNow back to components with templates.\n\nThe example shown above with the static welcome message in the template is, of course, not very useful.\nIt seems more like an overcomplicated way to replace a simple `include`.\n\nBut, we rarely ever want to render templates with static content.\nUsually, we want to pass some context variables to the template to be rendered.\nThis is where components start to become interesting.\n\nThe default implementation of `render_html` calls the component's `get_context_data` method to get the context variables to pass to the template.\nThe default implementation of `get_context_data` returns an empty dictionary.\nTo customize the context variables passed to the template, we can override `get_context_data`.\n\n```python\n# my_app/components.py\n\nfrom laces.components import Component\n\n\nclass WelcomePanel(Component):\n    template_name = \"my_app/components/welcome.html\"\n\n    def get_context_data(self, parent_context):\n        return {\"name\": \"Alice\"}\n```\n\n```html+django\n{# my_app/templates/my_app/components/welcome.html #}\n\n<h1>Hello {{ name }}</h1>\n```\n\nWith the above we are now rendering a welcome message with the name coming from the component's `get_context_data` method.\nNice.\nBut, still not very useful, as the name is still hardcoded â€” in the component method instead of the template, but hardcoded nonetheless.\n\n#### Using class properties\n\nWhen considering how to make the context of our components more useful, it's helpful to remember that components are just normal Python classes and objects.\nSo, you are basically free to get the context data into the component in any way you like.\n\nFor example, we can pass arguments to the constructor and use them in the component's methods, like `get_context_data`.\n\n```python\n# my_app/components.py\n\nfrom laces.components import Component\n\n\nclass WelcomePanel(Component):\n    template_name = \"my_app/components/welcome.html\"\n\n    def __init__(self, name):\n        self.name = name\n\n    def get_context_data(self, parent_context):\n        return {\"name\": self.name}\n```\n\nNice, this is getting better.\nNow we can pass the name to the component when we instantiate it and pass the component ready to be rendered to the view template.\n\n```python\n# my_app/views.py\n\nfrom django.shortcuts import render\n\nfrom my_app.components import WelcomePanel\n\n\ndef home(request):\n    welcome = WelcomePanel(name=\"Alice\")\n    return render(\n        request,\n        \"my_app/home.html\",\n        {\"welcome\": welcome},\n    )\n```\n\nSo, as mentioned before, we can use the full power of Python classes and objects to provide context data to our components.\nA couple more examples of how components can be used can be found [below](#patterns-for-using-components).\n\n#### Using the parent context\n\nYou may have noticed in the above examples that the `render_html` and `get_context_data` methods take a `parent_context` argument.\nThis is the context of the template that is calling the component.\nThe `parent_context` is passed into the `render_html` method by the `{% component %}` template tag.\nIn the default implementation of the `render_html` method, the `parent_context` is then passed to the `get_context_data` method.\nThe default implementation of the `get_context_data` method, however, ignores the `parent_context` argument and returns an empty dictionary.\nTo make use of it, you will have to override the `get_context_data` method.\n\nRelying on data from the parent context somewhat forgoes some of the benefits of components, which is tying the data and template together.\nEspecially for nested uses of components, you now require that the data in the right format is passed through all layers of templates again.\nIt is usually cleaner to provide all the data needed by the component directly to the component itself.\n\nHowever, there may be cases where this is not possible or desirable.\nFor those cases, you have access to the parent context in the component's `get_context_data` method.\n\n```python\n# my_app/components.py\n\nfrom laces.components import Component\n\n\nclass WelcomePanel(Component):\n    template_name = \"my_app/components/welcome.html\"\n\n    def get_context_data(self, parent_context):\n        return {\"name\": parent_context[\"request\"].user.first_name}\n```\n\n(Of course, this could have also been achieved by passing the request or user object to the component in the view, but this is just an example.)\n\n### Using components in other templates\n\nAs mentioned in the [first example](#creating-components), components are rendered in other templates using the `{% component %}` tag from the `laces` tag library.\n\nHere is that example from above again, in which the view passes an instance of `WelcomePanel` to the context of `my_app/home.html`.\n\n```python\n# my_app/views.py\n\nfrom django.shortcuts import render\n\nfrom my_app.components import WelcomePanel\n\n\ndef home(request):\n    welcome = WelcomePanel()\n\n    return render(\n        request,\n        \"my_app/home.html\",\n        {\n            \"welcome\": welcome,\n        },\n    )\n```\n\nThen, in the `my_app/templates/my_app/home.html` template we render the welcome panel component as follows:\n\n```html+django\n{# my_app/templates/my_app/home.html #}\n\n{% load laces %}\n{% component welcome %}\n```\n\nThis is the basic usage of components and should cover most cases.\n\nHowever, the `{% component %}` tag also supports some additional features.\nSpecifically, the keywords `with`, `only` and `as` are supported, similar to how they work with the [`{% include %}`](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#std-templatetag-include) tag.\n\n#### Provide additional parent context variables with `with`\n\nYou can pass additional parent context variables to the component using the keyword `with`:\n\n```html+django\n{% component welcome with name=request.user.first_name %}\n```\n\n**Note**: These extra variables will be added to the `parent_context` which is passed to the component's `render_html` and `get_context_data` methods.\nThe default implementation of `get_context_data` ignores the `parent_context` argument, so you will have to override it to make use of the extra variables.\nFor more information see the above section on the [parent context](#using-the-parent-context).\n\n#### Limit the parent context variables with `only`\n\nTo limit the parent context variables passed to the component to only those variables provided by the `with` keyword (and no others from the calling template's context), use `only`:\n\n```html+django\n{% component welcome with name=request.user.first_name only %}\n```\n\n**Note**: Both, `with` and `only`, only affect the `parent_context` which is passed to the component's `render_html` and `get_context_data` methods. They do not have any direct effect on actual context that is passed to the component's template. E.g. if the component's `get_context_data` method returns a dictionary which always contains a key `foo`, then that key will be available in the component's template, regardless of whether `only` was used or not.\n\n#### Store the rendered output in a variable with `as`\n\nTo store the component's rendered output in a variable rather than outputting it immediately, use `as` followed by the variable name:\n\n```html+django\n{% component welcome as welcome_html %}\n\n{{ welcome_html }}\n```\n\n### Adding JavaScript and CSS assets to a component\n\nLike Django form widgets, components can specify associated JavaScript and CSS assets.\nThe assets for a component can be specified in the same way that [Django form assets are defined](https://docs.djangoproject.com/en/5.0/topics/forms/media).\nThis can be achieved using either an inner `Media` class or a dynamic `media` property.\n\nAn inner `Media` class definition looks like this:\n\n```python\n# my_app/components.py\n\nfrom laces.components import Component\n\n\nclass WelcomePanel(Component):\n    template_name = \"my_app/components/welcome.html\"\n\n    class Media:\n        css = {\"all\": (\"my_app/css/welcome-panel.css\",)}\n```\n\nThe more dynamic definition via a `media` property looks like this:\n\n```python\n# my_app/components.py\n\nfrom django.forms import Media\n\nfrom laces.components import Component\n\n\nclass WelcomePanel(Component):\n    template_name = \"my_app/components/welcome.html\"\n\n    @property\n    def media(self):\n        return Media(css={\"all\": (\"my_app/css/welcome-panel.css\",)})\n```\n\n**Note**:\nIt is your template's responsibility to output any media declarations defined on the components.\n\n#### Outputting component media in templates\n\nOnce you have defined the assets on the component in one of the two ways above, you can output them in your templates.\nThis, again, works in the same way as it does for Django form widgets.\nThe component instance will have a `media` property which returns an instance of the `django.forms.Media` class.\nThis is the case, even if you used the nested `Media` class to define the assets.\nThe [string representation of a `Media` objects](https://docs.djangoproject.com/en/5.0/topics/forms/media#s-media-objects) are the HTML declarations to include the assets.\n\nIn the example home template from above, we can output the component's media declarations like so:\n\n```html+django\n{# my_app/templates/my_app/home.html #}\n\n{% load laces %}\n\n<head>\n    {{ welcome.media }}\n<head>\n<body>\n    {% component welcome %}\n</body>\n```\n\n#### Combining media with `MediaContainer`\n\nWhen you have many components in a page, it can be cumbersome to output the media declarations for each component individually.\nTo make that process a bit easier, Laces provides a `MediaContainer` class.\nThe `MediaContainer` class is a subclass of Python's built-in `list` class which combines the `media` of all it's members.\n\nIn a view we can create a `MediaContainer` instance containing several media-defining components and pass it to the view template.\n\n```python\n# my_app/views.py\n\nfrom django.shortcuts import render\nfrom laces.components import MediaContainer\n\nfrom my_app.components import (\n    Dashboard,\n    Footer,\n    Header,\n    Sidebar,\n    WelcomePanel,\n)\n\n\ndef home(request):\n    components = MediaContainer(\n        [\n            Header(),\n            Sidebar(),\n            WelcomePanel(),\n            Dashboard(),\n            Footer(),\n        ]\n    )\n\n    return render(\n        request,\n        \"my_app/home.html\",\n        {\n            \"components\": components,\n        },\n    )\n```\n\nThen, in the view template, we can output the media declarations for all components in the container at once.\n\n```html+django\n{# my_app/templates/my_app/home.html #}\n\n{% load laces %}\n\n<head>\n    {{ components.media }}\n<head>\n<body>\n    {% for component in components %}\n        {% component component %}\n    {% endfor %}\n</body>\n```\n\nThis will output a combined media declaration for all components in the container.\nThe combination of the media declarations follows the behaviour outlined in the [Django documentation](https://docs.djangoproject.com/en/5.0/topics/forms/media/#combining-media-objects).\n\n**Note**:\nThe use of `MediaContainer` is not limited to contain components.\nIt can be used to combine the `media` properties of any kind of objects that have a `media` property.\n\n## Patterns for using components\n\nBelow, we want to show a few more examples of how components can be used that were not covered in the [\"Getting started\" section](#getting-started) above.\n\n### Nesting components\n\nThe combination of data and template that components provide becomes especially useful when components are nested.\n\n```python\n# my_app/components.py\n\nfrom laces.components import Component\n\n\nclass WelcomePanel(Component): ...\n\n\nclass Dashboard(Component):\n    template_name = \"my_app/components/dashboard.html\"\n\n    def __init__(self, user):\n        self.welcome = WelcomePanel(name=user.first_name)\n        ...\n\n    def get_context_data(self, parent_context):\n        return {\"welcome\": self.welcome}\n```\n\nThe template of the \"parent\" component does not need to know anything about the \"child\" component, except for which template variable is a component.\nThe child component already contains the data it needs and knows which template to use to render that data.\n\n```html+django\n{# my_app/templates/my_app/components/dashboard.html #}\n\n{% load laces %}\n\n<div class=\"dashboard\">\n    {% component welcome %}\n\n    ...\n</div>\n```\n\nThe nesting also provides us with a nice data structure we can test.\n\n```python\ndashboard = Dashboard(user=request.user)\n\nassert dashboard.welcome.name == request.user.first_name\n```\n\n### Nested groups of components\n\nThe nesting of components is not limited to single instances.\nWe can also nest groups of components.\n\n```python\n# my_app/components.py\n\nfrom laces.components import Component\n\n\nclass WelcomePanel(Component): ...\n\n\nclass UsagePanel(Component): ...\n\n\nclass TeamPanel(Component): ...\n\n\nclass Dashboard(Component):\n    template_name = \"my_app/components/dashboard.html\"\n\n    def __init__(self, user):\n        self.panels = [\n            WelcomePanel(name=user.first_name),\n            UsagePanel(user=user),\n            TeamPanel(groups=user.groups.all()),\n        ]\n        ...\n\n    def get_context_data(self, parent_context):\n        return {\"panels\": self.panels}\n```\n\n```html+django\n{# my_app/templates/my_app/components/dashboard.html #}\n\n{% load laces %}\n\n<div class=\"dashboard\">\n    {% for panel in panels %}\n        {% component panel %}\n    {% endfor %}\n    ...\n</div>\n```\n\n### Container components\n\nThe [above example](#nested-groups-of-components) is relatively static.\nThe `Dashboard` component always contains the same panels.\n\nYou could also imagine passing the child components in through the constructor.\nThis would make your component into a dynamic container component.\n\n```python\n# my_app/components.py\n\nfrom laces.components import Component\n\n\nclass Section(Component):\n    template_name = \"my_app/components/section.html\"\n\n    def __init__(self, children: list[Component]):\n        self.children = children\n        ...\n\n    def get_context_data(self, parent_context):\n        return {\"children\": self.children}\n\n\nclass Heading(Component): ...\n\n\nclass Paragraph(Component): ...\n\n\nclass Image(Component): ...\n```\n\n```html+django\n{# my_app/templates/my_app/components/section.html #}\n\n{% load laces %}\n<section>\n    {% for child in children %}\n        {% component child %}\n    {% endfor %}\n</section>\n```\n\nThe above `Section` component can take any kind of component as children.\nThe only thing that `Section` requires is that the children can be rendered with the `{% component %}` tag (which all components do).\n\nIn the view, we can now instantiate the `Section` component with any children we want.\n\n```python\n# my_app/views.py\n\nfrom django.shortcuts import render\n\nfrom my_app.components import (\n    Heading,\n    Image,\n    Paragraph,\n    Section,\n)\n\n\ndef home(request):\n    content = Section(\n        children=[\n            Heading(...),\n            Paragraph(...),\n            Image(...),\n        ]\n    )\n\n    return render(\n        request,\n        \"my_app/home.html\",\n        {\"content\": content},\n    )\n```\n\n```html+django\n{# my_app/templates/my_app/home.html #}\n\n{% load laces %}\n\n<body>\n    {% component content %}\n    ...\n</body>\n```\n\n### Using dataclasses\n\nAbove, we showed how to [use class properties](#using-class-properties) to add data to the component's context.\nThis is a very useful and common pattern.\nHowever, it is a bit verbose, especially when you have many properties and directly pass the properties to the template context.\n\nTo make this a little more convenient, we can use [`dataclasses`](https://docs.python.org/3.12/library/dataclasses.html#module-dataclasses).\n\n```python\n# my_app/components.py\n\nfrom dataclasses import dataclass, asdict\n\nfrom laces.components import Component\n\n\n@dataclass\nclass WelcomePanel(Component):\n    template_name = \"my_app/components/welcome.html\"\n\n    name: str\n\n    def get_context_data(self, parent_context):\n        return asdict(self)\n```\n\nWith dataclasses we define the name and type of the properties we want to pass to the component in the class definition.\nThen, we can use the `asdict` function to convert the dataclass instance to a dictionary that can be directly as the template context.\n\nThe `asdict` function only adds keys to the dictionary that were defined as the properties defined in the dataclass.\nIn the above example, the dictionary returned by `asdict` would only contain the `name` key.\nIt would not contain the `template_name` key, because that is set on the class with a value but without a type annotation.\nIf you were to add the type annotation, then the `template_name` key would also be included in the dictionary returned by `asdict`.\n\n### Custom constructor methods\n\nWhen a component has many properties, it can be a pain to pass each property to the constructor individually.\nThis is especially true when the component is used in many places and the data preparation would need to be repeated in each use case.\nCustom constructor methods can help with that.\n\nIn case of our `WelcomePanel` example, we might want to show some more user information, including a profile image and link to the user's profile page.\nWe can add a `classmethod` that takes the user object and returns an instance of the component with all the data needed to render the component.\nWe can also use this method to encapsulate the logic for generating additional data, such as the profile URL.\n\n```python\n# my_app/components.py\n\nfrom django import urls\nfrom dataclasses import dataclass, asdict\n\nfrom laces.components import Component\n\n\n@dataclass\nclass WelcomePanel(Component):\n    template_name = \"my_app/components/welcome.html\"\n\n    first_name: str\n    last_name: str\n    profile_url: str\n    profile_image_url: str\n\n    @classmethod\n    def from_user(cls, user):\n        profile_url = urls.reverse(\"profile\", kwargs={\"pk\": user.pk})\n        return cls(\n            first_name=user.first_name,\n            last_name=user.last_name,\n            profile_url=profile_url,\n            profile_image_url=user.profile.image.url,\n        )\n\n    def get_context_data(self, parent_context):\n        return asdict(self)\n```\n\nNow, we can instantiate the component in the view like so:\n\n```python\n# my_app/views.py\n\nfrom django.shortcuts import render\n\nfrom my_app.components import WelcomePanel\n\n\ndef home(request):\n    welcome = WelcomePanel.from_user(request.user)\n    return render(\n        request,\n        \"my_app/home.html\",\n        {\"welcome\": welcome},\n    )\n```\n\nThe constructor method allows us to keep our view very simple and clean as all the data preparation is encapsulated in the component.\n\nAs in the example above, custom constructor methods pair very well with the use of dataclasses, but they can of course also be used without them.\n\n## About Laces and components\n\n### Why \"Laces\"?\n\n\"Laces\" is somewhat of a reference to the feature of tying data and templates together.\nThe components are also \"self-rendering,\" which could be seen as \"self-reliance,\" which relates to \"bootstrapping.\"\nAnd aren't \"bootstraps\" just a long kind of \"(shoe)laces?\"\n\nFinally, it is a nod to [@mixxorz](https://github.com/mixxorz)'s fantastic [Slippers package](https://github.com/mixxorz/slippers), which also takes a component focused approach to improve the experience when working with Django templates, but in a quite different way.\n\n### Supported versions\n\n- Python >= 3.8\n- Django >= 3.2\n\n## Contributing\n\n### Install\n\nTo make changes to this project, first clone this repository:\n\n```sh\n$ git clone https://github.com/tbrlpld/laces.git\n$ cd laces\n```\n\nWith your preferred virtualenv activated, install the development dependencies:\n\n#### Using pip\n\n```sh\n$ python -m pip install --upgrade pip>=21.3\n$ python -m pip install -e '.[dev]' -U\n```\n\n#### Using flit\n\n```sh\n$ python -m pip install flit\n$ flit install\n```\n\n### pre-commit\n\nNote that this project uses [pre-commit](https://github.com/pre-commit/pre-commit).\nIt is included in the project testing requirements. To set up locally:\n\n```shell\n# initialize pre-commit\n$ pre-commit install\n\n# Optional, run all checks once for this, then the checks will run only on the changed files\n$ git ls-files --others --cached --exclude-standard | xargs pre-commit run --files\n```\n\n### How to run tests\n\nNow you can run all tests like so:\n\n```sh\n$ tox\n```\n\nOr, you can run them for a specific environment:\n\n```sh\n$ tox -e python3.11-django4.2\n```\n\nOr, run only a specific test:\n\n```sh\n$ tox -e python3.11-django4.2 laces.tests.test_file.TestClass.test_method\n```\n\nTo run the test app interactively, use:\n\n```sh\n$ tox -e interactive\n```\n\nYou can now visit `http://localhost:8020/`.\n\n#### Testing with coverage\n\n`tox` is configured to run tests with coverage.\nThe coverage report is combined for all environments.\nThis is done by using the `--append` flag when running coverage in `tox`.\nThis means it will also include previous results.\n\nYou can see the coverage report by running:\n\n```sh\n$ coverage report\n```\n\nTo get a clean report, you can run `coverage erase` before running `tox`.\n\n#### Running tests without `tox`\n\nIf you want to run tests without `tox`, you can use the `testmanage.py` script.\nThis script is a wrapper around Django's `manage.py` and will run tests with the correct settings.\n\nTo make this work, you need to have the `testing` dependencies installed.\n\n```sh\n$ python -m pip install -e '.[testing]' -U\n```\n\nThen you can run tests with:\n\n```sh\n$ ./testmanage.py test\n````\n\nTo run tests with coverage, use:\n\n```sh\n$ coverage run ./testmanage.py test\n```\n\n### Python version management\n\nTox will attempt to find installed Python versions on your machine.\n\nIf you use `pyenv` to manage multiple versions, you can tell `tox` to use those versions.\nTo ensure that `tox` will find Python versions installed with `pyenv` you need [`virtualenv-pyenv`](https://pypi.org/project/virtualenv-pyenv/) (note: this is not `pyenv-virtualenv`).\n`virtualenv-pyenv` is part of the development dependencies (just like `tox` itself).\nAdditionally, you have to set the environment variable `VIRTUALENV_DISCOVERY=pyenv`.\n\n### Publishing\n\nThis project uses the [Trusted Publisher model for PyPI releases](https://docs.pypi.org/trusted-publishers/).\nThis means that publishing is done through GitHub Actions when a [new release is created on GitHub](https://github.com/tbrlpld/laces/releases/new).\n\nTo create a release, you need a Git tag.\nThe tag can either be created on the command line and pushed or in the \"create release\" interface on GitHub.\nThe tag name should be the version number prefixed with a `v` (e.g. `v0.1.0`).\n\nBefore publishing a new release, make sure to update\n\n- the changelog in `CHANGELOG.md`, and\n- the version number in `laces/__init__.py`.\n\nTo manually test publishing the package, you can use `flit`.\nBe sure to configure the `testpypi` repository in your `~/.pypirc` file according to the Flit [documentation](https://flit.pypa.io/en/stable/upload.html#controlling-package-uploads).\nIf your PyPI account is using 2FA, you'll need to create a [PyPI API token](https://test.pypi.org/help/#apitoken) and use that as your password and `__token__` as the username.\n\nWhen you're ready to test the publishing, run:\n\n```shell\n$ flit build\n$ flit publish --repository testpypi\n```\n\n","description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"","keywords":"","license":"","maintainer":"","maintainer_email":"","name":"laces","package_url":"https://pypi.org/project/laces/","platform":null,"project_url":"https://pypi.org/project/laces/","project_urls":{"Home":"https://github.com/tbrlpld/laces"},"provides_extra":null,"release_url":"https://pypi.org/project/laces/0.1.1/","requires_dist":["Django>=3.2","tox==4.12.1 ; extra == \"dev\"","tox-gh-actions==3.2.0 ; extra == \"dev\"","virtualenv-pyenv==0.4.0 ; extra == \"dev\"","coverage==7.3.4 ; extra == \"dev\"","pre-commit==3.4.0 ; extra == \"dev\"","black==24.1.1 ; extra == \"dev\"","blacken-docs==1.16.0 ; extra == \"dev\"","isort==5.13.2 ; extra == \"dev\"","flake8==7.0.0 ; extra == \"dev\"","flake8-bugbear ; extra == \"dev\"","flake8-comprehensions ; extra == \"dev\"","mypy==1.7.1 ; extra == \"dev\"","django-stubs[compatible-mypy]==4.2.7 ; extra == \"dev\"","types-requests==2.31.0.20240125 ; extra == \"dev\"","dj-database-url==2.1.0 ; extra == \"testing\"","coverage==7.3.4 ; extra == \"testing\""],"requires_python":">=3.8","summary":"Django components that know how to render themselves.","version":"0.1.1","yanked":false,"yanked_reason":null},"last_serial":21820896,"releases":{"0.1.0":[{"comment_text":"","digests":{"blake2b_256":"8fe522efd49a229dfdab54b336fe63bdf3cda4a53e63d319d4c2b7d3da7981e5","md5":"2139099c597420afbcc9936daf681425","sha256":"2f97c2863eea99a1a151d16a9b413aa3f95daa763080a387267d886d8c0f1922"},"downloads":-1,"filename":"laces-0.1.0-py3-none-any.whl","has_sig":false,"md5_digest":"2139099c597420afbcc9936daf681425","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.8","size":9858,"upload_time":"2023-11-29T21:31:51","upload_time_iso_8601":"2023-11-29T21:31:51.877181Z","url":"https://files.pythonhosted.org/packages/8f/e5/22efd49a229dfdab54b336fe63bdf3cda4a53e63d319d4c2b7d3da7981e5/laces-0.1.0-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"d2d14307905433191ac8ef8745a485755091a57b47cb15f34c70c85677ee82c3","md5":"913bfb7a38b7b70a29e1a0257ad59324","sha256":"1ea9980a040efb7299084bb8bf829088575cb0cccbf91987bbf9f195a81787b1"},"downloads":-1,"filename":"laces-0.1.0.tar.gz","has_sig":false,"md5_digest":"913bfb7a38b7b70a29e1a0257ad59324","packagetype":"sdist","python_version":"source","requires_python":">=3.8","size":11710,"upload_time":"2023-11-29T21:31:53","upload_time_iso_8601":"2023-11-29T21:31:53.520684Z","url":"https://files.pythonhosted.org/packages/d2/d1/4307905433191ac8ef8745a485755091a57b47cb15f34c70c85677ee82c3/laces-0.1.0.tar.gz","yanked":false,"yanked_reason":null}],"0.1.1":[{"comment_text":"","digests":{"blake2b_256":"e0dcceadbdc5e14aec7bd01bdd6ef8d5bf704d6a12d1b5a25bcaaa066bdb820d","md5":"b92194c9dff29f295ca1509e2a327205","sha256":"ae2c575b9aaa46154e5518c61c9f86f5a9478f753a51e9c5547c7d275d361242"},"downloads":-1,"filename":"laces-0.1.1-py3-none-any.whl","has_sig":false,"md5_digest":"b92194c9dff29f295ca1509e2a327205","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.8","size":21349,"upload_time":"2024-02-10T23:34:20","upload_time_iso_8601":"2024-02-10T23:34:20.370485Z","url":"https://files.pythonhosted.org/packages/e0/dc/ceadbdc5e14aec7bd01bdd6ef8d5bf704d6a12d1b5a25bcaaa066bdb820d/laces-0.1.1-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"a2cbd69f2cbb248bd6baceb7597d8c6c229797689b546ac2a446fac15b8f455f","md5":"e75e453948f7a0caeb40141d54ede959","sha256":"e45159c46f6adca33010d34e9af869e57201b70675c6dc088e919b16c89456a4"},"downloads":-1,"filename":"laces-0.1.1.tar.gz","has_sig":false,"md5_digest":"e75e453948f7a0caeb40141d54ede959","packagetype":"sdist","python_version":"source","requires_python":">=3.8","size":26889,"upload_time":"2024-02-10T23:34:22","upload_time_iso_8601":"2024-02-10T23:34:22.055446Z","url":"https://files.pythonhosted.org/packages/a2/cb/d69f2cbb248bd6baceb7597d8c6c229797689b546ac2a446fac15b8f455f/laces-0.1.1.tar.gz","yanked":false,"yanked_reason":null}]},"urls":[{"comment_text":"","digests":{"blake2b_256":"e0dcceadbdc5e14aec7bd01bdd6ef8d5bf704d6a12d1b5a25bcaaa066bdb820d","md5":"b92194c9dff29f295ca1509e2a327205","sha256":"ae2c575b9aaa46154e5518c61c9f86f5a9478f753a51e9c5547c7d275d361242"},"downloads":-1,"filename":"laces-0.1.1-py3-none-any.whl","has_sig":false,"md5_digest":"b92194c9dff29f295ca1509e2a327205","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.8","size":21349,"upload_time":"2024-02-10T23:34:20","upload_time_iso_8601":"2024-02-10T23:34:20.370485Z","url":"https://files.pythonhosted.org/packages/e0/dc/ceadbdc5e14aec7bd01bdd6ef8d5bf704d6a12d1b5a25bcaaa066bdb820d/laces-0.1.1-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"a2cbd69f2cbb248bd6baceb7597d8c6c229797689b546ac2a446fac15b8f455f","md5":"e75e453948f7a0caeb40141d54ede959","sha256":"e45159c46f6adca33010d34e9af869e57201b70675c6dc088e919b16c89456a4"},"downloads":-1,"filename":"laces-0.1.1.tar.gz","has_sig":false,"md5_digest":"e75e453948f7a0caeb40141d54ede959","packagetype":"sdist","python_version":"source","requires_python":">=3.8","size":26889,"upload_time":"2024-02-10T23:34:22","upload_time_iso_8601":"2024-02-10T23:34:22.055446Z","url":"https://files.pythonhosted.org/packages/a2/cb/d69f2cbb248bd6baceb7597d8c6c229797689b546ac2a446fac15b8f455f/laces-0.1.1.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[]}
